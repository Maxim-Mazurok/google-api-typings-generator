/* This is stub file for gapi.client.storage-v1 definition tests */
// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator

// Revision: 20250906

gapi.load('client', async () => {
  /** now we can use gapi.client */

  await gapi.client.load(
    'https://storage.googleapis.com/$discovery/rest?version=v1',
  );
  /** now we can use gapi.client.storage */

  /** don't forget to authenticate your client before sending any request to resources: */
  /** declare client_id registered in Google Developers Console */
  const client_id = '<<PUT YOUR CLIENT ID HERE>>';
  const scope = [
    /** View and manage your data across Google Cloud Platform services */
    'https://www.googleapis.com/auth/cloud-platform',
    /** View your data across Google Cloud Platform services */
    'https://www.googleapis.com/auth/cloud-platform.read-only',
    /** Manage your data and permissions in Google Cloud Storage */
    'https://www.googleapis.com/auth/devstorage.full_control',
    /** View your data in Google Cloud Storage */
    'https://www.googleapis.com/auth/devstorage.read_only',
    /** Manage your data in Google Cloud Storage */
    'https://www.googleapis.com/auth/devstorage.read_write',
  ];
  const immediate = false;
  gapi.auth.authorize({client_id, scope, immediate}, authResult => {
    if (authResult && !authResult.error) {
      /** handle successful authorization */
      void run();
    } else {
      /** handle authorization error */
    }
  });

  async function run() {
    /** Disables an Anywhere Cache instance. */
    await gapi.client.storage.anywhereCaches.disable({
      anywhereCacheId: 'Test string',
      bucket: 'Test string',
    });
    /** Returns the metadata of an Anywhere Cache instance. */
    await gapi.client.storage.anywhereCaches.get({
      anywhereCacheId: 'Test string',
      bucket: 'Test string',
    });
    /** Creates an Anywhere Cache instance. */
    await gapi.client.storage.anywhereCaches.insert(
      {
        bucket: 'Test string',
      },
      {
        admissionPolicy: 'Test string',
        anywhereCacheId: 'Test string',
        bucket: 'Test string',
        createTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        pendingUpdate: true,
        selfLink: 'Test string',
        state: 'Test string',
        ttl: 'Test string',
        updateTime: 'Test string',
        zone: 'Test string',
      },
    );
    /** Returns a list of Anywhere Cache instances of the bucket matching the criteria. */
    await gapi.client.storage.anywhereCaches.list({
      bucket: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Pauses an Anywhere Cache instance. */
    await gapi.client.storage.anywhereCaches.pause({
      anywhereCacheId: 'Test string',
      bucket: 'Test string',
    });
    /** Resumes a paused or disabled Anywhere Cache instance. */
    await gapi.client.storage.anywhereCaches.resume({
      anywhereCacheId: 'Test string',
      bucket: 'Test string',
    });
    /** Updates the config(ttl and admissionPolicy) of an Anywhere Cache instance. */
    await gapi.client.storage.anywhereCaches.update(
      {
        anywhereCacheId: 'Test string',
        bucket: 'Test string',
      },
      {
        admissionPolicy: 'Test string',
        anywhereCacheId: 'Test string',
        bucket: 'Test string',
        createTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        pendingUpdate: true,
        selfLink: 'Test string',
        state: 'Test string',
        ttl: 'Test string',
        updateTime: 'Test string',
        zone: 'Test string',
      },
    );
    /** Permanently deletes the ACL entry for the specified entity on the specified bucket. */
    await gapi.client.storage.bucketAccessControls.delete({
      bucket: 'Test string',
      entity: 'Test string',
      userProject: 'Test string',
    });
    /** Returns the ACL entry for the specified entity on the specified bucket. */
    await gapi.client.storage.bucketAccessControls.get({
      bucket: 'Test string',
      entity: 'Test string',
      userProject: 'Test string',
    });
    /** Creates a new ACL entry on the specified bucket. */
    await gapi.client.storage.bucketAccessControls.insert(
      {
        bucket: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Retrieves ACL entries on the specified bucket. */
    await gapi.client.storage.bucketAccessControls.list({
      bucket: 'Test string',
      userProject: 'Test string',
    });
    /** Patches an ACL entry on the specified bucket. */
    await gapi.client.storage.bucketAccessControls.patch(
      {
        bucket: 'Test string',
        entity: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Updates an ACL entry on the specified bucket. */
    await gapi.client.storage.bucketAccessControls.update(
      {
        bucket: 'Test string',
        entity: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Deletes an empty bucket. Deletions are permanent unless soft delete is enabled on the bucket. */
    await gapi.client.storage.buckets.delete({
      bucket: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      userProject: 'Test string',
    });
    /** Returns metadata for the specified bucket. */
    await gapi.client.storage.buckets.get({
      bucket: 'Test string',
      generation: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      projection: 'Test string',
      softDeleted: true,
      userProject: 'Test string',
    });
    /** Returns an IAM policy for the specified bucket. */
    await gapi.client.storage.buckets.getIamPolicy({
      bucket: 'Test string',
      optionsRequestedPolicyVersion: 42,
      userProject: 'Test string',
    });
    /** Returns the storage layout configuration for the specified bucket. Note that this operation requires storage.objects.list permission. */
    await gapi.client.storage.buckets.getStorageLayout({
      bucket: 'Test string',
      prefix: 'Test string',
    });
    /** Creates a new bucket. */
    await gapi.client.storage.buckets.insert(
      {
        enableObjectRetention: true,
        predefinedAcl: 'Test string',
        predefinedDefaultObjectAcl: 'Test string',
        project: 'Test string',
        projection: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        autoclass: {
          enabled: true,
          terminalStorageClass: 'Test string',
          terminalStorageClassUpdateTime: 'Test string',
          toggleTime: 'Test string',
        },
        billing: {
          requesterPays: true,
        },
        cors: [
          {
            maxAgeSeconds: 42,
            method: ['Test string'],
            origin: ['Test string'],
            responseHeader: ['Test string'],
          },
        ],
        customPlacementConfig: {
          dataLocations: ['Test string'],
        },
        defaultEventBasedHold: true,
        defaultObjectAcl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        encryption: {
          customerManagedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
          customerSuppliedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
          defaultKmsKeyName: 'Test string',
          googleManagedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
        },
        etag: 'Test string',
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        hierarchicalNamespace: {
          enabled: true,
        },
        iamConfiguration: {
          bucketPolicyOnly: {
            enabled: true,
            lockedTime: 'Test string',
          },
          publicAccessPrevention: 'Test string',
          uniformBucketLevelAccess: {
            enabled: true,
            lockedTime: 'Test string',
          },
        },
        id: 'Test string',
        ipFilter: {
          allowAllServiceAgentAccess: true,
          allowCrossOrgVpcs: true,
          mode: 'Test string',
          publicNetworkSource: {
            allowedIpCidrRanges: ['Test string'],
          },
          vpcNetworkSources: [
            {
              allowedIpCidrRanges: ['Test string'],
              network: 'Test string',
            },
          ],
        },
        kind: 'Test string',
        labels: {
          A: 'Test string',
        },
        lifecycle: {
          rule: [
            {
              action: {
                storageClass: 'Test string',
                type: 'Test string',
              },
              condition: {
                age: 42,
                createdBefore: 'Test string',
                customTimeBefore: 'Test string',
                daysSinceCustomTime: 42,
                daysSinceNoncurrentTime: 42,
                isLive: true,
                matchesPattern: 'Test string',
                matchesPrefix: ['Test string'],
                matchesStorageClass: ['Test string'],
                matchesSuffix: ['Test string'],
                noncurrentTimeBefore: 'Test string',
                numNewerVersions: 42,
              },
            },
          ],
        },
        location: 'Test string',
        locationType: 'Test string',
        logging: {
          logBucket: 'Test string',
          logObjectPrefix: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        objectRetention: {
          mode: 'Test string',
        },
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        projectNumber: 'Test string',
        retentionPolicy: {
          effectiveTime: 'Test string',
          isLocked: true,
          retentionPeriod: 'Test string',
        },
        rpo: 'Test string',
        satisfiesPZI: true,
        satisfiesPZS: true,
        selfLink: 'Test string',
        softDeletePolicy: {
          effectiveTime: 'Test string',
          retentionDurationSeconds: 'Test string',
        },
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        timeCreated: 'Test string',
        updated: 'Test string',
        versioning: {
          enabled: true,
        },
        website: {
          mainPageSuffix: 'Test string',
          notFoundPage: 'Test string',
        },
      },
    );
    /** Retrieves a list of buckets for a given project. */
    await gapi.client.storage.buckets.list({
      maxResults: 42,
      pageToken: 'Test string',
      prefix: 'Test string',
      project: 'Test string',
      projection: 'Test string',
      softDeleted: true,
      userProject: 'Test string',
    });
    /** Locks retention policy on a bucket. */
    await gapi.client.storage.buckets.lockRetentionPolicy({
      bucket: 'Test string',
      ifMetagenerationMatch: 'Test string',
      userProject: 'Test string',
    });
    /** Patches a bucket. Changes to the bucket will be readable immediately after writing, but configuration changes may take time to propagate. */
    await gapi.client.storage.buckets.patch(
      {
        bucket: 'Test string',
        ifMetagenerationMatch: 'Test string',
        ifMetagenerationNotMatch: 'Test string',
        predefinedAcl: 'Test string',
        predefinedDefaultObjectAcl: 'Test string',
        projection: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        autoclass: {
          enabled: true,
          terminalStorageClass: 'Test string',
          terminalStorageClassUpdateTime: 'Test string',
          toggleTime: 'Test string',
        },
        billing: {
          requesterPays: true,
        },
        cors: [
          {
            maxAgeSeconds: 42,
            method: ['Test string'],
            origin: ['Test string'],
            responseHeader: ['Test string'],
          },
        ],
        customPlacementConfig: {
          dataLocations: ['Test string'],
        },
        defaultEventBasedHold: true,
        defaultObjectAcl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        encryption: {
          customerManagedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
          customerSuppliedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
          defaultKmsKeyName: 'Test string',
          googleManagedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
        },
        etag: 'Test string',
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        hierarchicalNamespace: {
          enabled: true,
        },
        iamConfiguration: {
          bucketPolicyOnly: {
            enabled: true,
            lockedTime: 'Test string',
          },
          publicAccessPrevention: 'Test string',
          uniformBucketLevelAccess: {
            enabled: true,
            lockedTime: 'Test string',
          },
        },
        id: 'Test string',
        ipFilter: {
          allowAllServiceAgentAccess: true,
          allowCrossOrgVpcs: true,
          mode: 'Test string',
          publicNetworkSource: {
            allowedIpCidrRanges: ['Test string'],
          },
          vpcNetworkSources: [
            {
              allowedIpCidrRanges: ['Test string'],
              network: 'Test string',
            },
          ],
        },
        kind: 'Test string',
        labels: {
          A: 'Test string',
        },
        lifecycle: {
          rule: [
            {
              action: {
                storageClass: 'Test string',
                type: 'Test string',
              },
              condition: {
                age: 42,
                createdBefore: 'Test string',
                customTimeBefore: 'Test string',
                daysSinceCustomTime: 42,
                daysSinceNoncurrentTime: 42,
                isLive: true,
                matchesPattern: 'Test string',
                matchesPrefix: ['Test string'],
                matchesStorageClass: ['Test string'],
                matchesSuffix: ['Test string'],
                noncurrentTimeBefore: 'Test string',
                numNewerVersions: 42,
              },
            },
          ],
        },
        location: 'Test string',
        locationType: 'Test string',
        logging: {
          logBucket: 'Test string',
          logObjectPrefix: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        objectRetention: {
          mode: 'Test string',
        },
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        projectNumber: 'Test string',
        retentionPolicy: {
          effectiveTime: 'Test string',
          isLocked: true,
          retentionPeriod: 'Test string',
        },
        rpo: 'Test string',
        satisfiesPZI: true,
        satisfiesPZS: true,
        selfLink: 'Test string',
        softDeletePolicy: {
          effectiveTime: 'Test string',
          retentionDurationSeconds: 'Test string',
        },
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        timeCreated: 'Test string',
        updated: 'Test string',
        versioning: {
          enabled: true,
        },
        website: {
          mainPageSuffix: 'Test string',
          notFoundPage: 'Test string',
        },
      },
    );
    /** Initiates a long-running Relocate Bucket operation on the specified bucket. */
    await gapi.client.storage.buckets.relocate(
      {
        bucket: 'Test string',
      },
      {
        destinationCustomPlacementConfig: {
          dataLocations: ['Test string'],
        },
        destinationLocation: 'Test string',
        validateOnly: true,
      },
    );
    /** Restores a soft-deleted bucket. */
    await gapi.client.storage.buckets.restore({
      bucket: 'Test string',
      generation: 'Test string',
      projection: 'Test string',
      userProject: 'Test string',
    });
    /** Updates an IAM policy for the specified bucket. */
    await gapi.client.storage.buckets.setIamPolicy(
      {
        bucket: 'Test string',
        userProject: 'Test string',
      },
      {
        bindings: [
          {
            condition: {
              description: 'Test string',
              expression: 'Test string',
              location: 'Test string',
              title: 'Test string',
            },
            members: ['Test string'],
            role: 'Test string',
          },
        ],
        etag: 'Test string',
        kind: 'Test string',
        resourceId: 'Test string',
        version: 42,
      },
    );
    /** Tests a set of permissions on the given bucket to see which, if any, are held by the caller. */
    await gapi.client.storage.buckets.testIamPermissions({
      bucket: 'Test string',
      permissions: 'Test string',
      userProject: 'Test string',
    });
    /** Updates a bucket. Changes to the bucket will be readable immediately after writing, but configuration changes may take time to propagate. */
    await gapi.client.storage.buckets.update(
      {
        bucket: 'Test string',
        ifMetagenerationMatch: 'Test string',
        ifMetagenerationNotMatch: 'Test string',
        predefinedAcl: 'Test string',
        predefinedDefaultObjectAcl: 'Test string',
        projection: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        autoclass: {
          enabled: true,
          terminalStorageClass: 'Test string',
          terminalStorageClassUpdateTime: 'Test string',
          toggleTime: 'Test string',
        },
        billing: {
          requesterPays: true,
        },
        cors: [
          {
            maxAgeSeconds: 42,
            method: ['Test string'],
            origin: ['Test string'],
            responseHeader: ['Test string'],
          },
        ],
        customPlacementConfig: {
          dataLocations: ['Test string'],
        },
        defaultEventBasedHold: true,
        defaultObjectAcl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        encryption: {
          customerManagedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
          customerSuppliedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
          defaultKmsKeyName: 'Test string',
          googleManagedEncryptionEnforcementConfig: {
            effectiveTime: 'Test string',
            restrictionMode: 'Test string',
          },
        },
        etag: 'Test string',
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        hierarchicalNamespace: {
          enabled: true,
        },
        iamConfiguration: {
          bucketPolicyOnly: {
            enabled: true,
            lockedTime: 'Test string',
          },
          publicAccessPrevention: 'Test string',
          uniformBucketLevelAccess: {
            enabled: true,
            lockedTime: 'Test string',
          },
        },
        id: 'Test string',
        ipFilter: {
          allowAllServiceAgentAccess: true,
          allowCrossOrgVpcs: true,
          mode: 'Test string',
          publicNetworkSource: {
            allowedIpCidrRanges: ['Test string'],
          },
          vpcNetworkSources: [
            {
              allowedIpCidrRanges: ['Test string'],
              network: 'Test string',
            },
          ],
        },
        kind: 'Test string',
        labels: {
          A: 'Test string',
        },
        lifecycle: {
          rule: [
            {
              action: {
                storageClass: 'Test string',
                type: 'Test string',
              },
              condition: {
                age: 42,
                createdBefore: 'Test string',
                customTimeBefore: 'Test string',
                daysSinceCustomTime: 42,
                daysSinceNoncurrentTime: 42,
                isLive: true,
                matchesPattern: 'Test string',
                matchesPrefix: ['Test string'],
                matchesStorageClass: ['Test string'],
                matchesSuffix: ['Test string'],
                noncurrentTimeBefore: 'Test string',
                numNewerVersions: 42,
              },
            },
          ],
        },
        location: 'Test string',
        locationType: 'Test string',
        logging: {
          logBucket: 'Test string',
          logObjectPrefix: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        objectRetention: {
          mode: 'Test string',
        },
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        projectNumber: 'Test string',
        retentionPolicy: {
          effectiveTime: 'Test string',
          isLocked: true,
          retentionPeriod: 'Test string',
        },
        rpo: 'Test string',
        satisfiesPZI: true,
        satisfiesPZS: true,
        selfLink: 'Test string',
        softDeletePolicy: {
          effectiveTime: 'Test string',
          retentionDurationSeconds: 'Test string',
        },
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        timeCreated: 'Test string',
        updated: 'Test string',
        versioning: {
          enabled: true,
        },
        website: {
          mainPageSuffix: 'Test string',
          notFoundPage: 'Test string',
        },
      },
    );
    /** Stop watching resources through this channel */
    await gapi.client.storage.channels.stop(
      {},
      {
        address: 'Test string',
        expiration: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        params: {
          A: 'Test string',
        },
        payload: true,
        resourceId: 'Test string',
        resourceUri: 'Test string',
        token: 'Test string',
        type: 'Test string',
      },
    );
    /** Permanently deletes the default object ACL entry for the specified entity on the specified bucket. */
    await gapi.client.storage.defaultObjectAccessControls.delete({
      bucket: 'Test string',
      entity: 'Test string',
      userProject: 'Test string',
    });
    /** Returns the default object ACL entry for the specified entity on the specified bucket. */
    await gapi.client.storage.defaultObjectAccessControls.get({
      bucket: 'Test string',
      entity: 'Test string',
      userProject: 'Test string',
    });
    /** Creates a new default object ACL entry on the specified bucket. */
    await gapi.client.storage.defaultObjectAccessControls.insert(
      {
        bucket: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        generation: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        object: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Retrieves default object ACL entries on the specified bucket. */
    await gapi.client.storage.defaultObjectAccessControls.list({
      bucket: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      userProject: 'Test string',
    });
    /** Patches a default object ACL entry on the specified bucket. */
    await gapi.client.storage.defaultObjectAccessControls.patch(
      {
        bucket: 'Test string',
        entity: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        generation: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        object: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Updates a default object ACL entry on the specified bucket. */
    await gapi.client.storage.defaultObjectAccessControls.update(
      {
        bucket: 'Test string',
        entity: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        generation: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        object: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Permanently deletes a folder. Only applicable to buckets with hierarchical namespace enabled. */
    await gapi.client.storage.folders.delete({
      bucket: 'Test string',
      folder: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
    });
    /** Returns metadata for the specified folder. Only applicable to buckets with hierarchical namespace enabled. */
    await gapi.client.storage.folders.get({
      bucket: 'Test string',
      folder: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
    });
    /** Creates a new folder. Only applicable to buckets with hierarchical namespace enabled. */
    await gapi.client.storage.folders.insert(
      {
        bucket: 'Test string',
        recursive: true,
      },
      {
        bucket: 'Test string',
        createTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        metageneration: 'Test string',
        name: 'Test string',
        pendingRenameInfo: {
          operationId: 'Test string',
        },
        selfLink: 'Test string',
        updateTime: 'Test string',
      },
    );
    /** Retrieves a list of folders matching the criteria. Only applicable to buckets with hierarchical namespace enabled. */
    await gapi.client.storage.folders.list({
      bucket: 'Test string',
      delimiter: 'Test string',
      endOffset: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      prefix: 'Test string',
      startOffset: 'Test string',
    });
    /** Renames a source folder to a destination folder. Only applicable to buckets with hierarchical namespace enabled. */
    await gapi.client.storage.folders.rename({
      bucket: 'Test string',
      destinationFolder: 'Test string',
      ifSourceMetagenerationMatch: 'Test string',
      ifSourceMetagenerationNotMatch: 'Test string',
      sourceFolder: 'Test string',
    });
    /** Permanently deletes a managed folder. */
    await gapi.client.storage.managedFolders.delete({
      allowNonEmpty: true,
      bucket: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      managedFolder: 'Test string',
    });
    /** Returns metadata of the specified managed folder. */
    await gapi.client.storage.managedFolders.get({
      bucket: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      managedFolder: 'Test string',
    });
    /** Returns an IAM policy for the specified managed folder. */
    await gapi.client.storage.managedFolders.getIamPolicy({
      bucket: 'Test string',
      managedFolder: 'Test string',
      optionsRequestedPolicyVersion: 42,
      userProject: 'Test string',
    });
    /** Creates a new managed folder. */
    await gapi.client.storage.managedFolders.insert(
      {
        bucket: 'Test string',
      },
      {
        bucket: 'Test string',
        createTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        metageneration: 'Test string',
        name: 'Test string',
        selfLink: 'Test string',
        updateTime: 'Test string',
      },
    );
    /** Lists managed folders in the given bucket. */
    await gapi.client.storage.managedFolders.list({
      bucket: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      prefix: 'Test string',
    });
    /** Updates an IAM policy for the specified managed folder. */
    await gapi.client.storage.managedFolders.setIamPolicy(
      {
        bucket: 'Test string',
        managedFolder: 'Test string',
        userProject: 'Test string',
      },
      {
        bindings: [
          {
            condition: {
              description: 'Test string',
              expression: 'Test string',
              location: 'Test string',
              title: 'Test string',
            },
            members: ['Test string'],
            role: 'Test string',
          },
        ],
        etag: 'Test string',
        kind: 'Test string',
        resourceId: 'Test string',
        version: 42,
      },
    );
    /** Tests a set of permissions on the given managed folder to see which, if any, are held by the caller. */
    await gapi.client.storage.managedFolders.testIamPermissions({
      bucket: 'Test string',
      managedFolder: 'Test string',
      permissions: 'Test string',
      userProject: 'Test string',
    });
    /** Permanently deletes a notification subscription. */
    await gapi.client.storage.notifications.delete({
      bucket: 'Test string',
      notification: 'Test string',
      userProject: 'Test string',
    });
    /** View a notification configuration. */
    await gapi.client.storage.notifications.get({
      bucket: 'Test string',
      notification: 'Test string',
      userProject: 'Test string',
    });
    /** Creates a notification subscription for a given bucket. */
    await gapi.client.storage.notifications.insert(
      {
        bucket: 'Test string',
        userProject: 'Test string',
      },
      {
        custom_attributes: {
          A: 'Test string',
        },
        etag: 'Test string',
        event_types: ['Test string'],
        id: 'Test string',
        kind: 'Test string',
        object_name_prefix: 'Test string',
        payload_format: 'Test string',
        selfLink: 'Test string',
        topic: 'Test string',
      },
    );
    /** Retrieves a list of notification subscriptions for a given bucket. */
    await gapi.client.storage.notifications.list({
      bucket: 'Test string',
      userProject: 'Test string',
    });
    /** Permanently deletes the ACL entry for the specified entity on the specified object. */
    await gapi.client.storage.objectAccessControls.delete({
      bucket: 'Test string',
      entity: 'Test string',
      generation: 'Test string',
      object: 'Test string',
      userProject: 'Test string',
    });
    /** Returns the ACL entry for the specified entity on the specified object. */
    await gapi.client.storage.objectAccessControls.get({
      bucket: 'Test string',
      entity: 'Test string',
      generation: 'Test string',
      object: 'Test string',
      userProject: 'Test string',
    });
    /** Creates a new ACL entry on the specified object. */
    await gapi.client.storage.objectAccessControls.insert(
      {
        bucket: 'Test string',
        generation: 'Test string',
        object: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        generation: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        object: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Retrieves ACL entries on the specified object. */
    await gapi.client.storage.objectAccessControls.list({
      bucket: 'Test string',
      generation: 'Test string',
      object: 'Test string',
      userProject: 'Test string',
    });
    /** Patches an ACL entry on the specified object. */
    await gapi.client.storage.objectAccessControls.patch(
      {
        bucket: 'Test string',
        entity: 'Test string',
        generation: 'Test string',
        object: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        generation: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        object: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Updates an ACL entry on the specified object. */
    await gapi.client.storage.objectAccessControls.update(
      {
        bucket: 'Test string',
        entity: 'Test string',
        generation: 'Test string',
        object: 'Test string',
        userProject: 'Test string',
      },
      {
        bucket: 'Test string',
        domain: 'Test string',
        email: 'Test string',
        entity: 'Test string',
        entityId: 'Test string',
        etag: 'Test string',
        generation: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        object: 'Test string',
        projectTeam: {
          projectNumber: 'Test string',
          team: 'Test string',
        },
        role: 'Test string',
        selfLink: 'Test string',
      },
    );
    /** Initiates a long-running bulk restore operation on the specified bucket. */
    await gapi.client.storage.objects.bulkRestore(
      {
        bucket: 'Test string',
      },
      {
        allowOverwrite: true,
        copySourceAcl: true,
        createdAfterTime: 'Test string',
        createdBeforeTime: 'Test string',
        matchGlobs: ['Test string'],
        softDeletedAfterTime: 'Test string',
        softDeletedBeforeTime: 'Test string',
      },
    );
    /** Concatenates a list of existing objects into a new object in the same bucket. */
    await gapi.client.storage.objects.compose(
      {
        destinationBucket: 'Test string',
        destinationObject: 'Test string',
        destinationPredefinedAcl: 'Test string',
        ifGenerationMatch: 'Test string',
        ifMetagenerationMatch: 'Test string',
        kmsKeyName: 'Test string',
        userProject: 'Test string',
      },
      {
        destination: {
          acl: [
            {
              bucket: 'Test string',
              domain: 'Test string',
              email: 'Test string',
              entity: 'Test string',
              entityId: 'Test string',
              etag: 'Test string',
              generation: 'Test string',
              id: 'Test string',
              kind: 'Test string',
              object: 'Test string',
              projectTeam: {
                projectNumber: 'Test string',
                team: 'Test string',
              },
              role: 'Test string',
              selfLink: 'Test string',
            },
          ],
          bucket: 'Test string',
          cacheControl: 'Test string',
          componentCount: 42,
          contentDisposition: 'Test string',
          contentEncoding: 'Test string',
          contentLanguage: 'Test string',
          contentType: 'Test string',
          contexts: {
            custom: {
              A: {
                createTime: 'Test string',
                updateTime: 'Test string',
                value: 'Test string',
              },
            },
          },
          crc32c: 'Test string',
          customerEncryption: {
            encryptionAlgorithm: 'Test string',
            keySha256: 'Test string',
          },
          customTime: 'Test string',
          etag: 'Test string',
          eventBasedHold: true,
          generation: 'Test string',
          hardDeleteTime: 'Test string',
          id: 'Test string',
          kind: 'Test string',
          kmsKeyName: 'Test string',
          md5Hash: 'Test string',
          mediaLink: 'Test string',
          metadata: {
            A: 'Test string',
          },
          metageneration: 'Test string',
          name: 'Test string',
          owner: {
            entity: 'Test string',
            entityId: 'Test string',
          },
          restoreToken: 'Test string',
          retention: {
            mode: 'Test string',
            retainUntilTime: 'Test string',
          },
          retentionExpirationTime: 'Test string',
          selfLink: 'Test string',
          size: 'Test string',
          softDeleteTime: 'Test string',
          storageClass: 'Test string',
          temporaryHold: true,
          timeCreated: 'Test string',
          timeDeleted: 'Test string',
          timeFinalized: 'Test string',
          timeStorageClassUpdated: 'Test string',
          updated: 'Test string',
        },
        kind: 'Test string',
        sourceObjects: [
          {
            generation: 'Test string',
            name: 'Test string',
            objectPreconditions: {
              ifGenerationMatch: 'Test string',
            },
          },
        ],
      },
    );
    /** Copies a source object to a destination object. Optionally overrides metadata. */
    await gapi.client.storage.objects.copy(
      {
        destinationBucket: 'Test string',
        destinationKmsKeyName: 'Test string',
        destinationObject: 'Test string',
        destinationPredefinedAcl: 'Test string',
        ifGenerationMatch: 'Test string',
        ifGenerationNotMatch: 'Test string',
        ifMetagenerationMatch: 'Test string',
        ifMetagenerationNotMatch: 'Test string',
        ifSourceGenerationMatch: 'Test string',
        ifSourceGenerationNotMatch: 'Test string',
        ifSourceMetagenerationMatch: 'Test string',
        ifSourceMetagenerationNotMatch: 'Test string',
        projection: 'Test string',
        sourceBucket: 'Test string',
        sourceGeneration: 'Test string',
        sourceObject: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        bucket: 'Test string',
        cacheControl: 'Test string',
        componentCount: 42,
        contentDisposition: 'Test string',
        contentEncoding: 'Test string',
        contentLanguage: 'Test string',
        contentType: 'Test string',
        contexts: {
          custom: {
            A: {
              createTime: 'Test string',
              updateTime: 'Test string',
              value: 'Test string',
            },
          },
        },
        crc32c: 'Test string',
        customerEncryption: {
          encryptionAlgorithm: 'Test string',
          keySha256: 'Test string',
        },
        customTime: 'Test string',
        etag: 'Test string',
        eventBasedHold: true,
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        kmsKeyName: 'Test string',
        md5Hash: 'Test string',
        mediaLink: 'Test string',
        metadata: {
          A: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        restoreToken: 'Test string',
        retention: {
          mode: 'Test string',
          retainUntilTime: 'Test string',
        },
        retentionExpirationTime: 'Test string',
        selfLink: 'Test string',
        size: 'Test string',
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        temporaryHold: true,
        timeCreated: 'Test string',
        timeDeleted: 'Test string',
        timeFinalized: 'Test string',
        timeStorageClassUpdated: 'Test string',
        updated: 'Test string',
      },
    );
    /** Deletes an object and its metadata. Deletions are permanent if versioning is not enabled for the bucket, or if the generation parameter is used. */
    await gapi.client.storage.objects.delete({
      bucket: 'Test string',
      generation: 'Test string',
      ifGenerationMatch: 'Test string',
      ifGenerationNotMatch: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      object: 'Test string',
      userProject: 'Test string',
    });
    /** Retrieves an object or its metadata. */
    await gapi.client.storage.objects.get({
      bucket: 'Test string',
      generation: 'Test string',
      ifGenerationMatch: 'Test string',
      ifGenerationNotMatch: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      object: 'Test string',
      projection: 'Test string',
      restoreToken: 'Test string',
      softDeleted: true,
      userProject: 'Test string',
    });
    /** Returns an IAM policy for the specified object. */
    await gapi.client.storage.objects.getIamPolicy({
      bucket: 'Test string',
      generation: 'Test string',
      object: 'Test string',
      userProject: 'Test string',
    });
    /** Stores a new object and metadata. */
    await gapi.client.storage.objects.insert(
      {
        bucket: 'Test string',
        contentEncoding: 'Test string',
        ifGenerationMatch: 'Test string',
        ifGenerationNotMatch: 'Test string',
        ifMetagenerationMatch: 'Test string',
        ifMetagenerationNotMatch: 'Test string',
        kmsKeyName: 'Test string',
        name: 'Test string',
        predefinedAcl: 'Test string',
        projection: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        bucket: 'Test string',
        cacheControl: 'Test string',
        componentCount: 42,
        contentDisposition: 'Test string',
        contentEncoding: 'Test string',
        contentLanguage: 'Test string',
        contentType: 'Test string',
        contexts: {
          custom: {
            A: {
              createTime: 'Test string',
              updateTime: 'Test string',
              value: 'Test string',
            },
          },
        },
        crc32c: 'Test string',
        customerEncryption: {
          encryptionAlgorithm: 'Test string',
          keySha256: 'Test string',
        },
        customTime: 'Test string',
        etag: 'Test string',
        eventBasedHold: true,
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        kmsKeyName: 'Test string',
        md5Hash: 'Test string',
        mediaLink: 'Test string',
        metadata: {
          A: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        restoreToken: 'Test string',
        retention: {
          mode: 'Test string',
          retainUntilTime: 'Test string',
        },
        retentionExpirationTime: 'Test string',
        selfLink: 'Test string',
        size: 'Test string',
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        temporaryHold: true,
        timeCreated: 'Test string',
        timeDeleted: 'Test string',
        timeFinalized: 'Test string',
        timeStorageClassUpdated: 'Test string',
        updated: 'Test string',
      },
    );
    /** Retrieves a list of objects matching the criteria. */
    await gapi.client.storage.objects.list({
      bucket: 'Test string',
      delimiter: 'Test string',
      endOffset: 'Test string',
      filter: 'Test string',
      includeFoldersAsPrefixes: true,
      includeTrailingDelimiter: true,
      matchGlob: 'Test string',
      maxResults: 42,
      pageToken: 'Test string',
      prefix: 'Test string',
      projection: 'Test string',
      softDeleted: true,
      startOffset: 'Test string',
      userProject: 'Test string',
      versions: true,
    });
    /** Moves the source object to the destination object in the same bucket. */
    await gapi.client.storage.objects.move({
      bucket: 'Test string',
      destinationObject: 'Test string',
      ifGenerationMatch: 'Test string',
      ifGenerationNotMatch: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      ifSourceGenerationMatch: 'Test string',
      ifSourceGenerationNotMatch: 'Test string',
      ifSourceMetagenerationMatch: 'Test string',
      ifSourceMetagenerationNotMatch: 'Test string',
      projection: 'Test string',
      sourceObject: 'Test string',
      userProject: 'Test string',
    });
    /** Patches an object's metadata. */
    await gapi.client.storage.objects.patch(
      {
        bucket: 'Test string',
        generation: 'Test string',
        ifGenerationMatch: 'Test string',
        ifGenerationNotMatch: 'Test string',
        ifMetagenerationMatch: 'Test string',
        ifMetagenerationNotMatch: 'Test string',
        object: 'Test string',
        overrideUnlockedRetention: true,
        predefinedAcl: 'Test string',
        projection: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        bucket: 'Test string',
        cacheControl: 'Test string',
        componentCount: 42,
        contentDisposition: 'Test string',
        contentEncoding: 'Test string',
        contentLanguage: 'Test string',
        contentType: 'Test string',
        contexts: {
          custom: {
            A: {
              createTime: 'Test string',
              updateTime: 'Test string',
              value: 'Test string',
            },
          },
        },
        crc32c: 'Test string',
        customerEncryption: {
          encryptionAlgorithm: 'Test string',
          keySha256: 'Test string',
        },
        customTime: 'Test string',
        etag: 'Test string',
        eventBasedHold: true,
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        kmsKeyName: 'Test string',
        md5Hash: 'Test string',
        mediaLink: 'Test string',
        metadata: {
          A: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        restoreToken: 'Test string',
        retention: {
          mode: 'Test string',
          retainUntilTime: 'Test string',
        },
        retentionExpirationTime: 'Test string',
        selfLink: 'Test string',
        size: 'Test string',
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        temporaryHold: true,
        timeCreated: 'Test string',
        timeDeleted: 'Test string',
        timeFinalized: 'Test string',
        timeStorageClassUpdated: 'Test string',
        updated: 'Test string',
      },
    );
    /** Restores a soft-deleted object. */
    await gapi.client.storage.objects.restore({
      bucket: 'Test string',
      copySourceAcl: true,
      generation: 'Test string',
      ifGenerationMatch: 'Test string',
      ifGenerationNotMatch: 'Test string',
      ifMetagenerationMatch: 'Test string',
      ifMetagenerationNotMatch: 'Test string',
      object: 'Test string',
      projection: 'Test string',
      restoreToken: 'Test string',
      userProject: 'Test string',
    });
    /** Rewrites a source object to a destination object. Optionally overrides metadata. */
    await gapi.client.storage.objects.rewrite(
      {
        destinationBucket: 'Test string',
        destinationKmsKeyName: 'Test string',
        destinationObject: 'Test string',
        destinationPredefinedAcl: 'Test string',
        ifGenerationMatch: 'Test string',
        ifGenerationNotMatch: 'Test string',
        ifMetagenerationMatch: 'Test string',
        ifMetagenerationNotMatch: 'Test string',
        ifSourceGenerationMatch: 'Test string',
        ifSourceGenerationNotMatch: 'Test string',
        ifSourceMetagenerationMatch: 'Test string',
        ifSourceMetagenerationNotMatch: 'Test string',
        maxBytesRewrittenPerCall: 'Test string',
        projection: 'Test string',
        rewriteToken: 'Test string',
        sourceBucket: 'Test string',
        sourceGeneration: 'Test string',
        sourceObject: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        bucket: 'Test string',
        cacheControl: 'Test string',
        componentCount: 42,
        contentDisposition: 'Test string',
        contentEncoding: 'Test string',
        contentLanguage: 'Test string',
        contentType: 'Test string',
        contexts: {
          custom: {
            A: {
              createTime: 'Test string',
              updateTime: 'Test string',
              value: 'Test string',
            },
          },
        },
        crc32c: 'Test string',
        customerEncryption: {
          encryptionAlgorithm: 'Test string',
          keySha256: 'Test string',
        },
        customTime: 'Test string',
        etag: 'Test string',
        eventBasedHold: true,
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        kmsKeyName: 'Test string',
        md5Hash: 'Test string',
        mediaLink: 'Test string',
        metadata: {
          A: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        restoreToken: 'Test string',
        retention: {
          mode: 'Test string',
          retainUntilTime: 'Test string',
        },
        retentionExpirationTime: 'Test string',
        selfLink: 'Test string',
        size: 'Test string',
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        temporaryHold: true,
        timeCreated: 'Test string',
        timeDeleted: 'Test string',
        timeFinalized: 'Test string',
        timeStorageClassUpdated: 'Test string',
        updated: 'Test string',
      },
    );
    /** Updates an IAM policy for the specified object. */
    await gapi.client.storage.objects.setIamPolicy(
      {
        bucket: 'Test string',
        generation: 'Test string',
        object: 'Test string',
        userProject: 'Test string',
      },
      {
        bindings: [
          {
            condition: {
              description: 'Test string',
              expression: 'Test string',
              location: 'Test string',
              title: 'Test string',
            },
            members: ['Test string'],
            role: 'Test string',
          },
        ],
        etag: 'Test string',
        kind: 'Test string',
        resourceId: 'Test string',
        version: 42,
      },
    );
    /** Tests a set of permissions on the given object to see which, if any, are held by the caller. */
    await gapi.client.storage.objects.testIamPermissions({
      bucket: 'Test string',
      generation: 'Test string',
      object: 'Test string',
      permissions: 'Test string',
      userProject: 'Test string',
    });
    /** Updates an object's metadata. */
    await gapi.client.storage.objects.update(
      {
        bucket: 'Test string',
        generation: 'Test string',
        ifGenerationMatch: 'Test string',
        ifGenerationNotMatch: 'Test string',
        ifMetagenerationMatch: 'Test string',
        ifMetagenerationNotMatch: 'Test string',
        object: 'Test string',
        overrideUnlockedRetention: true,
        predefinedAcl: 'Test string',
        projection: 'Test string',
        userProject: 'Test string',
      },
      {
        acl: [
          {
            bucket: 'Test string',
            domain: 'Test string',
            email: 'Test string',
            entity: 'Test string',
            entityId: 'Test string',
            etag: 'Test string',
            generation: 'Test string',
            id: 'Test string',
            kind: 'Test string',
            object: 'Test string',
            projectTeam: {
              projectNumber: 'Test string',
              team: 'Test string',
            },
            role: 'Test string',
            selfLink: 'Test string',
          },
        ],
        bucket: 'Test string',
        cacheControl: 'Test string',
        componentCount: 42,
        contentDisposition: 'Test string',
        contentEncoding: 'Test string',
        contentLanguage: 'Test string',
        contentType: 'Test string',
        contexts: {
          custom: {
            A: {
              createTime: 'Test string',
              updateTime: 'Test string',
              value: 'Test string',
            },
          },
        },
        crc32c: 'Test string',
        customerEncryption: {
          encryptionAlgorithm: 'Test string',
          keySha256: 'Test string',
        },
        customTime: 'Test string',
        etag: 'Test string',
        eventBasedHold: true,
        generation: 'Test string',
        hardDeleteTime: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        kmsKeyName: 'Test string',
        md5Hash: 'Test string',
        mediaLink: 'Test string',
        metadata: {
          A: 'Test string',
        },
        metageneration: 'Test string',
        name: 'Test string',
        owner: {
          entity: 'Test string',
          entityId: 'Test string',
        },
        restoreToken: 'Test string',
        retention: {
          mode: 'Test string',
          retainUntilTime: 'Test string',
        },
        retentionExpirationTime: 'Test string',
        selfLink: 'Test string',
        size: 'Test string',
        softDeleteTime: 'Test string',
        storageClass: 'Test string',
        temporaryHold: true,
        timeCreated: 'Test string',
        timeDeleted: 'Test string',
        timeFinalized: 'Test string',
        timeStorageClassUpdated: 'Test string',
        updated: 'Test string',
      },
    );
    /** Watch for changes on all objects in a bucket. */
    await gapi.client.storage.objects.watchAll(
      {
        bucket: 'Test string',
        delimiter: 'Test string',
        endOffset: 'Test string',
        includeTrailingDelimiter: true,
        maxResults: 42,
        pageToken: 'Test string',
        prefix: 'Test string',
        projection: 'Test string',
        startOffset: 'Test string',
        userProject: 'Test string',
        versions: true,
      },
      {
        address: 'Test string',
        expiration: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        params: {
          A: 'Test string',
        },
        payload: true,
        resourceId: 'Test string',
        resourceUri: 'Test string',
        token: 'Test string',
        type: 'Test string',
      },
    );
    /** Starts asynchronous advancement of the relocate bucket operation in the case of required write downtime, to allow it to lock the bucket at the source location, and proceed with the bucket location swap. The server makes a best effort to advance the relocate bucket operation, but success is not guaranteed. */
    await gapi.client.storage.operations.advanceRelocateBucket(
      {
        bucket: 'Test string',
        operationId: 'Test string',
      },
      {
        expireTime: 'Test string',
        ttl: 'Test string',
      },
    );
    /** Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. */
    await gapi.client.storage.operations.cancel({
      bucket: 'Test string',
      operationId: 'Test string',
    });
    /** Gets the latest state of a long-running operation. */
    await gapi.client.storage.operations.get({
      bucket: 'Test string',
      operationId: 'Test string',
    });
    /** Lists operations that match the specified filter in the request. */
    await gapi.client.storage.operations.list({
      bucket: 'Test string',
      filter: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Creates a new HMAC key for the specified service account. */
    await gapi.client.storage.projects.hmacKeys.create({
      projectId: 'Test string',
      serviceAccountEmail: 'Test string',
      userProject: 'Test string',
    });
    /** Deletes an HMAC key. */
    await gapi.client.storage.projects.hmacKeys.delete({
      accessId: 'Test string',
      projectId: 'Test string',
      userProject: 'Test string',
    });
    /** Retrieves an HMAC key's metadata */
    await gapi.client.storage.projects.hmacKeys.get({
      accessId: 'Test string',
      projectId: 'Test string',
      userProject: 'Test string',
    });
    /** Retrieves a list of HMAC keys matching the criteria. */
    await gapi.client.storage.projects.hmacKeys.list({
      maxResults: 42,
      pageToken: 'Test string',
      projectId: 'Test string',
      serviceAccountEmail: 'Test string',
      showDeletedKeys: true,
      userProject: 'Test string',
    });
    /** Updates the state of an HMAC key. See the [HMAC Key resource descriptor](https://cloud.google.com/storage/docs/json_api/v1/projects/hmacKeys/update#request-body) for valid states. */
    await gapi.client.storage.projects.hmacKeys.update(
      {
        accessId: 'Test string',
        projectId: 'Test string',
        userProject: 'Test string',
      },
      {
        accessId: 'Test string',
        etag: 'Test string',
        id: 'Test string',
        kind: 'Test string',
        projectId: 'Test string',
        selfLink: 'Test string',
        serviceAccountEmail: 'Test string',
        state: 'Test string',
        timeCreated: 'Test string',
        updated: 'Test string',
      },
    );
    /** Get the email address of this project's Google Cloud Storage service account. */
    await gapi.client.storage.projects.serviceAccount.get({
      projectId: 'Test string',
      userProject: 'Test string',
    });
  }
});
