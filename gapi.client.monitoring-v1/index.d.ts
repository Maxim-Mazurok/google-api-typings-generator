/* Type definitions for non-npm package Cloud Monitoring API v1 0.0 */
// Project: https://cloud.google.com/monitoring/api/
// Definitions by: Maxim Mazurok <https://github.com/Maxim-Mazurok>
//                 Nick Amoscato <https://github.com/namoscato>
//                 Declan Vong <https://github.com/declanvong>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator
// Generated from: https://monitoring.googleapis.com/$discovery/rest?version=v1
// Revision: 20250723

/// <reference types="gapi.client" />

declare namespace gapi.client {
  /** Load Cloud Monitoring API v1 */
  function load(
    urlOrObject: 'https://monitoring.googleapis.com/$discovery/rest?version=v1',
  ): Promise<void>;
  /** @deprecated Please load APIs with discovery documents. */
  function load(name: 'monitoring', version: 'v1'): Promise<void>;
  /** @deprecated Please load APIs with discovery documents. */
  function load(name: 'monitoring', version: 'v1', callback: () => any): void;

  namespace monitoring {
    interface Aggregation {
      /** The alignment_period specifies a time interval, in seconds, that is used to divide the data in all the time series into consistent blocks of time. This will be done before the per-series aligner can be applied to the data.The value must be at least 60 seconds. If a per-series aligner other than ALIGN_NONE is specified, this field is required or an error is returned. If no per-series aligner is specified, or the aligner ALIGN_NONE is specified, then this field is ignored.The maximum value of the alignment_period is 2 years, or 104 weeks. */
      alignmentPeriod?: string;
      /** The reduction operation to be used to combine time series into a single time series, where the value of each data point in the resulting series is a function of all the already aligned values in the input time series.Not all reducer operations can be applied to all time series. The valid choices depend on the metric_kind and the value_type of the original time series. Reduction can yield a time series with a different metric_kind or value_type than the input time series.Time series data must first be aligned (see per_series_aligner) in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified, and must not be ALIGN_NONE. An alignment_period must also be specified; otherwise, an error is returned. */
      crossSeriesReducer?: string;
      /** The set of fields to preserve when cross_series_reducer is specified. The group_by_fields determine how the time series are partitioned into subsets prior to applying the aggregation operation. Each subset contains time series that have the same value for each of the grouping fields. Each individual time series is a member of exactly one subset. The cross_series_reducer is applied to each subset of time series. It is not possible to reduce across different resource types, so this field implicitly contains resource.type. Fields not specified in group_by_fields are aggregated away. If group_by_fields is not specified and all the time series have the same resource type, then the time series are aggregated into a single output time series. If cross_series_reducer is not defined, this field is ignored. */
      groupByFields?: string[];
      /** An Aligner describes how to bring the data points in a single time series into temporal alignment. Except for ALIGN_NONE, all alignments cause all the data points in an alignment_period to be mathematically grouped together, resulting in a single data point for each alignment_period with end timestamp at the end of the period.Not all alignment operations may be applied to all time series. The valid choices depend on the metric_kind and value_type of the original time series. Alignment can change the metric_kind or the value_type of the time series.Time series data must be aligned in order to perform cross-time series reduction. If cross_series_reducer is specified, then per_series_aligner must be specified and not equal to ALIGN_NONE and alignment_period must be specified; otherwise, an error is returned. */
      perSeriesAligner?: string;
    }
    interface AggregationFunction {
      /** Optional. Parameters applied to the aggregation function. Only used for functions that require them. */
      parameters?: Parameter[];
      /** Required. The type of aggregation function, must be one of the following: "none" - no function. "percentile" - APPROX_QUANTILES() - 1 parameter numeric value "average" - AVG() "count" - COUNT() "count-distinct" - COUNT(DISTINCT) "count-distinct-approx" - APPROX_COUNT_DISTINCT() "max" - MAX() "min" - MIN() "sum" - SUM() */
      type?: string;
    }
    interface AlertChart {
      /** Required. The resource name of the alert policy. The format is: projects/[PROJECT_ID_OR_NUMBER]/alertPolicies/[ALERT_POLICY_ID] */
      name?: string;
    }
    interface Axis {
      /** The label of the axis. */
      label?: string;
      /** The axis scale. By default, a linear scale is used. */
      scale?: string;
    }
    interface Breakdown {
      /** Required. The Aggregation function is applied across all data in each breakdown created. */
      aggregationFunction?: AggregationFunction;
      /** Required. The name of the column in the dataset containing the breakdown values. */
      column?: string;
      /** Required. A limit to the number of breakdowns. If set to zero then all possible breakdowns are applied. The list of breakdowns is dependent on the value of the sort_order field. */
      limit?: number;
      /** Required. The sort order is applied to the values of the breakdown column. */
      sortOrder?: string;
    }
    interface ChartOptions {
      /** Preview: Configures whether the charted values are shown on the horizontal or vertical axis. By default, values are represented the vertical axis. This is a preview feature and may be subject to change before final release. */
      displayHorizontal?: boolean;
      /** The chart mode. */
      mode?: string;
    }
    interface CollapsibleGroup {
      /** The collapsed state of the widget on first page load. */
      collapsed?: boolean;
    }
    interface Column {
      /** The relative weight of this column. The column weight is used to adjust the width of columns on the screen (relative to peers). Greater the weight, greater the width of the column on the screen. If omitted, a value of 1 is used while rendering. */
      weight?: string;
      /** The display widgets arranged vertically in this column. */
      widgets?: Widget[];
    }
    interface ColumnLayout {
      /** The columns of content to display. */
      columns?: Column[];
    }
    interface ColumnSettings {
      /** Optional. Whether the column should be left / middle / right aligned */
      alignment?: string;
      /** Required. The id of the column. */
      column?: string;
      /** Optional. Display name of the column */
      displayName?: string;
      /** Optional. The thresholds used to determine how the table cell should be rendered given the time series' current value. */
      thresholds?: Threshold[];
      /** Required. Whether the column should be visible on page load. */
      visible?: boolean;
    }
    interface ColumnSortingOptions {
      /** Optional. Column name to sort data by */
      column?: string;
      /** Optional. A sorting direction that determines ascending or descending order. This is a legacy field kept for backwards compatibility with table. */
      direction?: string;
    }
    interface Dashboard {
      /** Configuration for event annotations to display on this dashboard. */
      annotations?: DashboardAnnotations;
      /** The content is divided into equally spaced columns and the widgets are arranged vertically. */
      columnLayout?: ColumnLayout;
      /** Filters to reduce the amount of data charted based on the filter criteria. */
      dashboardFilters?: DashboardFilter[];
      /** Required. The mutable, human-readable name. */
      displayName?: string;
      /** etag is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. An etag is returned in the response to GetDashboard, and users are expected to put that etag in the request to UpdateDashboard to ensure that their change will be applied to the same version of the Dashboard configuration. The field should not be passed during dashboard creation. */
      etag?: string;
      /** Content is arranged with a basic layout that re-flows a simple list of informational elements like widgets or tiles. */
      gridLayout?: GridLayout;
      /** Labels applied to the dashboard */
      labels?: {[P in string]: string};
      /** The content is arranged as a grid of tiles, with each content widget occupying one or more grid blocks. */
      mosaicLayout?: MosaicLayout;
      /** Identifier. The resource name of the dashboard. */
      name?: string;
      /** The content is divided into equally spaced rows and the widgets are arranged horizontally. */
      rowLayout?: RowLayout;
    }
    interface DashboardAnnotations {
      /** Dashboard level defaults for names of logging resources to search for events. Currently only projects are supported. Each individual EventAnnotation may have its own overrides. If both this field and the per annotation field is empty, then the scoping project is used. Limit: 50 projects. For example: “projects/some-project-id” */
      defaultResourceNames?: string[];
      /** List of annotation configurations for this dashboard. Each entry specifies one event type. */
      eventAnnotations?: EventAnnotation[];
    }
    interface DashboardFilter {
      /** The specified filter type */
      filterType?: string;
      /** Optional. The key for the label. This must be omitted if the filter_type is VALUE_ONLY but is required otherwise. */
      labelKey?: string;
      /** A list of possible string values for the filter */
      stringArray?: StringArray;
      /** An array of variable-length string values. If this field is set, value_type must be set to STRING_ARRAY or VALUE_TYPE_UNSPECIFIED */
      stringArrayValue?: StringArray;
      /** A variable-length string value. If this field is set, value_type must be set to STRING or VALUE_TYPE_UNSPECIFIED */
      stringValue?: string;
      /** The placeholder text that can be referenced in a filter string or MQL query. If omitted, the dashboard filter will be applied to all relevant widgets in the dashboard. */
      templateVariable?: string;
      /** A query to run to fetch possible values for the filter. Only OpsAnalyticsQueries are supported */
      timeSeriesQuery?: TimeSeriesQuery;
      /** The type of the filter value. If value_type is not provided, it will be inferred from the default_value. If neither value_type nor default_value is provided, value_type will be set to STRING by default. */
      valueType?: string;
    }
    interface DataSet {
      /** Optional. The collection of breakdowns to be applied to the dataset. */
      breakdowns?: Breakdown[];
      /** Optional. A collection of dimension columns. */
      dimensions?: Dimension[];
      /** A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value. */
      legendTemplate?: string;
      /** Optional. A collection of measures. */
      measures?: Measure[];
      /** Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals. */
      minAlignmentPeriod?: string;
      /** How this data should be plotted on the chart. */
      plotType?: string;
      /** Optional. A collection of sort options, affects the order of the data and legend. */
      sort?: ColumnSortingOptions[];
      /** Optional. The target axis to use for plotting the metric. */
      targetAxis?: string;
      /** Required. Fields for querying time series data from the Stackdriver metrics API. */
      timeSeriesQuery?: TimeSeriesQuery;
    }
    interface Dimension {
      /** Required. The name of the column in the source SQL query that is used to chart the dimension. */
      column?: string;
      /** Optional. The type of the dimension column. This is relevant only if one of the bin_size fields is set. If it is empty, the type TIMESTAMP or INT64 will be assumed based on which bin_size field is set. If populated, this should be set to one of the following types: DATE, TIME, DATETIME, TIMESTAMP, BIGNUMERIC, INT64, NUMERIC, FLOAT64. */
      columnType?: string;
      /** Optional. float_bin_size is used when the column type used for a dimension is a floating point numeric column. */
      floatBinSize?: number;
      /** A limit to the number of bins generated. When 0 is specified, the maximum count is not enforced. */
      maxBinCount?: number;
      /** numeric_bin_size is used when the column type used for a dimension is numeric or string. */
      numericBinSize?: number;
      /** The column name to sort on for binning. This column can be the same column as this dimension or any other column used as a measure in the results. If sort_order is set to NONE, then this value is not used. */
      sortColumn?: string;
      /** The sort order applied to the sort column. */
      sortOrder?: string;
      /** time_bin_size is used when the data type specified by column is a time type and the bin size is determined by a time duration. If column_type is DATE, this must be a whole value multiple of 1 day. If column_type is TIME, this must be less than or equal to 24 hours. */
      timeBinSize?: string;
    }
    interface DroppedLabels {
      /** Map from label to its value, for all labels dropped in any aggregation. */
      label?: {[P in string]: string};
    }
    interface Empty {}
    interface ErrorReportingPanel {
      /** The resource name of the Google Cloud Platform project. Written as projects/{projectID} or projects/{projectNumber}, where {projectID} and {projectNumber} can be found in the Google Cloud console (https://support.google.com/cloud/answer/6158840).Examples: projects/my-project-123, projects/5551234. */
      projectNames?: string[];
      /** An identifier of the service, such as the name of the executable, job, or Google App Engine service name. This field is expected to have a low number of values that are relatively stable over time, as opposed to version, which can be changed whenever new code is deployed.Contains the service name for error reports extracted from Google App Engine logs or default if the App Engine default service is used. */
      services?: string[];
      /** Represents the source code version that the developer provided, which could represent a version label or a Git SHA-1 hash, for example. For App Engine standard environment, the version is set to the version of the app. */
      versions?: string[];
    }
    interface EventAnnotation {
      /** Solely for UI display. Should not be used programmatically. */
      displayName?: string;
      /** Whether or not to show the events on the dashboard by default */
      enabled?: boolean;
      /** The type of event to display. */
      eventType?: string;
      /** string filtering the events - event dependant. Example values: "resource.labels.pod_name = 'pod-1'" "protoPayload.authenticationInfo.principalEmail='user@example.com'" */
      filter?: string;
      /** Per annotation level override for the names of logging resources to search for events. Currently only projects are supported. If both this field and the per annotation field is empty, it will default to the host project. Limit: 50 projects. For example: “projects/another-project-id” */
      resourceNames?: string[];
    }
    interface Field {
      /** The field cardinality. */
      cardinality?: string;
      /** The string value of the default value of this field. Proto2 syntax only. */
      defaultValue?: string;
      /** The field JSON name. */
      jsonName?: string;
      /** The field type. */
      kind?: string;
      /** The field name. */
      name?: string;
      /** The field number. */
      number?: number;
      /** The index of the field type in Type.oneofs, for message or enumeration types. The first type has index 1; zero means the type is not in the list. */
      oneofIndex?: number;
      /** The protocol buffer options. */
      options?: Option[];
      /** Whether to use alternative packed wire representation. */
      packed?: boolean;
      /** The field type URL, without the scheme, for message or enumeration types. Example: "type.googleapis.com/google.protobuf.Timestamp". */
      typeUrl?: string;
    }
    interface GaugeView {
      /** The lower bound for this gauge chart. The value of the chart should always be greater than or equal to this. */
      lowerBound?: number;
      /** The upper bound for this gauge chart. The value of the chart should always be less than or equal to this. */
      upperBound?: number;
    }
    interface GridLayout {
      /** The number of columns into which the view's width is divided. If omitted or set to zero, a system default will be used while rendering. */
      columns?: string;
      /** The informational elements that are arranged into the columns row-first. */
      widgets?: Widget[];
    }
    interface HttpBody {
      /** The HTTP Content-Type header value specifying the content type of the body. */
      contentType?: string;
      /** The HTTP request/response body as raw binary. */
      data?: string;
      /** Application specific response metadata. Must be set in the first response for streaming APIs. */
      extensions?: Array<{[P in string]: any}>;
    }
    interface IncidentList {
      /** Optional. The monitored resource for which incidents are listed. The resource doesn't need to be fully specified. That is, you can specify the resource type but not the values of the resource labels. The resource type and labels are used for filtering. */
      monitoredResources?: MonitoredResource[];
      /** Optional. A list of alert policy names to filter the incident list by. Don't include the project ID prefix in the policy name. For example, use alertPolicies/utilization. */
      policyNames?: string[];
    }
    interface Interval {
      /** Optional. Exclusive end of the interval.If specified, a Timestamp matching this interval will have to be before the end. */
      endTime?: string;
      /** Optional. Inclusive start of the interval.If specified, a Timestamp matching this interval will have to be the same or after the start. */
      startTime?: string;
    }
    interface ListDashboardsResponse {
      /** The list of requested dashboards. */
      dashboards?: Dashboard[];
      /** If there are more results than have been returned, then this field is set to a non-empty value. To see the additional results, use that value as page_token in the next call to this method. */
      nextPageToken?: string;
    }
    interface ListMetricsScopesByMonitoredProjectResponse {
      /** A set of all metrics scopes that the specified monitored project has been added to. */
      metricsScopes?: MetricsScope[];
    }
    interface LogsPanel {
      /** A filter that chooses which log entries to return. See Advanced Logs Queries (https://cloud.google.com/logging/docs/view/advanced-queries). Only log entries that match the filter are returned. An empty filter matches all log entries. */
      filter?: string;
      /** The names of logging resources to collect logs for. Currently projects and storage views are supported. If empty, the widget will default to the host project. */
      resourceNames?: string[];
    }
    interface Measure {
      /** Required. The aggregation function applied to the input column. This must not be set to "none" unless binning is disabled on the dimension. The aggregation function is used to group points on the dimension bins. */
      aggregationFunction?: AggregationFunction;
      /** Required. The column name within in the dataset used for the measure. */
      column?: string;
    }
    interface MetricsScope {
      /** Output only. The time when this Metrics Scope was created. */
      createTime?: string;
      /** Output only. The list of projects monitored by this Metrics Scope. */
      monitoredProjects?: MonitoredProject[];
      /** Immutable. The resource name of the Monitoring Metrics Scope. On input, the resource name can be specified with the scoping project ID or number. On output, the resource name is specified with the scoping project number. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER} */
      name?: string;
      /** Output only. The time when this Metrics Scope record was last updated. */
      updateTime?: string;
    }
    interface MonitoredProject {
      /** Output only. The time when this MonitoredProject was created. */
      createTime?: string;
      /** Output only. Set if the project has been tombstoned by the user. */
      isTombstoned?: boolean;
      /** Immutable. The resource name of the MonitoredProject. On input, the resource name includes the scoping project ID and monitored project ID. On output, it contains the equivalent project numbers. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}/projects/{MONITORED_PROJECT_ID_OR_NUMBER} */
      name?: string;
    }
    interface MonitoredResource {
      /** Required. Values for all of the labels listed in the associated monitored resource descriptor. For example, Compute Engine VM instances use the labels "project_id", "instance_id", and "zone". */
      labels?: {[P in string]: string};
      /** Required. The monitored resource type. This field must match the type field of a MonitoredResourceDescriptor object. For example, the type of a Compute Engine VM instance is gce_instance. For a list of types, see Monitoring resource types (https://cloud.google.com/monitoring/api/resources) and Logging resource types (https://cloud.google.com/logging/docs/api/v2/resource-list). */
      type?: string;
    }
    interface MosaicLayout {
      /** The number of columns in the mosaic grid. The number of columns must be between 1 and 48, inclusive. */
      columns?: number;
      /** The tiles to display. */
      tiles?: Tile[];
    }
    interface Operation {
      /** If the value is false, it means the operation is still in progress. If true, the operation is completed, and either error or response is available. */
      done?: boolean;
      /** The error result of the operation in case of failure or cancellation. */
      error?: Status;
      /** Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such metadata. Any method that returns a long-running operation should document the metadata type, if any. */
      metadata?: {[P in string]: any};
      /** The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the name should be a resource name ending with operations/{unique_id}. */
      name?: string;
      /** The normal, successful response of the operation. If the original method returns no data on success, such as Delete, the response is google.protobuf.Empty. If the original method is standard Get/Create/Update, the response should be the resource. For other methods, the response should have the type XxxResponse, where Xxx is the original method name. For example, if the original method name is TakeSnapshot(), the inferred response type is TakeSnapshotResponse. */
      response?: {[P in string]: any};
    }
    interface OperationMetadata {
      /** The time when the batch request was received. */
      createTime?: string;
      /** Current state of the batch operation. */
      state?: string;
      /** The time when the operation result was last updated. */
      updateTime?: string;
    }
    interface OpsAnalyticsQuery {
      /** A SQL query to fetch time series, category series, or numeric series data. */
      sql?: string;
    }
    interface Option {
      /** The option's name. For protobuf built-in options (options defined in descriptor.proto), this is the short name. For example, "map_entry". For custom options, it should be the fully-qualified name. For example, "google.api.http". */
      name?: string;
      /** The option's value packed in an Any message. If the value is a primitive, the corresponding wrapper type defined in google/protobuf/wrappers.proto should be used. If the value is an enum, it should be stored as an int32 value using the google.protobuf.Int32Value type. */
      value?: {[P in string]: any};
    }
    interface Parameter {
      /** A floating-point parameter value. */
      doubleValue?: number;
      /** An integer parameter value. */
      intValue?: string;
    }
    interface PickTimeSeriesFilter {
      /** How to use the ranking to select time series that pass through the filter. */
      direction?: string;
      /** Select the top N streams/time series within this time interval */
      interval?: Interval;
      /** How many time series to allow to pass through the filter. */
      numTimeSeries?: number;
      /** ranking_method is applied to each time series independently to produce the value which will be used to compare the time series to other time series. */
      rankingMethod?: string;
    }
    interface PieChart {
      /** Required. Indicates the visualization type for the PieChart. */
      chartType?: string;
      /** Required. The queries for the chart's data. */
      dataSets?: PieChartDataSet[];
      /** Optional. Indicates whether or not the pie chart should show slices' labels */
      showLabels?: boolean;
    }
    interface PieChartDataSet {
      /** A dimension is a structured label, class, or category for a set of measurements in your data. */
      dimensions?: Dimension[];
      /** A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc. */
      measures?: Measure[];
      /** Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals. */
      minAlignmentPeriod?: string;
      /** Optional. A template for the name of the slice. This name will be displayed in the legend and the tooltip of the pie chart. It replaces the auto-generated names for the slices. For example, if the template is set to ${resource.labels.zone}, the zone's value will be used for the name instead of the default name. */
      sliceNameTemplate?: string;
      /** Required. The query for the PieChart. See, google.monitoring.dashboard.v1.TimeSeriesQuery. */
      timeSeriesQuery?: TimeSeriesQuery;
    }
    interface QueryExemplarsRequest {
      /** The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      end?: string;
      /** A PromQL query string. Query language documentation: https://prometheus.io/docs/prometheus/latest/querying/basics/. */
      query?: string;
      /** The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      start?: string;
    }
    interface QueryInstantRequest {
      /** A PromQL query string. Query language documentation: https://prometheus.io/docs/prometheus/latest/querying/basics/. */
      query?: string;
      /** The single point in time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      time?: string;
      /** An upper bound timeout for the query. Either a Prometheus duration string (https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations) or floating point seconds. This non-standard encoding must be used for compatibility with the open source API. Clients may still implement timeouts at the connection level while ignoring this field. */
      timeout?: string;
    }
    interface QueryLabelsRequest {
      /** The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      end?: string;
      /** A list of matchers encoded in the Prometheus label matcher format to constrain the values to series that satisfy them. */
      match?: string;
      /** The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      start?: string;
    }
    interface QueryRangeRequest {
      /** The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      end?: string;
      /** A PromQL query string. Query language documentation: https://prometheus.io/docs/prometheus/latest/querying/basics/. */
      query?: string;
      /** The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      start?: string;
      /** The resolution of query result. Either a Prometheus duration string (https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations) or floating point seconds. This non-standard encoding must be used for compatibility with the open source API. Clients may still implement timeouts at the connection level while ignoring this field. */
      step?: string;
      /** An upper bound timeout for the query. Either a Prometheus duration string (https://prometheus.io/docs/prometheus/latest/querying/basics/#time-durations) or floating point seconds. This non-standard encoding must be used for compatibility with the open source API. Clients may still implement timeouts at the connection level while ignoring this field. */
      timeout?: string;
    }
    interface QuerySeriesRequest {
      /** The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      end?: string;
      /** The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
      start?: string;
    }
    interface RatioPart {
      /** By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data. */
      aggregation?: Aggregation;
      /** Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query. */
      filter?: string;
    }
    interface Row {
      /** The relative weight of this row. The row weight is used to adjust the height of rows on the screen (relative to peers). Greater the weight, greater the height of the row on the screen. If omitted, a value of 1 is used while rendering. */
      weight?: string;
      /** The display widgets arranged horizontally in this row. */
      widgets?: Widget[];
    }
    interface RowLayout {
      /** The rows of content to display. */
      rows?: Row[];
    }
    interface Scorecard {
      /** Will cause the Scorecard to show only the value, with no indicator to its value relative to its thresholds. */
      blankView?: any;
      /** Optional. The collection of breakdowns to be applied to the dataset. A breakdown is a way to slice the data. For example, you can break down the data by region. */
      breakdowns?: Breakdown[];
      /** Optional. A dimension is a structured label, class, or category for a set of measurements in your data. */
      dimensions?: Dimension[];
      /** Will cause the scorecard to show a gauge chart. */
      gaugeView?: GaugeView;
      /** Optional. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc. */
      measures?: Measure[];
      /** Will cause the scorecard to show a spark chart. */
      sparkChartView?: SparkChartView;
      /** The thresholds used to determine the state of the scorecard given the time series' current value. For an actual value x, the scorecard is in a danger state if x is less than or equal to a danger threshold that triggers below, or greater than or equal to a danger threshold that triggers above. Similarly, if x is above/below a warning threshold that triggers above/below, then the scorecard is in a warning state - unless x also puts it in a danger state. (Danger trumps warning.)As an example, consider a scorecard with the following four thresholds: { value: 90, category: 'DANGER', trigger: 'ABOVE', }, { value: 70, category: 'WARNING', trigger: 'ABOVE', }, { value: 10, category: 'DANGER', trigger: 'BELOW', }, { value: 20, category: 'WARNING', trigger: 'BELOW', } Then: values less than or equal to 10 would put the scorecard in a DANGER state, values greater than 10 but less than or equal to 20 a WARNING state, values strictly between 20 and 70 an OK state, values greater than or equal to 70 but less than 90 a WARNING state, and values greater than or equal to 90 a DANGER state. */
      thresholds?: Threshold[];
      /** Required. Fields for querying time series data from the Stackdriver metrics API. */
      timeSeriesQuery?: TimeSeriesQuery;
    }
    interface SectionHeader {
      /** Whether to insert a divider below the section in the table of contents */
      dividerBelow?: boolean;
      /** The subtitle of the section */
      subtitle?: string;
    }
    interface SingleViewGroup {
      /** Optional. Determines how the widget selector will be displayed. */
      displayType?: string;
    }
    interface SourceContext {
      /** The path-qualified name of the .proto file that contained the associated protobuf element. For example: "google/protobuf/source_context.proto". */
      fileName?: string;
    }
    interface SpanContext {
      /** The resource name of the span. The format is: projects/[PROJECT_ID_OR_NUMBER]/traces/[TRACE_ID]/spans/[SPAN_ID] [TRACE_ID] is a unique identifier for a trace within a project; it is a 32-character hexadecimal encoding of a 16-byte array.[SPAN_ID] is a unique identifier for a span within a trace; it is a 16-character hexadecimal encoding of an 8-byte array. */
      spanName?: string;
    }
    interface SparkChartView {
      /** The lower bound on data point frequency in the chart implemented by specifying the minimum alignment period to use in a time series query. For example, if the data is published once every 10 minutes it would not make sense to fetch and align data at one minute intervals. This field is optional and exists only as a hint. */
      minAlignmentPeriod?: string;
      /** Required. The type of sparkchart to show in this chartView. */
      sparkChartType?: string;
    }
    interface StatisticalTimeSeriesFilter {
      /** How many time series to output. */
      numTimeSeries?: number;
      /** rankingMethod is applied to a set of time series, and then the produced value for each individual time series is used to compare a given time series to others. These are methods that cannot be applied stream-by-stream, but rather require the full context of a request to evaluate time series. */
      rankingMethod?: string;
    }
    interface Status {
      /** The status code, which should be an enum value of google.rpc.Code. */
      code?: number;
      /** A list of messages that carry the error details. There is a common set of message types for APIs to use. */
      details?: Array<{[P in string]: any}>;
      /** A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client. */
      message?: string;
    }
    interface StringArray {
      /** The values of the array */
      values?: string[];
    }
    interface TableDataSet {
      /** Optional. The lower bound on data point frequency for this data set, implemented by specifying the minimum alignment period to use in a time series query For example, if the data is published once every 10 minutes, the min_alignment_period should be at least 10 minutes. It would not make sense to fetch and align data at one minute intervals. */
      minAlignmentPeriod?: string;
      /** Optional. Table display options for configuring how the table is rendered. */
      tableDisplayOptions?: TableDisplayOptions;
      /** Optional. A template string for naming TimeSeries in the resulting data set. This should be a string with interpolations of the form ${label_name}, which will resolve to the label's value i.e. "${resource.labels.project_id}." */
      tableTemplate?: string;
      /** Required. Fields for querying time series data from the Stackdriver metrics API. */
      timeSeriesQuery?: TimeSeriesQuery;
    }
    interface TableDisplayOptions {
      /** Optional. This field is unused and has been replaced by TimeSeriesTable.column_settings */
      shownColumns?: string[];
    }
    interface TemplateVariableCondition {
      /** Comparator to use to evaluate whether the value of the template variable matches the template_variable_value. For example, if the comparator is REGEX_FULL_MATCH, template_variable_value would contain a regex that is matched against the value of the template variable. */
      comparator?: string;
      /** The template variable whose value is evaluated. */
      templateVariable?: string;
      /** The value to compare the template variable to. For example, if the comparator is REGEX_FULL_MATCH, this field should contain a regex. */
      templateVariableValue?: string;
    }
    interface Text {
      /** The text content to be displayed. */
      content?: string;
      /** How the text content is formatted. */
      format?: string;
      /** How the text is styled */
      style?: TextStyle;
    }
    interface TextStyle {
      /** The background color as a hex string. "#RRGGBB" or "#RGB" */
      backgroundColor?: string;
      /** Font sizes for both the title and content. The title will still be larger relative to the content. */
      fontSize?: string;
      /** The horizontal alignment of both the title and content */
      horizontalAlignment?: string;
      /** The amount of padding around the widget */
      padding?: string;
      /** The pointer location for this widget (also sometimes called a "tail") */
      pointerLocation?: string;
      /** The text color as a hex string. "#RRGGBB" or "#RGB" */
      textColor?: string;
      /** The vertical alignment of both the title and content */
      verticalAlignment?: string;
    }
    interface Threshold {
      /** The state color for this threshold. Color is not allowed in a XyChart. */
      color?: string;
      /** The direction for the current threshold. Direction is not allowed in a XyChart. */
      direction?: string;
      /** A label for the threshold. */
      label?: string;
      /** The target axis to use for plotting the threshold. Target axis is not allowed in a Scorecard. */
      targetAxis?: string;
      /** The value of the threshold. The value should be defined in the native scale of the metric. */
      value?: number;
    }
    interface Tile {
      /** The height of the tile, measured in grid blocks. Tiles must have a minimum height of 1. */
      height?: number;
      /** The informational widget contained in the tile. For example an XyChart. */
      widget?: Widget;
      /** The width of the tile, measured in grid blocks. Tiles must have a minimum width of 1. */
      width?: number;
      /** The zero-indexed position of the tile in grid blocks relative to the left edge of the grid. Tiles must be contained within the specified number of columns. x_pos cannot be negative. */
      xPos?: number;
      /** The zero-indexed position of the tile in grid blocks relative to the top edge of the grid. y_pos cannot be negative. */
      yPos?: number;
    }
    interface TimeSeriesFilter {
      /** By default, the raw time series data is returned. Use this field to combine multiple time series for different views of the data. */
      aggregation?: Aggregation;
      /** Required. The monitoring filter (https://cloud.google.com/monitoring/api/v3/filters) that identifies the metric types, resources, and projects to query. */
      filter?: string;
      /** Ranking based time series filter. */
      pickTimeSeriesFilter?: PickTimeSeriesFilter;
      /** Apply a second aggregation after aggregation is applied. */
      secondaryAggregation?: Aggregation;
      /** Statistics based time series filter. Note: This field is deprecated and completely ignored by the API. */
      statisticalTimeSeriesFilter?: StatisticalTimeSeriesFilter;
    }
    interface TimeSeriesFilterRatio {
      /** The denominator of the ratio. */
      denominator?: RatioPart;
      /** The numerator of the ratio. */
      numerator?: RatioPart;
      /** Ranking based time series filter. */
      pickTimeSeriesFilter?: PickTimeSeriesFilter;
      /** Apply a second aggregation after the ratio is computed. */
      secondaryAggregation?: Aggregation;
      /** Statistics based time series filter. Note: This field is deprecated and completely ignored by the API. */
      statisticalTimeSeriesFilter?: StatisticalTimeSeriesFilter;
    }
    interface TimeSeriesQuery {
      /** Preview: A query used to fetch a time series, category series, or numeric series with SQL. This is a preview feature and may be subject to change before final release. */
      opsAnalyticsQuery?: OpsAnalyticsQuery;
      /** Optional. If set, Cloud Monitoring will treat the full query duration as the alignment period so that there will be only 1 output value.*Note: This could override the configured alignment period except for the cases where a series of data points are expected, like - XyChart - Scorecard's spark chart */
      outputFullDuration?: boolean;
      /** A query used to fetch time series with PromQL. */
      prometheusQuery?: string;
      /** Filter parameters to fetch time series. */
      timeSeriesFilter?: TimeSeriesFilter;
      /** Parameters to fetch a ratio between two time series filters. */
      timeSeriesFilterRatio?: TimeSeriesFilterRatio;
      /** A query used to fetch time series with MQL. */
      timeSeriesQueryLanguage?: string;
      /** The unit of data contained in fetched time series. If non-empty, this unit will override any unit that accompanies fetched data. The format is the same as the unit (https://cloud.google.com/monitoring/api/ref_v3/rest/v3/projects.metricDescriptors) field in MetricDescriptor. */
      unitOverride?: string;
    }
    interface TimeSeriesTable {
      /** Optional. The list of the persistent column settings for the table. */
      columnSettings?: ColumnSettings[];
      /** Required. The data displayed in this table. */
      dataSets?: TableDataSet[];
      /** Optional. Store rendering strategy */
      metricVisualization?: string;
    }
    interface Treemap {
      /** Required. The collection of datasets used to construct and populate the treemap. For the rendered treemap rectangles: Color is determined by the aggregated value for each grouping. Size is proportional to the count of time series aggregated within that rectangle's segment. */
      dataSets?: TreemapDataSet[];
      /** Required. Ordered labels representing the hierarchical treemap structure. */
      treemapHierarchy?: string[];
    }
    interface TreemapDataSet {
      /** Optional. The collection of breakdowns to be applied to the dataset. A breakdown is a way to slice the data. For example, you can break down the data by region. */
      breakdowns?: Breakdown[];
      /** Optional. A collection of measures. A measure is a measured value of a property in your data. For example, rainfall in inches, number of units sold, revenue gained, etc. */
      measures?: Measure[];
      /** Required. The query that fetches the relevant data. See google.monitoring.dashboard.v1.TimeSeriesQuery */
      timeSeriesQuery?: TimeSeriesQuery;
    }
    interface Type {
      /** The source edition string, only valid when syntax is SYNTAX_EDITIONS. */
      edition?: string;
      /** The list of fields. */
      fields?: Field[];
      /** The fully qualified message name. */
      name?: string;
      /** The list of types appearing in oneof definitions in this type. */
      oneofs?: string[];
      /** The protocol buffer options. */
      options?: Option[];
      /** The source context. */
      sourceContext?: SourceContext;
      /** The source syntax. */
      syntax?: string;
    }
    interface VisibilityCondition {
      /** A condition whose evaluation is based on the value of a template variable. */
      templateVariableCondition?: TemplateVariableCondition;
    }
    interface Widget {
      /** A chart of alert policy data. */
      alertChart?: AlertChart;
      /** A blank space. */
      blank?: any;
      /** A widget that groups the other widgets. All widgets that are within the area spanned by the grouping widget are considered member widgets. */
      collapsibleGroup?: CollapsibleGroup;
      /** A widget that displays a list of error groups. */
      errorReportingPanel?: ErrorReportingPanel;
      /** Optional. The widget id. Ids may be made up of alphanumerics, dashes and underscores. Widget ids are optional. */
      id?: string;
      /** A widget that shows list of incidents. */
      incidentList?: IncidentList;
      /** A widget that shows a stream of logs. */
      logsPanel?: LogsPanel;
      /** A widget that displays timeseries data as a pie chart. */
      pieChart?: PieChart;
      /** A scorecard summarizing time series data. */
      scorecard?: Scorecard;
      /** A widget that defines a section header for easier navigation of the dashboard. */
      sectionHeader?: SectionHeader;
      /** A widget that groups the other widgets by using a dropdown menu. */
      singleViewGroup?: SingleViewGroup;
      /** A raw string or markdown displaying textual content. */
      text?: Text;
      /** A widget that displays time series data in a tabular format. */
      timeSeriesTable?: TimeSeriesTable;
      /** Optional. The title of the widget. */
      title?: string;
      /** A widget that displays data as a treemap. */
      treemap?: Treemap;
      /** Optional. If set, this widget is rendered only when the condition is evaluated to true. */
      visibilityCondition?: VisibilityCondition;
      /** A chart of time series data. */
      xyChart?: XyChart;
    }
    interface XyChart {
      /** Display options for the chart. */
      chartOptions?: ChartOptions;
      /** Required. The data displayed in this chart. */
      dataSets?: DataSet[];
      /** Threshold lines drawn horizontally across the chart. */
      thresholds?: Threshold[];
      /** The duration used to display a comparison chart. A comparison chart simultaneously shows values from two similar-length time periods (e.g., week-over-week metrics). The duration must be positive, and it can only be applied to charts with data sets of LINE plot type. */
      timeshiftDuration?: string;
      /** The properties applied to the x-axis. */
      xAxis?: Axis;
      /** The properties applied to the y2-axis. */
      y2Axis?: Axis;
      /** The properties applied to the y-axis. */
      yAxis?: Axis;
    }
    interface ProjectsResource {
      /** Adds a MonitoredProject with the given project ID to the specified Metrics Scope. */
      create(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Required. The resource name of the existing Metrics Scope that will monitor this project. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER} */
        parent: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** Request body */
        resource: MonitoredProject;
      }): Request<Operation>;
      create(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Required. The resource name of the existing Metrics Scope that will monitor this project. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER} */
          parent: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
        },
        body: MonitoredProject,
      ): Request<Operation>;
      /** Deletes a MonitoredProject from the specified Metrics Scope. */
      delete(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Required. The resource name of the MonitoredProject. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER}/projects/{MONITORED_PROJECT_ID_OR_NUMBER}Authorization requires the following Google IAM (https://cloud.google.com/iam) permissions on both the Metrics Scope and on the MonitoredProject: monitoring.metricsScopes.link */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<Operation>;
    }
    interface MetricsScopesResource {
      /** Returns a specific Metrics Scope, including the list of projects monitored by the specified Metrics Scope. */
      get(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Required. The resource name of the Metrics Scope. Example: locations/global/metricsScopes/{SCOPING_PROJECT_ID_OR_NUMBER} */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<MetricsScope>;
      /** Returns a list of every Metrics Scope that a specific MonitoredProject has been added to. The metrics scope representing the specified monitored project will always be the first entry in the response. */
      listMetricsScopesByMonitoredProject(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Required. The resource name of the Monitored Project being requested. Example: projects/{MONITORED_PROJECT_ID_OR_NUMBER} */
        monitoredResourceContainer?: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<ListMetricsScopesByMonitoredProjectResponse>;
      projects: ProjectsResource;
    }
    interface GlobalResource {
      metricsScopes: MetricsScopesResource;
    }
    interface LocationsResource {
      global: GlobalResource;
    }
    interface OperationsResource {
      /** Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service. */
      get(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** The name of the operation resource. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<Operation>;
    }
    interface DashboardsResource {
      /** Creates a new custom dashboard. For examples on how you can use this API to create dashboards, see Managing dashboards by API (https://cloud.google.com/monitoring/dashboards/api-dashboard). This method requires the monitoring.dashboards.create permission on the specified project. For more information about permissions, see Cloud Identity and Access Management (https://cloud.google.com/iam). */
      create(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Required. The project on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] The [PROJECT_ID_OR_NUMBER] must match the dashboard resource name. */
        parent: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** If set, validate the request and preview the review, but do not actually save it. */
        validateOnly?: boolean;
        /** Request body */
        resource: Dashboard;
      }): Request<Dashboard>;
      create(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Required. The project on which to execute the request. The format is: projects/[PROJECT_ID_OR_NUMBER] The [PROJECT_ID_OR_NUMBER] must match the dashboard resource name. */
          parent: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
          /** If set, validate the request and preview the review, but do not actually save it. */
          validateOnly?: boolean;
        },
        body: Dashboard,
      ): Request<Dashboard>;
      /** Deletes an existing custom dashboard.This method requires the monitoring.dashboards.delete permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam). */
      delete(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Required. The resource name of the Dashboard. The format is: projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID] */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<{}>;
      /** Fetches a specific dashboard.This method requires the monitoring.dashboards.get permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam). */
      get(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Required. The resource name of the Dashboard. The format is one of: dashboards/[DASHBOARD_ID] (for system dashboards) projects/[PROJECT_ID_OR_NUMBER]/dashboards/[DASHBOARD_ID] (for custom dashboards). */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<Dashboard>;
      /** Lists the existing dashboards.This method requires the monitoring.dashboards.list permission on the specified project. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam). */
      list(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** A positive number that is the maximum number of results to return. If unspecified, a default of 1000 is used. */
        pageSize?: number;
        /** Optional. If this field is not empty then it must contain the nextPageToken value returned by a previous call to this method. Using this field causes the method to return additional results from the previous method call. */
        pageToken?: string;
        /** Required. The scope of the dashboards to list. The format is: projects/[PROJECT_ID_OR_NUMBER] */
        parent: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<ListDashboardsResponse>;
      /** Replaces an existing custom dashboard with a new definition.This method requires the monitoring.dashboards.update permission on the specified dashboard. For more information, see Cloud Identity and Access Management (https://cloud.google.com/iam). */
      patch(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Identifier. The resource name of the dashboard. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** If set, validate the request and preview the review, but do not actually save it. */
        validateOnly?: boolean;
        /** Request body */
        resource: Dashboard;
      }): Request<Dashboard>;
      patch(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** Identifier. The resource name of the dashboard. */
          name: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
          /** If set, validate the request and preview the review, but do not actually save it. */
          validateOnly?: boolean;
        },
        body: Dashboard,
      ): Request<Dashboard>;
    }
    interface LabelResource {
      /** Lists possible values for a given label name. */
      values(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** The end time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
        end?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** The label name for which values are queried. */
        label: string;
        /** Location of the resource information. Has to be "global" now. */
        location: string;
        /** A list of matchers encoded in the Prometheus label matcher format to constrain the values to series that satisfy them. */
        match?: string;
        /** Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** The start time to evaluate the query for. Either floating point UNIX seconds or RFC3339 formatted timestamp. */
        start?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<HttpBody>;
    }
    interface MetadataResource {
      /** Lists metadata for metrics. */
      list(request?: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Maximum number of metrics to return. */
        limit?: string;
        /** Location of the resource information. Has to be "global" for now. */
        location: string;
        /** The metric name for which to query metadata. If unset, all metric metadata is returned. */
        metric?: string;
        /** Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
      }): Request<HttpBody>;
    }
    interface V1Resource {
      /** Lists labels for metrics. */
      labels(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Location of the resource information. Has to be "global" now. */
        location: string;
        /** Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** Request body */
        resource: QueryLabelsRequest;
      }): Request<HttpBody>;
      labels(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** Location of the resource information. Has to be "global" now. */
          location: string;
          /** Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER. */
          name: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
        },
        body: QueryLabelsRequest,
      ): Request<HttpBody>;
      /** Evaluate a PromQL query at a single point in time. */
      query(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Location of the resource information. Has to be "global" now. */
        location: string;
        /** Required. The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** Request body */
        resource: QueryInstantRequest;
      }): Request<HttpBody>;
      query(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** Location of the resource information. Has to be "global" now. */
          location: string;
          /** Required. The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. */
          name: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
        },
        body: QueryInstantRequest,
      ): Request<HttpBody>;
      /** Lists exemplars relevant to a given PromQL query, */
      query_exemplars(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Location of the resource information. Has to be "global" now. */
        location: string;
        /** Required. The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** Request body */
        resource: QueryExemplarsRequest;
      }): Request<HttpBody>;
      query_exemplars(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** Location of the resource information. Has to be "global" now. */
          location: string;
          /** Required. The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. */
          name: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
        },
        body: QueryExemplarsRequest,
      ): Request<HttpBody>;
      /** Evaluate a PromQL query with start, end time range. */
      query_range(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Location of the resource information. Has to be "global" now. */
        location: string;
        /** Required. The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** Request body */
        resource: QueryRangeRequest;
      }): Request<HttpBody>;
      query_range(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** Location of the resource information. Has to be "global" now. */
          location: string;
          /** Required. The project on which to execute the request. Data associcated with the project's workspace stored under the The format is: projects/PROJECT_ID_OR_NUMBER. Open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. */
          name: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
        },
        body: QueryRangeRequest,
      ): Request<HttpBody>;
      /** Lists metadata for metrics. */
      series(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** Location of the resource information. Has to be "global" for now. */
        location: string;
        /** Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER. */
        name: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** Request body */
        resource: QuerySeriesRequest;
      }): Request<HttpBody>;
      series(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** Location of the resource information. Has to be "global" for now. */
          location: string;
          /** Required. The workspace on which to execute the request. It is not part of the open source API but used as a request path prefix to distinguish different virtual Prometheus instances of Google Prometheus Engine. The format is: projects/PROJECT_ID_OR_NUMBER. */
          name: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
        },
        body: QuerySeriesRequest,
      ): Request<HttpBody>;
      label: LabelResource;
      metadata: MetadataResource;
    }
    interface ApiResource {
      v1: V1Resource;
    }
    interface PrometheusResource {
      api: ApiResource;
    }
    interface LocationResource {
      prometheus: PrometheusResource;
    }
    interface ProjectsResource {
      dashboards: DashboardsResource;
      location: LocationResource;
    }

    const locations: LocationsResource;

    const operations: OperationsResource;

    const projects: ProjectsResource;
  }
}
