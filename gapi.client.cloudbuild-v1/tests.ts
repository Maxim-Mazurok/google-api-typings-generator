/* This is stub file for gapi.client.cloudbuild-v1 definition tests */
// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator

// Revision: 20231127

gapi.load('client', async () => {
  /** now we can use gapi.client */

  await gapi.client.load(
    'https://cloudbuild.googleapis.com/$discovery/rest?version=v1'
  );
  /** now we can use gapi.client.cloudbuild */

  /** don't forget to authenticate your client before sending any request to resources: */
  /** declare client_id registered in Google Developers Console */
  const client_id = '<<PUT YOUR CLIENT ID HERE>>';
  const scope = [
    /** See, edit, configure, and delete your Google Cloud data and see the email address for your Google Account. */
    'https://www.googleapis.com/auth/cloud-platform',
  ];
  const immediate = false;
  gapi.auth.authorize({client_id, scope, immediate}, authResult => {
    if (authResult && !authResult.error) {
      /** handle successful authorization */
      void run();
    } else {
      /** handle authorization error */
    }
  });

  async function run() {
    /** ReceiveGitHubDotComWebhook is called when the API receives a github.com webhook. */
    await gapi.client.cloudbuild.githubDotComWebhook.receive(
      {
        webhookKey: 'Test string',
      },
      {
        contentType: 'Test string',
        data: 'Test string',
        extensions: [
          {
            A: 42,
          },
        ],
      }
    );
    /** ReceiveRegionalWebhook is called when the API receives a regional GitHub webhook. */
    await gapi.client.cloudbuild.locations.regionalWebhook(
      {
        location: 'Test string',
        webhookKey: 'Test string',
      },
      {
        contentType: 'Test string',
        data: 'Test string',
        extensions: [
          {
            A: 42,
          },
        ],
      }
    );
    /** Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`. */
    await gapi.client.cloudbuild.operations.cancel(
      {
        name: 'Test string',
      },
      {}
    );
    /** Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service. */
    await gapi.client.cloudbuild.operations.get({
      name: 'Test string',
    });
    /** Approves or rejects a pending build. If approved, the returned LRO will be analogous to the LRO returned from a CreateBuild call. If rejected, the returned LRO will be immediately done. */
    await gapi.client.cloudbuild.projects.builds.approve(
      {
        name: 'Test string',
      },
      {
        approvalResult: {
          approvalTime: 'Test string',
          approverAccount: 'Test string',
          comment: 'Test string',
          decision: 'Test string',
          url: 'Test string',
        },
      }
    );
    /** Cancels a build in progress. */
    await gapi.client.cloudbuild.projects.builds.cancel(
      {
        id: 'Test string',
        projectId: 'Test string',
      },
      {
        id: 'Test string',
        name: 'Test string',
        projectId: 'Test string',
      }
    );
    /** Starts a build with the specified configuration. This method returns a long-running `Operation`, which includes the build ID. Pass the build ID to `GetBuild` to determine the build status (such as `SUCCESS` or `FAILURE`). */
    await gapi.client.cloudbuild.projects.builds.create(
      {
        parent: 'Test string',
        projectId: 'Test string',
      },
      {
        approval: {
          config: {
            approvalRequired: true,
          },
          result: {
            approvalTime: 'Test string',
            approverAccount: 'Test string',
            comment: 'Test string',
            decision: 'Test string',
            url: 'Test string',
          },
          state: 'Test string',
        },
        artifacts: {
          images: ['Test string'],
          mavenArtifacts: [
            {
              artifactId: 'Test string',
              groupId: 'Test string',
              path: 'Test string',
              repository: 'Test string',
              version: 'Test string',
            },
          ],
          npmPackages: [
            {
              packagePath: 'Test string',
              repository: 'Test string',
            },
          ],
          objects: {
            location: 'Test string',
            paths: ['Test string'],
            timing: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
          },
          pythonPackages: [
            {
              paths: ['Test string'],
              repository: 'Test string',
            },
          ],
        },
        availableSecrets: {
          inline: [
            {
              envMap: {
                A: 'Test string',
              },
              kmsKeyName: 'Test string',
            },
          ],
          secretManager: [
            {
              env: 'Test string',
              versionName: 'Test string',
            },
          ],
        },
        buildTriggerId: 'Test string',
        createTime: 'Test string',
        failureInfo: {
          detail: 'Test string',
          type: 'Test string',
        },
        finishTime: 'Test string',
        id: 'Test string',
        images: ['Test string'],
        logsBucket: 'Test string',
        logUrl: 'Test string',
        name: 'Test string',
        options: {
          automapSubstitutions: true,
          defaultLogsBucketBehavior: 'Test string',
          diskSizeGb: 'Test string',
          dynamicSubstitutions: true,
          env: ['Test string'],
          logging: 'Test string',
          logStreamingOption: 'Test string',
          machineType: 'Test string',
          pool: {
            name: 'Test string',
          },
          requestedVerifyOption: 'Test string',
          secretEnv: ['Test string'],
          sourceProvenanceHash: ['Test string'],
          substitutionOption: 'Test string',
          volumes: [
            {
              name: 'Test string',
              path: 'Test string',
            },
          ],
          workerPool: 'Test string',
        },
        projectId: 'Test string',
        queueTtl: 'Test string',
        results: {
          artifactManifest: 'Test string',
          artifactTiming: {
            endTime: 'Test string',
            startTime: 'Test string',
          },
          buildStepImages: ['Test string'],
          buildStepOutputs: ['Test string'],
          images: [
            {
              digest: 'Test string',
              name: 'Test string',
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
            },
          ],
          mavenArtifacts: [
            {
              fileHashes: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              uri: 'Test string',
            },
          ],
          npmPackages: [
            {
              fileHashes: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              uri: 'Test string',
            },
          ],
          numArtifacts: 'Test string',
          pythonPackages: [
            {
              fileHashes: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              uri: 'Test string',
            },
          ],
        },
        secrets: [
          {
            kmsKeyName: 'Test string',
            secretEnv: {
              A: 'Test string',
            },
          },
        ],
        serviceAccount: 'Test string',
        source: {
          connectedRepository: {
            dir: 'Test string',
            repository: 'Test string',
            revision: 'Test string',
          },
          gitSource: {
            dir: 'Test string',
            revision: 'Test string',
            url: 'Test string',
          },
          repoSource: {
            branchName: 'Test string',
            commitSha: 'Test string',
            dir: 'Test string',
            invertRegex: true,
            projectId: 'Test string',
            repoName: 'Test string',
            substitutions: {
              A: 'Test string',
            },
            tagName: 'Test string',
          },
          storageSource: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
            sourceFetcher: 'Test string',
          },
          storageSourceManifest: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
          },
        },
        sourceProvenance: {
          fileHashes: {
            A: {
              fileHash: [
                {
                  type: 'Test string',
                  value: 'Test string',
                },
              ],
            },
          },
          resolvedConnectedRepository: {
            dir: 'Test string',
            repository: 'Test string',
            revision: 'Test string',
          },
          resolvedGitSource: {
            dir: 'Test string',
            revision: 'Test string',
            url: 'Test string',
          },
          resolvedRepoSource: {
            branchName: 'Test string',
            commitSha: 'Test string',
            dir: 'Test string',
            invertRegex: true,
            projectId: 'Test string',
            repoName: 'Test string',
            substitutions: {
              A: 'Test string',
            },
            tagName: 'Test string',
          },
          resolvedStorageSource: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
            sourceFetcher: 'Test string',
          },
          resolvedStorageSourceManifest: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
          },
        },
        startTime: 'Test string',
        status: 'Test string',
        statusDetail: 'Test string',
        steps: [
          {
            allowExitCodes: [42],
            allowFailure: true,
            args: ['Test string'],
            automapSubstitutions: true,
            dir: 'Test string',
            entrypoint: 'Test string',
            env: ['Test string'],
            exitCode: 42,
            id: 'Test string',
            name: 'Test string',
            pullTiming: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            script: 'Test string',
            secretEnv: ['Test string'],
            status: 'Test string',
            timeout: 'Test string',
            timing: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            volumes: [
              {
                name: 'Test string',
                path: 'Test string',
              },
            ],
            waitFor: ['Test string'],
          },
        ],
        substitutions: {
          A: 'Test string',
        },
        tags: ['Test string'],
        timeout: 'Test string',
        timing: {
          A: {
            endTime: 'Test string',
            startTime: 'Test string',
          },
        },
        warnings: [
          {
            priority: 'Test string',
            text: 'Test string',
          },
        ],
      }
    );
    /** Returns information about a previously requested build. The `Build` that is returned includes its status (such as `SUCCESS`, `FAILURE`, or `WORKING`), and timing information. */
    await gapi.client.cloudbuild.projects.builds.get({
      id: 'Test string',
      name: 'Test string',
      projectId: 'Test string',
    });
    /** Lists previously requested builds. Previously requested builds may still be in-progress, or may have finished successfully or unsuccessfully. */
    await gapi.client.cloudbuild.projects.builds.list({
      filter: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
      projectId: 'Test string',
    });
    /** Creates a new build based on the specified build. This method creates a new build using the original build request, which may or may not result in an identical build. For triggered builds: * Triggered builds resolve to a precise revision; therefore a retry of a triggered build will result in a build that uses the same revision. For non-triggered builds that specify `RepoSource`: * If the original build built from the tip of a branch, the retried build will build from the tip of that branch, which may not be the same revision as the original build. * If the original build specified a commit sha or revision ID, the retried build will use the identical source. For builds that specify `StorageSource`: * If the original build pulled source from Cloud Storage without specifying the generation of the object, the new build will use the current object, which may be different from the original build source. * If the original build pulled source from Cloud Storage and specified the generation of the object, the new build will attempt to use the same object, which may or may not be available depending on the bucket's lifecycle management settings. */
    await gapi.client.cloudbuild.projects.builds.retry(
      {
        id: 'Test string',
        projectId: 'Test string',
      },
      {
        id: 'Test string',
        name: 'Test string',
        projectId: 'Test string',
      }
    );
    /** Create an association between a GCP project and a GitHub Enterprise server. */
    await gapi.client.cloudbuild.projects.githubEnterpriseConfigs.create(
      {
        gheConfigId: 'Test string',
        parent: 'Test string',
        projectId: 'Test string',
      },
      {
        appId: 'Test string',
        createTime: 'Test string',
        displayName: 'Test string',
        hostUrl: 'Test string',
        name: 'Test string',
        peeredNetwork: 'Test string',
        secrets: {
          oauthClientIdName: 'Test string',
          oauthClientIdVersionName: 'Test string',
          oauthSecretName: 'Test string',
          oauthSecretVersionName: 'Test string',
          privateKeyName: 'Test string',
          privateKeyVersionName: 'Test string',
          webhookSecretName: 'Test string',
          webhookSecretVersionName: 'Test string',
        },
        sslCa: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Delete an association between a GCP project and a GitHub Enterprise server. */
    await gapi.client.cloudbuild.projects.githubEnterpriseConfigs.delete({
      configId: 'Test string',
      name: 'Test string',
      projectId: 'Test string',
    });
    /** Retrieve a GitHubEnterpriseConfig. */
    await gapi.client.cloudbuild.projects.githubEnterpriseConfigs.get({
      configId: 'Test string',
      name: 'Test string',
      projectId: 'Test string',
    });
    /** List all GitHubEnterpriseConfigs for a given project. */
    await gapi.client.cloudbuild.projects.githubEnterpriseConfigs.list({
      parent: 'Test string',
      projectId: 'Test string',
    });
    /** Update an association between a GCP project and a GitHub Enterprise server. */
    await gapi.client.cloudbuild.projects.githubEnterpriseConfigs.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        appId: 'Test string',
        createTime: 'Test string',
        displayName: 'Test string',
        hostUrl: 'Test string',
        name: 'Test string',
        peeredNetwork: 'Test string',
        secrets: {
          oauthClientIdName: 'Test string',
          oauthClientIdVersionName: 'Test string',
          oauthSecretName: 'Test string',
          oauthSecretVersionName: 'Test string',
          privateKeyName: 'Test string',
          privateKeyVersionName: 'Test string',
          webhookSecretName: 'Test string',
          webhookSecretVersionName: 'Test string',
        },
        sslCa: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Creates a new `BitbucketServerConfig`. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.create(
      {
        bitbucketServerConfigId: 'Test string',
        parent: 'Test string',
      },
      {
        apiKey: 'Test string',
        connectedRepositories: [
          {
            projectKey: 'Test string',
            repoSlug: 'Test string',
            webhookId: 42,
          },
        ],
        createTime: 'Test string',
        hostUri: 'Test string',
        name: 'Test string',
        peeredNetwork: 'Test string',
        peeredNetworkIpRange: 'Test string',
        secrets: {
          adminAccessTokenVersionName: 'Test string',
          readAccessTokenVersionName: 'Test string',
          webhookSecretVersionName: 'Test string',
        },
        sslCa: 'Test string',
        username: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Delete a `BitbucketServerConfig`. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.delete(
      {
        name: 'Test string',
      }
    );
    /** Retrieve a `BitbucketServerConfig`. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.get({
      name: 'Test string',
    });
    /** List all `BitbucketServerConfigs` for a given project. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.list(
      {
        pageSize: 42,
        pageToken: 'Test string',
        parent: 'Test string',
      }
    );
    /** Updates an existing `BitbucketServerConfig`. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        apiKey: 'Test string',
        connectedRepositories: [
          {
            projectKey: 'Test string',
            repoSlug: 'Test string',
            webhookId: 42,
          },
        ],
        createTime: 'Test string',
        hostUri: 'Test string',
        name: 'Test string',
        peeredNetwork: 'Test string',
        peeredNetworkIpRange: 'Test string',
        secrets: {
          adminAccessTokenVersionName: 'Test string',
          readAccessTokenVersionName: 'Test string',
          webhookSecretVersionName: 'Test string',
        },
        sslCa: 'Test string',
        username: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Remove a Bitbucket Server repository from a given BitbucketServerConfig's connected repositories. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.removeBitbucketServerConnectedRepository(
      {
        config: 'Test string',
      },
      {
        connectedRepository: {
          projectKey: 'Test string',
          repoSlug: 'Test string',
          webhookId: 42,
        },
      }
    );
    /** Batch connecting Bitbucket Server repositories to Cloud Build. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.connectedRepositories.batchCreate(
      {
        parent: 'Test string',
      },
      {
        requests: [
          {
            bitbucketServerConnectedRepository: {
              parent: 'Test string',
              repo: {
                projectKey: 'Test string',
                repoSlug: 'Test string',
                webhookId: 42,
              },
              status: {
                code: 42,
                details: [
                  {
                    A: 42,
                  },
                ],
                message: 'Test string',
              },
            },
            parent: 'Test string',
          },
        ],
      }
    );
    /** List all repositories for a given `BitbucketServerConfig`. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.bitbucketServerConfigs.repos.list(
      {
        pageSize: 42,
        pageToken: 'Test string',
        parent: 'Test string',
      }
    );
    /** Approves or rejects a pending build. If approved, the returned LRO will be analogous to the LRO returned from a CreateBuild call. If rejected, the returned LRO will be immediately done. */
    await gapi.client.cloudbuild.projects.locations.builds.approve(
      {
        name: 'Test string',
      },
      {
        approvalResult: {
          approvalTime: 'Test string',
          approverAccount: 'Test string',
          comment: 'Test string',
          decision: 'Test string',
          url: 'Test string',
        },
      }
    );
    /** Cancels a build in progress. */
    await gapi.client.cloudbuild.projects.locations.builds.cancel(
      {
        name: 'Test string',
      },
      {
        id: 'Test string',
        name: 'Test string',
        projectId: 'Test string',
      }
    );
    /** Starts a build with the specified configuration. This method returns a long-running `Operation`, which includes the build ID. Pass the build ID to `GetBuild` to determine the build status (such as `SUCCESS` or `FAILURE`). */
    await gapi.client.cloudbuild.projects.locations.builds.create(
      {
        parent: 'Test string',
        projectId: 'Test string',
      },
      {
        approval: {
          config: {
            approvalRequired: true,
          },
          result: {
            approvalTime: 'Test string',
            approverAccount: 'Test string',
            comment: 'Test string',
            decision: 'Test string',
            url: 'Test string',
          },
          state: 'Test string',
        },
        artifacts: {
          images: ['Test string'],
          mavenArtifacts: [
            {
              artifactId: 'Test string',
              groupId: 'Test string',
              path: 'Test string',
              repository: 'Test string',
              version: 'Test string',
            },
          ],
          npmPackages: [
            {
              packagePath: 'Test string',
              repository: 'Test string',
            },
          ],
          objects: {
            location: 'Test string',
            paths: ['Test string'],
            timing: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
          },
          pythonPackages: [
            {
              paths: ['Test string'],
              repository: 'Test string',
            },
          ],
        },
        availableSecrets: {
          inline: [
            {
              envMap: {
                A: 'Test string',
              },
              kmsKeyName: 'Test string',
            },
          ],
          secretManager: [
            {
              env: 'Test string',
              versionName: 'Test string',
            },
          ],
        },
        buildTriggerId: 'Test string',
        createTime: 'Test string',
        failureInfo: {
          detail: 'Test string',
          type: 'Test string',
        },
        finishTime: 'Test string',
        id: 'Test string',
        images: ['Test string'],
        logsBucket: 'Test string',
        logUrl: 'Test string',
        name: 'Test string',
        options: {
          automapSubstitutions: true,
          defaultLogsBucketBehavior: 'Test string',
          diskSizeGb: 'Test string',
          dynamicSubstitutions: true,
          env: ['Test string'],
          logging: 'Test string',
          logStreamingOption: 'Test string',
          machineType: 'Test string',
          pool: {
            name: 'Test string',
          },
          requestedVerifyOption: 'Test string',
          secretEnv: ['Test string'],
          sourceProvenanceHash: ['Test string'],
          substitutionOption: 'Test string',
          volumes: [
            {
              name: 'Test string',
              path: 'Test string',
            },
          ],
          workerPool: 'Test string',
        },
        projectId: 'Test string',
        queueTtl: 'Test string',
        results: {
          artifactManifest: 'Test string',
          artifactTiming: {
            endTime: 'Test string',
            startTime: 'Test string',
          },
          buildStepImages: ['Test string'],
          buildStepOutputs: ['Test string'],
          images: [
            {
              digest: 'Test string',
              name: 'Test string',
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
            },
          ],
          mavenArtifacts: [
            {
              fileHashes: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              uri: 'Test string',
            },
          ],
          npmPackages: [
            {
              fileHashes: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              uri: 'Test string',
            },
          ],
          numArtifacts: 'Test string',
          pythonPackages: [
            {
              fileHashes: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
              pushTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              uri: 'Test string',
            },
          ],
        },
        secrets: [
          {
            kmsKeyName: 'Test string',
            secretEnv: {
              A: 'Test string',
            },
          },
        ],
        serviceAccount: 'Test string',
        source: {
          connectedRepository: {
            dir: 'Test string',
            repository: 'Test string',
            revision: 'Test string',
          },
          gitSource: {
            dir: 'Test string',
            revision: 'Test string',
            url: 'Test string',
          },
          repoSource: {
            branchName: 'Test string',
            commitSha: 'Test string',
            dir: 'Test string',
            invertRegex: true,
            projectId: 'Test string',
            repoName: 'Test string',
            substitutions: {
              A: 'Test string',
            },
            tagName: 'Test string',
          },
          storageSource: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
            sourceFetcher: 'Test string',
          },
          storageSourceManifest: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
          },
        },
        sourceProvenance: {
          fileHashes: {
            A: {
              fileHash: [
                {
                  type: 'Test string',
                  value: 'Test string',
                },
              ],
            },
          },
          resolvedConnectedRepository: {
            dir: 'Test string',
            repository: 'Test string',
            revision: 'Test string',
          },
          resolvedGitSource: {
            dir: 'Test string',
            revision: 'Test string',
            url: 'Test string',
          },
          resolvedRepoSource: {
            branchName: 'Test string',
            commitSha: 'Test string',
            dir: 'Test string',
            invertRegex: true,
            projectId: 'Test string',
            repoName: 'Test string',
            substitutions: {
              A: 'Test string',
            },
            tagName: 'Test string',
          },
          resolvedStorageSource: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
            sourceFetcher: 'Test string',
          },
          resolvedStorageSourceManifest: {
            bucket: 'Test string',
            generation: 'Test string',
            object: 'Test string',
          },
        },
        startTime: 'Test string',
        status: 'Test string',
        statusDetail: 'Test string',
        steps: [
          {
            allowExitCodes: [42],
            allowFailure: true,
            args: ['Test string'],
            automapSubstitutions: true,
            dir: 'Test string',
            entrypoint: 'Test string',
            env: ['Test string'],
            exitCode: 42,
            id: 'Test string',
            name: 'Test string',
            pullTiming: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            script: 'Test string',
            secretEnv: ['Test string'],
            status: 'Test string',
            timeout: 'Test string',
            timing: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            volumes: [
              {
                name: 'Test string',
                path: 'Test string',
              },
            ],
            waitFor: ['Test string'],
          },
        ],
        substitutions: {
          A: 'Test string',
        },
        tags: ['Test string'],
        timeout: 'Test string',
        timing: {
          A: {
            endTime: 'Test string',
            startTime: 'Test string',
          },
        },
        warnings: [
          {
            priority: 'Test string',
            text: 'Test string',
          },
        ],
      }
    );
    /** Returns information about a previously requested build. The `Build` that is returned includes its status (such as `SUCCESS`, `FAILURE`, or `WORKING`), and timing information. */
    await gapi.client.cloudbuild.projects.locations.builds.get({
      id: 'Test string',
      name: 'Test string',
      projectId: 'Test string',
    });
    /** Lists previously requested builds. Previously requested builds may still be in-progress, or may have finished successfully or unsuccessfully. */
    await gapi.client.cloudbuild.projects.locations.builds.list({
      filter: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
      projectId: 'Test string',
    });
    /** Creates a new build based on the specified build. This method creates a new build using the original build request, which may or may not result in an identical build. For triggered builds: * Triggered builds resolve to a precise revision; therefore a retry of a triggered build will result in a build that uses the same revision. For non-triggered builds that specify `RepoSource`: * If the original build built from the tip of a branch, the retried build will build from the tip of that branch, which may not be the same revision as the original build. * If the original build specified a commit sha or revision ID, the retried build will use the identical source. For builds that specify `StorageSource`: * If the original build pulled source from Cloud Storage without specifying the generation of the object, the new build will use the current object, which may be different from the original build source. * If the original build pulled source from Cloud Storage and specified the generation of the object, the new build will attempt to use the same object, which may or may not be available depending on the bucket's lifecycle management settings. */
    await gapi.client.cloudbuild.projects.locations.builds.retry(
      {
        name: 'Test string',
      },
      {
        id: 'Test string',
        name: 'Test string',
        projectId: 'Test string',
      }
    );
    /** Create an association between a GCP project and a GitHub Enterprise server. */
    await gapi.client.cloudbuild.projects.locations.githubEnterpriseConfigs.create(
      {
        gheConfigId: 'Test string',
        parent: 'Test string',
        projectId: 'Test string',
      },
      {
        appId: 'Test string',
        createTime: 'Test string',
        displayName: 'Test string',
        hostUrl: 'Test string',
        name: 'Test string',
        peeredNetwork: 'Test string',
        secrets: {
          oauthClientIdName: 'Test string',
          oauthClientIdVersionName: 'Test string',
          oauthSecretName: 'Test string',
          oauthSecretVersionName: 'Test string',
          privateKeyName: 'Test string',
          privateKeyVersionName: 'Test string',
          webhookSecretName: 'Test string',
          webhookSecretVersionName: 'Test string',
        },
        sslCa: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Delete an association between a GCP project and a GitHub Enterprise server. */
    await gapi.client.cloudbuild.projects.locations.githubEnterpriseConfigs.delete(
      {
        configId: 'Test string',
        name: 'Test string',
        projectId: 'Test string',
      }
    );
    /** Retrieve a GitHubEnterpriseConfig. */
    await gapi.client.cloudbuild.projects.locations.githubEnterpriseConfigs.get(
      {
        configId: 'Test string',
        name: 'Test string',
        projectId: 'Test string',
      }
    );
    /** List all GitHubEnterpriseConfigs for a given project. */
    await gapi.client.cloudbuild.projects.locations.githubEnterpriseConfigs.list(
      {
        parent: 'Test string',
        projectId: 'Test string',
      }
    );
    /** Update an association between a GCP project and a GitHub Enterprise server. */
    await gapi.client.cloudbuild.projects.locations.githubEnterpriseConfigs.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        appId: 'Test string',
        createTime: 'Test string',
        displayName: 'Test string',
        hostUrl: 'Test string',
        name: 'Test string',
        peeredNetwork: 'Test string',
        secrets: {
          oauthClientIdName: 'Test string',
          oauthClientIdVersionName: 'Test string',
          oauthSecretName: 'Test string',
          oauthSecretVersionName: 'Test string',
          privateKeyName: 'Test string',
          privateKeyVersionName: 'Test string',
          webhookSecretName: 'Test string',
          webhookSecretVersionName: 'Test string',
        },
        sslCa: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Creates a new `GitLabConfig`. This API is experimental */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.create(
      {
        gitlabConfigId: 'Test string',
        parent: 'Test string',
      },
      {
        connectedRepositories: [
          {
            id: 'Test string',
            webhookId: 42,
          },
        ],
        createTime: 'Test string',
        enterpriseConfig: {
          hostUri: 'Test string',
          serviceDirectoryConfig: {
            service: 'Test string',
          },
          sslCa: 'Test string',
        },
        name: 'Test string',
        secrets: {
          apiAccessTokenVersion: 'Test string',
          apiKeyVersion: 'Test string',
          readAccessTokenVersion: 'Test string',
          webhookSecretVersion: 'Test string',
        },
        username: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Delete a `GitLabConfig`. This API is experimental */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.delete({
      name: 'Test string',
    });
    /** Retrieves a `GitLabConfig`. This API is experimental */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.get({
      name: 'Test string',
    });
    /** List all `GitLabConfigs` for a given project. This API is experimental */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.list({
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates an existing `GitLabConfig`. This API is experimental */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        connectedRepositories: [
          {
            id: 'Test string',
            webhookId: 42,
          },
        ],
        createTime: 'Test string',
        enterpriseConfig: {
          hostUri: 'Test string',
          serviceDirectoryConfig: {
            service: 'Test string',
          },
          sslCa: 'Test string',
        },
        name: 'Test string',
        secrets: {
          apiAccessTokenVersion: 'Test string',
          apiKeyVersion: 'Test string',
          readAccessTokenVersion: 'Test string',
          webhookSecretVersion: 'Test string',
        },
        username: 'Test string',
        webhookKey: 'Test string',
      }
    );
    /** Remove a GitLab repository from a given GitLabConfig's connected repositories. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.removeGitLabConnectedRepository(
      {
        config: 'Test string',
      },
      {
        connectedRepository: {
          id: 'Test string',
          webhookId: 42,
        },
      }
    );
    /** Batch connecting GitLab repositories to Cloud Build. This API is experimental. */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.connectedRepositories.batchCreate(
      {
        parent: 'Test string',
      },
      {
        requests: [
          {
            gitlabConnectedRepository: {
              parent: 'Test string',
              repo: {
                id: 'Test string',
                webhookId: 42,
              },
              status: {
                code: 42,
                details: [
                  {
                    A: 42,
                  },
                ],
                message: 'Test string',
              },
            },
            parent: 'Test string',
          },
        ],
      }
    );
    /** List all repositories for a given `GitLabConfig`. This API is experimental */
    await gapi.client.cloudbuild.projects.locations.gitLabConfigs.repos.list({
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of 1, corresponding to `Code.CANCELLED`. */
    await gapi.client.cloudbuild.projects.locations.operations.cancel(
      {
        name: 'Test string',
      },
      {}
    );
    /** Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service. */
    await gapi.client.cloudbuild.projects.locations.operations.get({
      name: 'Test string',
    });
    /** Creates a new `BuildTrigger`. */
    await gapi.client.cloudbuild.projects.locations.triggers.create(
      {
        parent: 'Test string',
        projectId: 'Test string',
      },
      {
        approvalConfig: {
          approvalRequired: true,
        },
        autodetect: true,
        bitbucketServerTriggerConfig: {
          bitbucketServerConfig: {
            apiKey: 'Test string',
            connectedRepositories: [
              {
                projectKey: 'Test string',
                repoSlug: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            hostUri: 'Test string',
            name: 'Test string',
            peeredNetwork: 'Test string',
            peeredNetworkIpRange: 'Test string',
            secrets: {
              adminAccessTokenVersionName: 'Test string',
              readAccessTokenVersionName: 'Test string',
              webhookSecretVersionName: 'Test string',
            },
            sslCa: 'Test string',
            username: 'Test string',
            webhookKey: 'Test string',
          },
          bitbucketServerConfigResource: 'Test string',
          projectKey: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repoSlug: 'Test string',
        },
        build: {
          approval: {
            config: {
              approvalRequired: true,
            },
            result: {
              approvalTime: 'Test string',
              approverAccount: 'Test string',
              comment: 'Test string',
              decision: 'Test string',
              url: 'Test string',
            },
            state: 'Test string',
          },
          artifacts: {
            images: ['Test string'],
            mavenArtifacts: [
              {
                artifactId: 'Test string',
                groupId: 'Test string',
                path: 'Test string',
                repository: 'Test string',
                version: 'Test string',
              },
            ],
            npmPackages: [
              {
                packagePath: 'Test string',
                repository: 'Test string',
              },
            ],
            objects: {
              location: 'Test string',
              paths: ['Test string'],
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
            },
            pythonPackages: [
              {
                paths: ['Test string'],
                repository: 'Test string',
              },
            ],
          },
          availableSecrets: {
            inline: [
              {
                envMap: {
                  A: 'Test string',
                },
                kmsKeyName: 'Test string',
              },
            ],
            secretManager: [
              {
                env: 'Test string',
                versionName: 'Test string',
              },
            ],
          },
          buildTriggerId: 'Test string',
          createTime: 'Test string',
          failureInfo: {
            detail: 'Test string',
            type: 'Test string',
          },
          finishTime: 'Test string',
          id: 'Test string',
          images: ['Test string'],
          logsBucket: 'Test string',
          logUrl: 'Test string',
          name: 'Test string',
          options: {
            automapSubstitutions: true,
            defaultLogsBucketBehavior: 'Test string',
            diskSizeGb: 'Test string',
            dynamicSubstitutions: true,
            env: ['Test string'],
            logging: 'Test string',
            logStreamingOption: 'Test string',
            machineType: 'Test string',
            pool: {
              name: 'Test string',
            },
            requestedVerifyOption: 'Test string',
            secretEnv: ['Test string'],
            sourceProvenanceHash: ['Test string'],
            substitutionOption: 'Test string',
            volumes: [
              {
                name: 'Test string',
                path: 'Test string',
              },
            ],
            workerPool: 'Test string',
          },
          projectId: 'Test string',
          queueTtl: 'Test string',
          results: {
            artifactManifest: 'Test string',
            artifactTiming: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            buildStepImages: ['Test string'],
            buildStepOutputs: ['Test string'],
            images: [
              {
                digest: 'Test string',
                name: 'Test string',
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
              },
            ],
            mavenArtifacts: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            npmPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            numArtifacts: 'Test string',
            pythonPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
          },
          secrets: [
            {
              kmsKeyName: 'Test string',
              secretEnv: {
                A: 'Test string',
              },
            },
          ],
          serviceAccount: 'Test string',
          source: {
            connectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            gitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            repoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            storageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            storageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          sourceProvenance: {
            fileHashes: {
              A: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
            },
            resolvedConnectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            resolvedGitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            resolvedRepoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            resolvedStorageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            resolvedStorageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          startTime: 'Test string',
          status: 'Test string',
          statusDetail: 'Test string',
          steps: [
            {
              allowExitCodes: [42],
              allowFailure: true,
              args: ['Test string'],
              automapSubstitutions: true,
              dir: 'Test string',
              entrypoint: 'Test string',
              env: ['Test string'],
              exitCode: 42,
              id: 'Test string',
              name: 'Test string',
              pullTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              script: 'Test string',
              secretEnv: ['Test string'],
              status: 'Test string',
              timeout: 'Test string',
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              volumes: [
                {
                  name: 'Test string',
                  path: 'Test string',
                },
              ],
              waitFor: ['Test string'],
            },
          ],
          substitutions: {
            A: 'Test string',
          },
          tags: ['Test string'],
          timeout: 'Test string',
          timing: {
            A: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
          },
          warnings: [
            {
              priority: 'Test string',
              text: 'Test string',
            },
          ],
        },
        createTime: 'Test string',
        description: 'Test string',
        disabled: true,
        eventType: 'Test string',
        filename: 'Test string',
        filter: 'Test string',
        gitFileSource: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          path: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          revision: 'Test string',
          uri: 'Test string',
        },
        github: {
          enterpriseConfigResourceName: 'Test string',
          installationId: 'Test string',
          name: 'Test string',
          owner: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        gitlabEnterpriseEventsConfig: {
          gitlabConfig: {
            connectedRepositories: [
              {
                id: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            enterpriseConfig: {
              hostUri: 'Test string',
              serviceDirectoryConfig: {
                service: 'Test string',
              },
              sslCa: 'Test string',
            },
            name: 'Test string',
            secrets: {
              apiAccessTokenVersion: 'Test string',
              apiKeyVersion: 'Test string',
              readAccessTokenVersion: 'Test string',
              webhookSecretVersion: 'Test string',
            },
            username: 'Test string',
            webhookKey: 'Test string',
          },
          gitlabConfigResource: 'Test string',
          projectNamespace: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        id: 'Test string',
        ignoredFiles: ['Test string'],
        includeBuildLogs: 'Test string',
        includedFiles: ['Test string'],
        name: 'Test string',
        pubsubConfig: {
          serviceAccountEmail: 'Test string',
          state: 'Test string',
          subscription: 'Test string',
          topic: 'Test string',
        },
        repositoryEventConfig: {
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repository: 'Test string',
          repositoryType: 'Test string',
        },
        resourceName: 'Test string',
        serviceAccount: 'Test string',
        sourceToBuild: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          ref: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          uri: 'Test string',
        },
        substitutions: {
          A: 'Test string',
        },
        tags: ['Test string'],
        triggerTemplate: {
          branchName: 'Test string',
          commitSha: 'Test string',
          dir: 'Test string',
          invertRegex: true,
          projectId: 'Test string',
          repoName: 'Test string',
          substitutions: {
            A: 'Test string',
          },
          tagName: 'Test string',
        },
        webhookConfig: {
          secret: 'Test string',
          state: 'Test string',
        },
      }
    );
    /** Deletes a `BuildTrigger` by its project ID and trigger ID. */
    await gapi.client.cloudbuild.projects.locations.triggers.delete({
      name: 'Test string',
      projectId: 'Test string',
      triggerId: 'Test string',
    });
    /** Returns information about a `BuildTrigger`. */
    await gapi.client.cloudbuild.projects.locations.triggers.get({
      name: 'Test string',
      projectId: 'Test string',
      triggerId: 'Test string',
    });
    /** Lists existing `BuildTrigger`s. */
    await gapi.client.cloudbuild.projects.locations.triggers.list({
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
      projectId: 'Test string',
    });
    /** Updates a `BuildTrigger` by its project ID and trigger ID. */
    await gapi.client.cloudbuild.projects.locations.triggers.patch(
      {
        projectId: 'Test string',
        resourceName: 'Test string',
        triggerId: 'Test string',
        updateMask: 'Test string',
      },
      {
        approvalConfig: {
          approvalRequired: true,
        },
        autodetect: true,
        bitbucketServerTriggerConfig: {
          bitbucketServerConfig: {
            apiKey: 'Test string',
            connectedRepositories: [
              {
                projectKey: 'Test string',
                repoSlug: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            hostUri: 'Test string',
            name: 'Test string',
            peeredNetwork: 'Test string',
            peeredNetworkIpRange: 'Test string',
            secrets: {
              adminAccessTokenVersionName: 'Test string',
              readAccessTokenVersionName: 'Test string',
              webhookSecretVersionName: 'Test string',
            },
            sslCa: 'Test string',
            username: 'Test string',
            webhookKey: 'Test string',
          },
          bitbucketServerConfigResource: 'Test string',
          projectKey: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repoSlug: 'Test string',
        },
        build: {
          approval: {
            config: {
              approvalRequired: true,
            },
            result: {
              approvalTime: 'Test string',
              approverAccount: 'Test string',
              comment: 'Test string',
              decision: 'Test string',
              url: 'Test string',
            },
            state: 'Test string',
          },
          artifacts: {
            images: ['Test string'],
            mavenArtifacts: [
              {
                artifactId: 'Test string',
                groupId: 'Test string',
                path: 'Test string',
                repository: 'Test string',
                version: 'Test string',
              },
            ],
            npmPackages: [
              {
                packagePath: 'Test string',
                repository: 'Test string',
              },
            ],
            objects: {
              location: 'Test string',
              paths: ['Test string'],
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
            },
            pythonPackages: [
              {
                paths: ['Test string'],
                repository: 'Test string',
              },
            ],
          },
          availableSecrets: {
            inline: [
              {
                envMap: {
                  A: 'Test string',
                },
                kmsKeyName: 'Test string',
              },
            ],
            secretManager: [
              {
                env: 'Test string',
                versionName: 'Test string',
              },
            ],
          },
          buildTriggerId: 'Test string',
          createTime: 'Test string',
          failureInfo: {
            detail: 'Test string',
            type: 'Test string',
          },
          finishTime: 'Test string',
          id: 'Test string',
          images: ['Test string'],
          logsBucket: 'Test string',
          logUrl: 'Test string',
          name: 'Test string',
          options: {
            automapSubstitutions: true,
            defaultLogsBucketBehavior: 'Test string',
            diskSizeGb: 'Test string',
            dynamicSubstitutions: true,
            env: ['Test string'],
            logging: 'Test string',
            logStreamingOption: 'Test string',
            machineType: 'Test string',
            pool: {
              name: 'Test string',
            },
            requestedVerifyOption: 'Test string',
            secretEnv: ['Test string'],
            sourceProvenanceHash: ['Test string'],
            substitutionOption: 'Test string',
            volumes: [
              {
                name: 'Test string',
                path: 'Test string',
              },
            ],
            workerPool: 'Test string',
          },
          projectId: 'Test string',
          queueTtl: 'Test string',
          results: {
            artifactManifest: 'Test string',
            artifactTiming: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            buildStepImages: ['Test string'],
            buildStepOutputs: ['Test string'],
            images: [
              {
                digest: 'Test string',
                name: 'Test string',
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
              },
            ],
            mavenArtifacts: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            npmPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            numArtifacts: 'Test string',
            pythonPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
          },
          secrets: [
            {
              kmsKeyName: 'Test string',
              secretEnv: {
                A: 'Test string',
              },
            },
          ],
          serviceAccount: 'Test string',
          source: {
            connectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            gitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            repoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            storageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            storageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          sourceProvenance: {
            fileHashes: {
              A: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
            },
            resolvedConnectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            resolvedGitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            resolvedRepoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            resolvedStorageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            resolvedStorageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          startTime: 'Test string',
          status: 'Test string',
          statusDetail: 'Test string',
          steps: [
            {
              allowExitCodes: [42],
              allowFailure: true,
              args: ['Test string'],
              automapSubstitutions: true,
              dir: 'Test string',
              entrypoint: 'Test string',
              env: ['Test string'],
              exitCode: 42,
              id: 'Test string',
              name: 'Test string',
              pullTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              script: 'Test string',
              secretEnv: ['Test string'],
              status: 'Test string',
              timeout: 'Test string',
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              volumes: [
                {
                  name: 'Test string',
                  path: 'Test string',
                },
              ],
              waitFor: ['Test string'],
            },
          ],
          substitutions: {
            A: 'Test string',
          },
          tags: ['Test string'],
          timeout: 'Test string',
          timing: {
            A: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
          },
          warnings: [
            {
              priority: 'Test string',
              text: 'Test string',
            },
          ],
        },
        createTime: 'Test string',
        description: 'Test string',
        disabled: true,
        eventType: 'Test string',
        filename: 'Test string',
        filter: 'Test string',
        gitFileSource: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          path: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          revision: 'Test string',
          uri: 'Test string',
        },
        github: {
          enterpriseConfigResourceName: 'Test string',
          installationId: 'Test string',
          name: 'Test string',
          owner: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        gitlabEnterpriseEventsConfig: {
          gitlabConfig: {
            connectedRepositories: [
              {
                id: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            enterpriseConfig: {
              hostUri: 'Test string',
              serviceDirectoryConfig: {
                service: 'Test string',
              },
              sslCa: 'Test string',
            },
            name: 'Test string',
            secrets: {
              apiAccessTokenVersion: 'Test string',
              apiKeyVersion: 'Test string',
              readAccessTokenVersion: 'Test string',
              webhookSecretVersion: 'Test string',
            },
            username: 'Test string',
            webhookKey: 'Test string',
          },
          gitlabConfigResource: 'Test string',
          projectNamespace: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        id: 'Test string',
        ignoredFiles: ['Test string'],
        includeBuildLogs: 'Test string',
        includedFiles: ['Test string'],
        name: 'Test string',
        pubsubConfig: {
          serviceAccountEmail: 'Test string',
          state: 'Test string',
          subscription: 'Test string',
          topic: 'Test string',
        },
        repositoryEventConfig: {
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repository: 'Test string',
          repositoryType: 'Test string',
        },
        resourceName: 'Test string',
        serviceAccount: 'Test string',
        sourceToBuild: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          ref: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          uri: 'Test string',
        },
        substitutions: {
          A: 'Test string',
        },
        tags: ['Test string'],
        triggerTemplate: {
          branchName: 'Test string',
          commitSha: 'Test string',
          dir: 'Test string',
          invertRegex: true,
          projectId: 'Test string',
          repoName: 'Test string',
          substitutions: {
            A: 'Test string',
          },
          tagName: 'Test string',
        },
        webhookConfig: {
          secret: 'Test string',
          state: 'Test string',
        },
      }
    );
    /** Runs a `BuildTrigger` at a particular source revision. To run a regional or global trigger, use the POST request that includes the location endpoint in the path (ex. v1/projects/{projectId}/locations/{region}/triggers/{triggerId}:run). The POST request that does not include the location endpoint in the path can only be used when running global triggers. */
    await gapi.client.cloudbuild.projects.locations.triggers.run(
      {
        name: 'Test string',
      },
      {
        projectId: 'Test string',
        source: {
          branchName: 'Test string',
          commitSha: 'Test string',
          dir: 'Test string',
          invertRegex: true,
          projectId: 'Test string',
          repoName: 'Test string',
          substitutions: {
            A: 'Test string',
          },
          tagName: 'Test string',
        },
        triggerId: 'Test string',
      }
    );
    /** ReceiveTriggerWebhook [Experimental] is called when the API receives a webhook request targeted at a specific trigger. */
    await gapi.client.cloudbuild.projects.locations.triggers.webhook(
      {
        name: 'Test string',
        projectId: 'Test string',
        secret: 'Test string',
        trigger: 'Test string',
      },
      {
        contentType: 'Test string',
        data: 'Test string',
        extensions: [
          {
            A: 42,
          },
        ],
      }
    );
    /** Creates a `WorkerPool`. */
    await gapi.client.cloudbuild.projects.locations.workerPools.create(
      {
        parent: 'Test string',
        validateOnly: true,
        workerPoolId: 'Test string',
      },
      {
        annotations: {
          A: 'Test string',
        },
        createTime: 'Test string',
        deleteTime: 'Test string',
        displayName: 'Test string',
        etag: 'Test string',
        name: 'Test string',
        privatePoolV1Config: {
          networkConfig: {
            egressOption: 'Test string',
            peeredNetwork: 'Test string',
            peeredNetworkIpRange: 'Test string',
          },
          workerConfig: {
            diskSizeGb: 'Test string',
            machineType: 'Test string',
          },
        },
        state: 'Test string',
        uid: 'Test string',
        updateTime: 'Test string',
      }
    );
    /** Deletes a `WorkerPool`. */
    await gapi.client.cloudbuild.projects.locations.workerPools.delete({
      allowMissing: true,
      etag: 'Test string',
      name: 'Test string',
      validateOnly: true,
    });
    /** Returns details of a `WorkerPool`. */
    await gapi.client.cloudbuild.projects.locations.workerPools.get({
      name: 'Test string',
    });
    /** Lists `WorkerPool`s. */
    await gapi.client.cloudbuild.projects.locations.workerPools.list({
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates a `WorkerPool`. */
    await gapi.client.cloudbuild.projects.locations.workerPools.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
        validateOnly: true,
      },
      {
        annotations: {
          A: 'Test string',
        },
        createTime: 'Test string',
        deleteTime: 'Test string',
        displayName: 'Test string',
        etag: 'Test string',
        name: 'Test string',
        privatePoolV1Config: {
          networkConfig: {
            egressOption: 'Test string',
            peeredNetwork: 'Test string',
            peeredNetworkIpRange: 'Test string',
          },
          workerConfig: {
            diskSizeGb: 'Test string',
            machineType: 'Test string',
          },
        },
        state: 'Test string',
        uid: 'Test string',
        updateTime: 'Test string',
      }
    );
    /** Creates a new `BuildTrigger`. */
    await gapi.client.cloudbuild.projects.triggers.create(
      {
        parent: 'Test string',
        projectId: 'Test string',
      },
      {
        approvalConfig: {
          approvalRequired: true,
        },
        autodetect: true,
        bitbucketServerTriggerConfig: {
          bitbucketServerConfig: {
            apiKey: 'Test string',
            connectedRepositories: [
              {
                projectKey: 'Test string',
                repoSlug: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            hostUri: 'Test string',
            name: 'Test string',
            peeredNetwork: 'Test string',
            peeredNetworkIpRange: 'Test string',
            secrets: {
              adminAccessTokenVersionName: 'Test string',
              readAccessTokenVersionName: 'Test string',
              webhookSecretVersionName: 'Test string',
            },
            sslCa: 'Test string',
            username: 'Test string',
            webhookKey: 'Test string',
          },
          bitbucketServerConfigResource: 'Test string',
          projectKey: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repoSlug: 'Test string',
        },
        build: {
          approval: {
            config: {
              approvalRequired: true,
            },
            result: {
              approvalTime: 'Test string',
              approverAccount: 'Test string',
              comment: 'Test string',
              decision: 'Test string',
              url: 'Test string',
            },
            state: 'Test string',
          },
          artifacts: {
            images: ['Test string'],
            mavenArtifacts: [
              {
                artifactId: 'Test string',
                groupId: 'Test string',
                path: 'Test string',
                repository: 'Test string',
                version: 'Test string',
              },
            ],
            npmPackages: [
              {
                packagePath: 'Test string',
                repository: 'Test string',
              },
            ],
            objects: {
              location: 'Test string',
              paths: ['Test string'],
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
            },
            pythonPackages: [
              {
                paths: ['Test string'],
                repository: 'Test string',
              },
            ],
          },
          availableSecrets: {
            inline: [
              {
                envMap: {
                  A: 'Test string',
                },
                kmsKeyName: 'Test string',
              },
            ],
            secretManager: [
              {
                env: 'Test string',
                versionName: 'Test string',
              },
            ],
          },
          buildTriggerId: 'Test string',
          createTime: 'Test string',
          failureInfo: {
            detail: 'Test string',
            type: 'Test string',
          },
          finishTime: 'Test string',
          id: 'Test string',
          images: ['Test string'],
          logsBucket: 'Test string',
          logUrl: 'Test string',
          name: 'Test string',
          options: {
            automapSubstitutions: true,
            defaultLogsBucketBehavior: 'Test string',
            diskSizeGb: 'Test string',
            dynamicSubstitutions: true,
            env: ['Test string'],
            logging: 'Test string',
            logStreamingOption: 'Test string',
            machineType: 'Test string',
            pool: {
              name: 'Test string',
            },
            requestedVerifyOption: 'Test string',
            secretEnv: ['Test string'],
            sourceProvenanceHash: ['Test string'],
            substitutionOption: 'Test string',
            volumes: [
              {
                name: 'Test string',
                path: 'Test string',
              },
            ],
            workerPool: 'Test string',
          },
          projectId: 'Test string',
          queueTtl: 'Test string',
          results: {
            artifactManifest: 'Test string',
            artifactTiming: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            buildStepImages: ['Test string'],
            buildStepOutputs: ['Test string'],
            images: [
              {
                digest: 'Test string',
                name: 'Test string',
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
              },
            ],
            mavenArtifacts: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            npmPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            numArtifacts: 'Test string',
            pythonPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
          },
          secrets: [
            {
              kmsKeyName: 'Test string',
              secretEnv: {
                A: 'Test string',
              },
            },
          ],
          serviceAccount: 'Test string',
          source: {
            connectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            gitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            repoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            storageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            storageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          sourceProvenance: {
            fileHashes: {
              A: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
            },
            resolvedConnectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            resolvedGitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            resolvedRepoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            resolvedStorageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            resolvedStorageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          startTime: 'Test string',
          status: 'Test string',
          statusDetail: 'Test string',
          steps: [
            {
              allowExitCodes: [42],
              allowFailure: true,
              args: ['Test string'],
              automapSubstitutions: true,
              dir: 'Test string',
              entrypoint: 'Test string',
              env: ['Test string'],
              exitCode: 42,
              id: 'Test string',
              name: 'Test string',
              pullTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              script: 'Test string',
              secretEnv: ['Test string'],
              status: 'Test string',
              timeout: 'Test string',
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              volumes: [
                {
                  name: 'Test string',
                  path: 'Test string',
                },
              ],
              waitFor: ['Test string'],
            },
          ],
          substitutions: {
            A: 'Test string',
          },
          tags: ['Test string'],
          timeout: 'Test string',
          timing: {
            A: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
          },
          warnings: [
            {
              priority: 'Test string',
              text: 'Test string',
            },
          ],
        },
        createTime: 'Test string',
        description: 'Test string',
        disabled: true,
        eventType: 'Test string',
        filename: 'Test string',
        filter: 'Test string',
        gitFileSource: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          path: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          revision: 'Test string',
          uri: 'Test string',
        },
        github: {
          enterpriseConfigResourceName: 'Test string',
          installationId: 'Test string',
          name: 'Test string',
          owner: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        gitlabEnterpriseEventsConfig: {
          gitlabConfig: {
            connectedRepositories: [
              {
                id: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            enterpriseConfig: {
              hostUri: 'Test string',
              serviceDirectoryConfig: {
                service: 'Test string',
              },
              sslCa: 'Test string',
            },
            name: 'Test string',
            secrets: {
              apiAccessTokenVersion: 'Test string',
              apiKeyVersion: 'Test string',
              readAccessTokenVersion: 'Test string',
              webhookSecretVersion: 'Test string',
            },
            username: 'Test string',
            webhookKey: 'Test string',
          },
          gitlabConfigResource: 'Test string',
          projectNamespace: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        id: 'Test string',
        ignoredFiles: ['Test string'],
        includeBuildLogs: 'Test string',
        includedFiles: ['Test string'],
        name: 'Test string',
        pubsubConfig: {
          serviceAccountEmail: 'Test string',
          state: 'Test string',
          subscription: 'Test string',
          topic: 'Test string',
        },
        repositoryEventConfig: {
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repository: 'Test string',
          repositoryType: 'Test string',
        },
        resourceName: 'Test string',
        serviceAccount: 'Test string',
        sourceToBuild: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          ref: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          uri: 'Test string',
        },
        substitutions: {
          A: 'Test string',
        },
        tags: ['Test string'],
        triggerTemplate: {
          branchName: 'Test string',
          commitSha: 'Test string',
          dir: 'Test string',
          invertRegex: true,
          projectId: 'Test string',
          repoName: 'Test string',
          substitutions: {
            A: 'Test string',
          },
          tagName: 'Test string',
        },
        webhookConfig: {
          secret: 'Test string',
          state: 'Test string',
        },
      }
    );
    /** Deletes a `BuildTrigger` by its project ID and trigger ID. */
    await gapi.client.cloudbuild.projects.triggers.delete({
      name: 'Test string',
      projectId: 'Test string',
      triggerId: 'Test string',
    });
    /** Returns information about a `BuildTrigger`. */
    await gapi.client.cloudbuild.projects.triggers.get({
      name: 'Test string',
      projectId: 'Test string',
      triggerId: 'Test string',
    });
    /** Lists existing `BuildTrigger`s. */
    await gapi.client.cloudbuild.projects.triggers.list({
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
      projectId: 'Test string',
    });
    /** Updates a `BuildTrigger` by its project ID and trigger ID. */
    await gapi.client.cloudbuild.projects.triggers.patch(
      {
        projectId: 'Test string',
        triggerId: 'Test string',
        updateMask: 'Test string',
      },
      {
        approvalConfig: {
          approvalRequired: true,
        },
        autodetect: true,
        bitbucketServerTriggerConfig: {
          bitbucketServerConfig: {
            apiKey: 'Test string',
            connectedRepositories: [
              {
                projectKey: 'Test string',
                repoSlug: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            hostUri: 'Test string',
            name: 'Test string',
            peeredNetwork: 'Test string',
            peeredNetworkIpRange: 'Test string',
            secrets: {
              adminAccessTokenVersionName: 'Test string',
              readAccessTokenVersionName: 'Test string',
              webhookSecretVersionName: 'Test string',
            },
            sslCa: 'Test string',
            username: 'Test string',
            webhookKey: 'Test string',
          },
          bitbucketServerConfigResource: 'Test string',
          projectKey: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repoSlug: 'Test string',
        },
        build: {
          approval: {
            config: {
              approvalRequired: true,
            },
            result: {
              approvalTime: 'Test string',
              approverAccount: 'Test string',
              comment: 'Test string',
              decision: 'Test string',
              url: 'Test string',
            },
            state: 'Test string',
          },
          artifacts: {
            images: ['Test string'],
            mavenArtifacts: [
              {
                artifactId: 'Test string',
                groupId: 'Test string',
                path: 'Test string',
                repository: 'Test string',
                version: 'Test string',
              },
            ],
            npmPackages: [
              {
                packagePath: 'Test string',
                repository: 'Test string',
              },
            ],
            objects: {
              location: 'Test string',
              paths: ['Test string'],
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
            },
            pythonPackages: [
              {
                paths: ['Test string'],
                repository: 'Test string',
              },
            ],
          },
          availableSecrets: {
            inline: [
              {
                envMap: {
                  A: 'Test string',
                },
                kmsKeyName: 'Test string',
              },
            ],
            secretManager: [
              {
                env: 'Test string',
                versionName: 'Test string',
              },
            ],
          },
          buildTriggerId: 'Test string',
          createTime: 'Test string',
          failureInfo: {
            detail: 'Test string',
            type: 'Test string',
          },
          finishTime: 'Test string',
          id: 'Test string',
          images: ['Test string'],
          logsBucket: 'Test string',
          logUrl: 'Test string',
          name: 'Test string',
          options: {
            automapSubstitutions: true,
            defaultLogsBucketBehavior: 'Test string',
            diskSizeGb: 'Test string',
            dynamicSubstitutions: true,
            env: ['Test string'],
            logging: 'Test string',
            logStreamingOption: 'Test string',
            machineType: 'Test string',
            pool: {
              name: 'Test string',
            },
            requestedVerifyOption: 'Test string',
            secretEnv: ['Test string'],
            sourceProvenanceHash: ['Test string'],
            substitutionOption: 'Test string',
            volumes: [
              {
                name: 'Test string',
                path: 'Test string',
              },
            ],
            workerPool: 'Test string',
          },
          projectId: 'Test string',
          queueTtl: 'Test string',
          results: {
            artifactManifest: 'Test string',
            artifactTiming: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
            buildStepImages: ['Test string'],
            buildStepOutputs: ['Test string'],
            images: [
              {
                digest: 'Test string',
                name: 'Test string',
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
              },
            ],
            mavenArtifacts: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            npmPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
            numArtifacts: 'Test string',
            pythonPackages: [
              {
                fileHashes: {
                  fileHash: [
                    {
                      type: 'Test string',
                      value: 'Test string',
                    },
                  ],
                },
                pushTiming: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                uri: 'Test string',
              },
            ],
          },
          secrets: [
            {
              kmsKeyName: 'Test string',
              secretEnv: {
                A: 'Test string',
              },
            },
          ],
          serviceAccount: 'Test string',
          source: {
            connectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            gitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            repoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            storageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            storageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          sourceProvenance: {
            fileHashes: {
              A: {
                fileHash: [
                  {
                    type: 'Test string',
                    value: 'Test string',
                  },
                ],
              },
            },
            resolvedConnectedRepository: {
              dir: 'Test string',
              repository: 'Test string',
              revision: 'Test string',
            },
            resolvedGitSource: {
              dir: 'Test string',
              revision: 'Test string',
              url: 'Test string',
            },
            resolvedRepoSource: {
              branchName: 'Test string',
              commitSha: 'Test string',
              dir: 'Test string',
              invertRegex: true,
              projectId: 'Test string',
              repoName: 'Test string',
              substitutions: {
                A: 'Test string',
              },
              tagName: 'Test string',
            },
            resolvedStorageSource: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
              sourceFetcher: 'Test string',
            },
            resolvedStorageSourceManifest: {
              bucket: 'Test string',
              generation: 'Test string',
              object: 'Test string',
            },
          },
          startTime: 'Test string',
          status: 'Test string',
          statusDetail: 'Test string',
          steps: [
            {
              allowExitCodes: [42],
              allowFailure: true,
              args: ['Test string'],
              automapSubstitutions: true,
              dir: 'Test string',
              entrypoint: 'Test string',
              env: ['Test string'],
              exitCode: 42,
              id: 'Test string',
              name: 'Test string',
              pullTiming: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              script: 'Test string',
              secretEnv: ['Test string'],
              status: 'Test string',
              timeout: 'Test string',
              timing: {
                endTime: 'Test string',
                startTime: 'Test string',
              },
              volumes: [
                {
                  name: 'Test string',
                  path: 'Test string',
                },
              ],
              waitFor: ['Test string'],
            },
          ],
          substitutions: {
            A: 'Test string',
          },
          tags: ['Test string'],
          timeout: 'Test string',
          timing: {
            A: {
              endTime: 'Test string',
              startTime: 'Test string',
            },
          },
          warnings: [
            {
              priority: 'Test string',
              text: 'Test string',
            },
          ],
        },
        createTime: 'Test string',
        description: 'Test string',
        disabled: true,
        eventType: 'Test string',
        filename: 'Test string',
        filter: 'Test string',
        gitFileSource: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          path: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          revision: 'Test string',
          uri: 'Test string',
        },
        github: {
          enterpriseConfigResourceName: 'Test string',
          installationId: 'Test string',
          name: 'Test string',
          owner: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        gitlabEnterpriseEventsConfig: {
          gitlabConfig: {
            connectedRepositories: [
              {
                id: 'Test string',
                webhookId: 42,
              },
            ],
            createTime: 'Test string',
            enterpriseConfig: {
              hostUri: 'Test string',
              serviceDirectoryConfig: {
                service: 'Test string',
              },
              sslCa: 'Test string',
            },
            name: 'Test string',
            secrets: {
              apiAccessTokenVersion: 'Test string',
              apiKeyVersion: 'Test string',
              readAccessTokenVersion: 'Test string',
              webhookSecretVersion: 'Test string',
            },
            username: 'Test string',
            webhookKey: 'Test string',
          },
          gitlabConfigResource: 'Test string',
          projectNamespace: 'Test string',
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
        },
        id: 'Test string',
        ignoredFiles: ['Test string'],
        includeBuildLogs: 'Test string',
        includedFiles: ['Test string'],
        name: 'Test string',
        pubsubConfig: {
          serviceAccountEmail: 'Test string',
          state: 'Test string',
          subscription: 'Test string',
          topic: 'Test string',
        },
        repositoryEventConfig: {
          pullRequest: {
            branch: 'Test string',
            commentControl: 'Test string',
            invertRegex: true,
          },
          push: {
            branch: 'Test string',
            invertRegex: true,
            tag: 'Test string',
          },
          repository: 'Test string',
          repositoryType: 'Test string',
        },
        resourceName: 'Test string',
        serviceAccount: 'Test string',
        sourceToBuild: {
          bitbucketServerConfig: 'Test string',
          githubEnterpriseConfig: 'Test string',
          ref: 'Test string',
          repository: 'Test string',
          repoType: 'Test string',
          uri: 'Test string',
        },
        substitutions: {
          A: 'Test string',
        },
        tags: ['Test string'],
        triggerTemplate: {
          branchName: 'Test string',
          commitSha: 'Test string',
          dir: 'Test string',
          invertRegex: true,
          projectId: 'Test string',
          repoName: 'Test string',
          substitutions: {
            A: 'Test string',
          },
          tagName: 'Test string',
        },
        webhookConfig: {
          secret: 'Test string',
          state: 'Test string',
        },
      }
    );
    /** Runs a `BuildTrigger` at a particular source revision. To run a regional or global trigger, use the POST request that includes the location endpoint in the path (ex. v1/projects/{projectId}/locations/{region}/triggers/{triggerId}:run). The POST request that does not include the location endpoint in the path can only be used when running global triggers. */
    await gapi.client.cloudbuild.projects.triggers.run(
      {
        name: 'Test string',
        projectId: 'Test string',
        triggerId: 'Test string',
      },
      {
        branchName: 'Test string',
        commitSha: 'Test string',
        dir: 'Test string',
        invertRegex: true,
        projectId: 'Test string',
        repoName: 'Test string',
        substitutions: {
          A: 'Test string',
        },
        tagName: 'Test string',
      }
    );
    /** ReceiveTriggerWebhook [Experimental] is called when the API receives a webhook request targeted at a specific trigger. */
    await gapi.client.cloudbuild.projects.triggers.webhook(
      {
        name: 'Test string',
        projectId: 'Test string',
        secret: 'Test string',
        trigger: 'Test string',
      },
      {
        contentType: 'Test string',
        data: 'Test string',
        extensions: [
          {
            A: 42,
          },
        ],
      }
    );
    /** ReceiveWebhook is called when the API receives a GitHub webhook. */
    await gapi.client.cloudbuild.v1.webhook(
      {
        webhookKey: 'Test string',
      },
      {
        contentType: 'Test string',
        data: 'Test string',
        extensions: [
          {
            A: 42,
          },
        ],
      }
    );
  }
});
