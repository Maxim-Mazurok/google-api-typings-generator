/* This is stub file for gapi.client.netapp-v1 definition tests */
// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator

// Revision: 20260125

gapi.load('client', async () => {
  /** now we can use gapi.client */

  await gapi.client.load(
    'https://netapp.googleapis.com/$discovery/rest?version=v1',
  );
  /** now we can use gapi.client.netapp */

  /** don't forget to authenticate your client before sending any request to resources: */
  /** declare client_id registered in Google Developers Console */
  const client_id = '<<PUT YOUR CLIENT ID HERE>>';
  const scope = [
    /** See, edit, configure, and delete your Google Cloud data and see the email address for your Google Account. */
    'https://www.googleapis.com/auth/cloud-platform',
  ];
  const immediate = false;
  gapi.auth.authorize({client_id, scope, immediate}, authResult => {
    if (authResult && !authResult.error) {
      /** handle successful authorization */
      void run();
    } else {
      /** handle authorization error */
    }
  });

  async function run() {
    /** Gets information about a location. */
    await gapi.client.netapp.projects.locations.get({
      name: 'Test string',
    });
    /** Lists information about the supported locations for this service. This method can be called in two ways: * **List all public locations:** Use the path `GET /v1/locations`. * **List project-visible locations:** Use the path `GET /v1/projects/{project_id}/locations`. This may include public locations as well as private or other locations specifically visible to the project. */
    await gapi.client.netapp.projects.locations.list({
      extraLocationTypes: 'Test string',
      filter: 'Test string',
      name: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** CreateActiveDirectory Creates the active directory specified in the request. */
    await gapi.client.netapp.projects.locations.activeDirectories.create(
      {
        activeDirectoryId: 'Test string',
        parent: 'Test string',
      },
      {
        administrators: ['Test string'],
        aesEncryption: true,
        backupOperators: ['Test string'],
        createTime: 'Test string',
        description: 'Test string',
        dns: 'Test string',
        domain: 'Test string',
        encryptDcConnections: true,
        kdcHostname: 'Test string',
        kdcIp: 'Test string',
        labels: {
          A: 'Test string',
        },
        ldapSigning: true,
        name: 'Test string',
        netBiosPrefix: 'Test string',
        nfsUsersWithLdap: true,
        organizationalUnit: 'Test string',
        password: 'Test string',
        securityOperators: ['Test string'],
        site: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        username: 'Test string',
      },
    );
    /** Delete the active directory specified in the request. */
    await gapi.client.netapp.projects.locations.activeDirectories.delete({
      name: 'Test string',
    });
    /** Describes a specified active directory. */
    await gapi.client.netapp.projects.locations.activeDirectories.get({
      name: 'Test string',
    });
    /** Lists active directories. */
    await gapi.client.netapp.projects.locations.activeDirectories.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Update the parameters of an active directories. */
    await gapi.client.netapp.projects.locations.activeDirectories.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        administrators: ['Test string'],
        aesEncryption: true,
        backupOperators: ['Test string'],
        createTime: 'Test string',
        description: 'Test string',
        dns: 'Test string',
        domain: 'Test string',
        encryptDcConnections: true,
        kdcHostname: 'Test string',
        kdcIp: 'Test string',
        labels: {
          A: 'Test string',
        },
        ldapSigning: true,
        name: 'Test string',
        netBiosPrefix: 'Test string',
        nfsUsersWithLdap: true,
        organizationalUnit: 'Test string',
        password: 'Test string',
        securityOperators: ['Test string'],
        site: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        username: 'Test string',
      },
    );
    /** Creates new backup policy */
    await gapi.client.netapp.projects.locations.backupPolicies.create(
      {
        backupPolicyId: 'Test string',
        parent: 'Test string',
      },
      {
        assignedVolumeCount: 42,
        createTime: 'Test string',
        dailyBackupLimit: 42,
        description: 'Test string',
        enabled: true,
        labels: {
          A: 'Test string',
        },
        monthlyBackupLimit: 42,
        name: 'Test string',
        state: 'Test string',
        weeklyBackupLimit: 42,
      },
    );
    /** Warning! This operation will permanently delete the backup policy. */
    await gapi.client.netapp.projects.locations.backupPolicies.delete({
      name: 'Test string',
    });
    /** Returns the description of the specified backup policy by backup_policy_id. */
    await gapi.client.netapp.projects.locations.backupPolicies.get({
      name: 'Test string',
    });
    /** Returns list of all available backup policies. */
    await gapi.client.netapp.projects.locations.backupPolicies.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates settings of a specific backup policy. */
    await gapi.client.netapp.projects.locations.backupPolicies.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        assignedVolumeCount: 42,
        createTime: 'Test string',
        dailyBackupLimit: 42,
        description: 'Test string',
        enabled: true,
        labels: {
          A: 'Test string',
        },
        monthlyBackupLimit: 42,
        name: 'Test string',
        state: 'Test string',
        weeklyBackupLimit: 42,
      },
    );
    /** Creates new backup vault */
    await gapi.client.netapp.projects.locations.backupVaults.create(
      {
        backupVaultId: 'Test string',
        parent: 'Test string',
      },
      {
        backupRegion: 'Test string',
        backupRetentionPolicy: {
          backupMinimumEnforcedRetentionDays: 42,
          dailyBackupImmutable: true,
          manualBackupImmutable: true,
          monthlyBackupImmutable: true,
          weeklyBackupImmutable: true,
        },
        backupsCryptoKeyVersion: 'Test string',
        backupVaultType: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        destinationBackupVault: 'Test string',
        encryptionState: 'Test string',
        kmsConfig: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        sourceBackupVault: 'Test string',
        sourceRegion: 'Test string',
        state: 'Test string',
      },
    );
    /** Warning! This operation will permanently delete the backup vault. */
    await gapi.client.netapp.projects.locations.backupVaults.delete({
      name: 'Test string',
    });
    /** Returns the description of the specified backup vault */
    await gapi.client.netapp.projects.locations.backupVaults.get({
      name: 'Test string',
    });
    /** Returns list of all available backup vaults. */
    await gapi.client.netapp.projects.locations.backupVaults.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates the settings of a specific backup vault. */
    await gapi.client.netapp.projects.locations.backupVaults.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        backupRegion: 'Test string',
        backupRetentionPolicy: {
          backupMinimumEnforcedRetentionDays: 42,
          dailyBackupImmutable: true,
          manualBackupImmutable: true,
          monthlyBackupImmutable: true,
          weeklyBackupImmutable: true,
        },
        backupsCryptoKeyVersion: 'Test string',
        backupVaultType: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        destinationBackupVault: 'Test string',
        encryptionState: 'Test string',
        kmsConfig: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        sourceBackupVault: 'Test string',
        sourceRegion: 'Test string',
        state: 'Test string',
      },
    );
    /** Creates a backup from the volume specified in the request The backup can be created from the given snapshot if specified in the request. If no snapshot specified, there'll be a new snapshot taken to initiate the backup creation. */
    await gapi.client.netapp.projects.locations.backupVaults.backups.create(
      {
        backupId: 'Test string',
        parent: 'Test string',
      },
      {
        backupRegion: 'Test string',
        backupType: 'Test string',
        chainStorageBytes: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        enforcedRetentionEndTime: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        satisfiesPzi: true,
        satisfiesPzs: true,
        sourceSnapshot: 'Test string',
        sourceVolume: 'Test string',
        state: 'Test string',
        volumeRegion: 'Test string',
        volumeUsageBytes: 'Test string',
      },
    );
    /** Warning! This operation will permanently delete the backup. */
    await gapi.client.netapp.projects.locations.backupVaults.backups.delete({
      name: 'Test string',
    });
    /** Returns the description of the specified backup */
    await gapi.client.netapp.projects.locations.backupVaults.backups.get({
      name: 'Test string',
    });
    /** Returns descriptions of all backups for a backupVault. */
    await gapi.client.netapp.projects.locations.backupVaults.backups.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Update backup with full spec. */
    await gapi.client.netapp.projects.locations.backupVaults.backups.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        backupRegion: 'Test string',
        backupType: 'Test string',
        chainStorageBytes: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        enforcedRetentionEndTime: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        satisfiesPzi: true,
        satisfiesPzs: true,
        sourceSnapshot: 'Test string',
        sourceVolume: 'Test string',
        state: 'Test string',
        volumeRegion: 'Test string',
        volumeUsageBytes: 'Test string',
      },
    );
    /** Creates a new host group. */
    await gapi.client.netapp.projects.locations.hostGroups.create(
      {
        hostGroupId: 'Test string',
        parent: 'Test string',
      },
      {
        createTime: 'Test string',
        description: 'Test string',
        hosts: ['Test string'],
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        osType: 'Test string',
        state: 'Test string',
        type: 'Test string',
      },
    );
    /** Deletes a host group. */
    await gapi.client.netapp.projects.locations.hostGroups.delete({
      name: 'Test string',
    });
    /** Returns details of the specified host group. */
    await gapi.client.netapp.projects.locations.hostGroups.get({
      name: 'Test string',
    });
    /** Returns a list of host groups in a `location`. Use `-` as location to list host groups across all locations. */
    await gapi.client.netapp.projects.locations.hostGroups.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates an existing host group. */
    await gapi.client.netapp.projects.locations.hostGroups.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        createTime: 'Test string',
        description: 'Test string',
        hosts: ['Test string'],
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        osType: 'Test string',
        state: 'Test string',
        type: 'Test string',
      },
    );
    /** Creates a new KMS config. */
    await gapi.client.netapp.projects.locations.kmsConfigs.create(
      {
        kmsConfigId: 'Test string',
        parent: 'Test string',
      },
      {
        createTime: 'Test string',
        cryptoKeyName: 'Test string',
        description: 'Test string',
        instructions: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        serviceAccount: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
      },
    );
    /** Warning! This operation will permanently delete the Kms config. */
    await gapi.client.netapp.projects.locations.kmsConfigs.delete({
      name: 'Test string',
    });
    /** Encrypt the existing volumes without CMEK encryption with the desired the KMS config for the whole region. */
    await gapi.client.netapp.projects.locations.kmsConfigs.encrypt(
      {
        name: 'Test string',
      },
      {},
    );
    /** Returns the description of the specified KMS config by kms_config_id. */
    await gapi.client.netapp.projects.locations.kmsConfigs.get({
      name: 'Test string',
    });
    /** Returns descriptions of all KMS configs owned by the caller. */
    await gapi.client.netapp.projects.locations.kmsConfigs.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates the Kms config properties with the full spec */
    await gapi.client.netapp.projects.locations.kmsConfigs.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        createTime: 'Test string',
        cryptoKeyName: 'Test string',
        description: 'Test string',
        instructions: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        serviceAccount: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
      },
    );
    /** Verifies KMS config reachability. */
    await gapi.client.netapp.projects.locations.kmsConfigs.verify(
      {
        name: 'Test string',
      },
      {},
    );
    /** Starts asynchronous cancellation on a long-running operation. The server makes a best effort to cancel the operation, but success is not guaranteed. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. Clients can use Operations.GetOperation or other methods to check whether the cancellation succeeded or whether the operation completed despite cancellation. On successful cancellation, the operation is not deleted; instead, it becomes an operation with an Operation.error value with a google.rpc.Status.code of `1`, corresponding to `Code.CANCELLED`. */
    await gapi.client.netapp.projects.locations.operations.cancel(
      {
        name: 'Test string',
      },
      {},
    );
    /** Deletes a long-running operation. This method indicates that the client is no longer interested in the operation result. It does not cancel the operation. If the server doesn't support this method, it returns `google.rpc.Code.UNIMPLEMENTED`. */
    await gapi.client.netapp.projects.locations.operations.delete({
      name: 'Test string',
    });
    /** Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service. */
    await gapi.client.netapp.projects.locations.operations.get({
      name: 'Test string',
    });
    /** Lists operations that match the specified filter in the request. If the server doesn't support this method, it returns `UNIMPLEMENTED`. */
    await gapi.client.netapp.projects.locations.operations.list({
      filter: 'Test string',
      name: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      returnPartialSuccess: true,
    });
    /** Creates a new storage pool. */
    await gapi.client.netapp.projects.locations.storagePools.create(
      {
        parent: 'Test string',
        storagePoolId: 'Test string',
      },
      {
        activeDirectory: 'Test string',
        allowAutoTiering: true,
        availableThroughputMibps: 42,
        capacityGib: 'Test string',
        coldTierSizeUsedGib: 'Test string',
        createTime: 'Test string',
        customPerformanceEnabled: true,
        description: 'Test string',
        enableHotTierAutoResize: true,
        encryptionType: 'Test string',
        globalAccessAllowed: true,
        hotTierSizeGib: 'Test string',
        hotTierSizeUsedGib: 'Test string',
        kmsConfig: 'Test string',
        labels: {
          A: 'Test string',
        },
        ldapEnabled: true,
        name: 'Test string',
        network: 'Test string',
        psaRange: 'Test string',
        qosType: 'Test string',
        replicaZone: 'Test string',
        satisfiesPzi: true,
        satisfiesPzs: true,
        serviceLevel: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        totalIops: 'Test string',
        totalThroughputMibps: 'Test string',
        type: 'Test string',
        volumeCapacityGib: 'Test string',
        volumeCount: 42,
        zone: 'Test string',
      },
    );
    /** Warning! This operation will permanently delete the storage pool. */
    await gapi.client.netapp.projects.locations.storagePools.delete({
      name: 'Test string',
    });
    /** Returns the description of the specified storage pool by poolId. */
    await gapi.client.netapp.projects.locations.storagePools.get({
      name: 'Test string',
    });
    /** Returns descriptions of all storage pools owned by the caller. */
    await gapi.client.netapp.projects.locations.storagePools.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates the storage pool properties with the full spec */
    await gapi.client.netapp.projects.locations.storagePools.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        activeDirectory: 'Test string',
        allowAutoTiering: true,
        availableThroughputMibps: 42,
        capacityGib: 'Test string',
        coldTierSizeUsedGib: 'Test string',
        createTime: 'Test string',
        customPerformanceEnabled: true,
        description: 'Test string',
        enableHotTierAutoResize: true,
        encryptionType: 'Test string',
        globalAccessAllowed: true,
        hotTierSizeGib: 'Test string',
        hotTierSizeUsedGib: 'Test string',
        kmsConfig: 'Test string',
        labels: {
          A: 'Test string',
        },
        ldapEnabled: true,
        name: 'Test string',
        network: 'Test string',
        psaRange: 'Test string',
        qosType: 'Test string',
        replicaZone: 'Test string',
        satisfiesPzi: true,
        satisfiesPzs: true,
        serviceLevel: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        totalIops: 'Test string',
        totalThroughputMibps: 'Test string',
        type: 'Test string',
        volumeCapacityGib: 'Test string',
        volumeCount: 42,
        zone: 'Test string',
      },
    );
    /** This operation will switch the active/replica zone for a regional storagePool. */
    await gapi.client.netapp.projects.locations.storagePools.switch(
      {
        name: 'Test string',
      },
      {},
    );
    /** ValidateDirectoryService does a connectivity check for a directory service policy attached to the storage pool. */
    await gapi.client.netapp.projects.locations.storagePools.validateDirectoryService(
      {
        name: 'Test string',
      },
      {
        directoryServiceType: 'Test string',
      },
    );
    /** Creates a new Volume in a given project and location. */
    await gapi.client.netapp.projects.locations.volumes.create(
      {
        parent: 'Test string',
        volumeId: 'Test string',
      },
      {
        activeDirectory: 'Test string',
        backupConfig: {
          backupChainBytes: 'Test string',
          backupPolicies: ['Test string'],
          backupVault: 'Test string',
          scheduledBackupEnabled: true,
        },
        blockDevices: [
          {
            hostGroups: ['Test string'],
            identifier: 'Test string',
            name: 'Test string',
            osType: 'Test string',
            sizeGib: 'Test string',
          },
        ],
        cacheParameters: {
          cacheConfig: {
            cachePrePopulate: {
              excludePathList: ['Test string'],
              pathList: ['Test string'],
              recursion: true,
            },
            cachePrePopulateState: 'Test string',
            cifsChangeNotifyEnabled: true,
            writebackEnabled: true,
          },
          cacheState: 'Test string',
          command: 'Test string',
          enableGlobalFileLock: true,
          passphrase: 'Test string',
          peerClusterName: 'Test string',
          peeringCommandExpiryTime: 'Test string',
          peerIpAddresses: ['Test string'],
          peerSvmName: 'Test string',
          peerVolumeName: 'Test string',
          stateDetails: 'Test string',
        },
        capacityGib: 'Test string',
        coldTierSizeGib: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        encryptionType: 'Test string',
        exportPolicy: {
          rules: [
            {
              accessType: 'Test string',
              allowedClients: 'Test string',
              anonUid: 'Test string',
              hasRootAccess: 'Test string',
              kerberos5iReadOnly: true,
              kerberos5iReadWrite: true,
              kerberos5pReadOnly: true,
              kerberos5pReadWrite: true,
              kerberos5ReadOnly: true,
              kerberos5ReadWrite: true,
              nfsv3: true,
              nfsv4: true,
              squashMode: 'Test string',
            },
          ],
        },
        hasReplication: true,
        hotTierSizeUsedGib: 'Test string',
        hybridReplicationParameters: {
          clusterLocation: 'Test string',
          description: 'Test string',
          hybridReplicationType: 'Test string',
          labels: {
            A: 'Test string',
          },
          largeVolumeConstituentCount: 42,
          peerClusterName: 'Test string',
          peerIpAddresses: ['Test string'],
          peerSvmName: 'Test string',
          peerVolumeName: 'Test string',
          replication: 'Test string',
          replicationSchedule: 'Test string',
        },
        kerberosEnabled: true,
        kmsConfig: 'Test string',
        labels: {
          A: 'Test string',
        },
        largeCapacity: true,
        ldapEnabled: true,
        mountOptions: [
          {
            export: 'Test string',
            exportFull: 'Test string',
            instructions: 'Test string',
            ipAddress: 'Test string',
            protocol: 'Test string',
          },
        ],
        multipleEndpoints: true,
        name: 'Test string',
        network: 'Test string',
        protocols: ['Test string'],
        psaRange: 'Test string',
        replicaZone: 'Test string',
        restoreParameters: {
          sourceBackup: 'Test string',
          sourceSnapshot: 'Test string',
        },
        restrictedActions: ['Test string'],
        securityStyle: 'Test string',
        serviceLevel: 'Test string',
        shareName: 'Test string',
        smbSettings: ['Test string'],
        snapReserve: 42,
        snapshotDirectory: true,
        snapshotPolicy: {
          dailySchedule: {
            hour: 42,
            minute: 42,
            snapshotsToKeep: 42,
          },
          enabled: true,
          hourlySchedule: {
            minute: 42,
            snapshotsToKeep: 42,
          },
          monthlySchedule: {
            daysOfMonth: 'Test string',
            hour: 42,
            minute: 42,
            snapshotsToKeep: 42,
          },
          weeklySchedule: {
            day: 'Test string',
            hour: 42,
            minute: 42,
            snapshotsToKeep: 42,
          },
        },
        state: 'Test string',
        stateDetails: 'Test string',
        storagePool: 'Test string',
        throughputMibps: 42,
        tieringPolicy: {
          coolingThresholdDays: 42,
          hotTierBypassModeEnabled: true,
          tierAction: 'Test string',
        },
        unixPermissions: 'Test string',
        usedGib: 'Test string',
        zone: 'Test string',
      },
    );
    /** Deletes a single Volume. */
    await gapi.client.netapp.projects.locations.volumes.delete({
      force: true,
      name: 'Test string',
    });
    /** Establish volume peering. This is used to establish cluster and svm peerings between the GCNV and OnPrem clusters. */
    await gapi.client.netapp.projects.locations.volumes.establishPeering(
      {
        name: 'Test string',
      },
      {
        peerClusterName: 'Test string',
        peerIpAddresses: ['Test string'],
        peerSvmName: 'Test string',
        peerVolumeName: 'Test string',
      },
    );
    /** Gets details of a single Volume. */
    await gapi.client.netapp.projects.locations.volumes.get({
      name: 'Test string',
    });
    /** Lists Volumes in a given project. */
    await gapi.client.netapp.projects.locations.volumes.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates the parameters of a single Volume. */
    await gapi.client.netapp.projects.locations.volumes.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        activeDirectory: 'Test string',
        backupConfig: {
          backupChainBytes: 'Test string',
          backupPolicies: ['Test string'],
          backupVault: 'Test string',
          scheduledBackupEnabled: true,
        },
        blockDevices: [
          {
            hostGroups: ['Test string'],
            identifier: 'Test string',
            name: 'Test string',
            osType: 'Test string',
            sizeGib: 'Test string',
          },
        ],
        cacheParameters: {
          cacheConfig: {
            cachePrePopulate: {
              excludePathList: ['Test string'],
              pathList: ['Test string'],
              recursion: true,
            },
            cachePrePopulateState: 'Test string',
            cifsChangeNotifyEnabled: true,
            writebackEnabled: true,
          },
          cacheState: 'Test string',
          command: 'Test string',
          enableGlobalFileLock: true,
          passphrase: 'Test string',
          peerClusterName: 'Test string',
          peeringCommandExpiryTime: 'Test string',
          peerIpAddresses: ['Test string'],
          peerSvmName: 'Test string',
          peerVolumeName: 'Test string',
          stateDetails: 'Test string',
        },
        capacityGib: 'Test string',
        coldTierSizeGib: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        encryptionType: 'Test string',
        exportPolicy: {
          rules: [
            {
              accessType: 'Test string',
              allowedClients: 'Test string',
              anonUid: 'Test string',
              hasRootAccess: 'Test string',
              kerberos5iReadOnly: true,
              kerberos5iReadWrite: true,
              kerberos5pReadOnly: true,
              kerberos5pReadWrite: true,
              kerberos5ReadOnly: true,
              kerberos5ReadWrite: true,
              nfsv3: true,
              nfsv4: true,
              squashMode: 'Test string',
            },
          ],
        },
        hasReplication: true,
        hotTierSizeUsedGib: 'Test string',
        hybridReplicationParameters: {
          clusterLocation: 'Test string',
          description: 'Test string',
          hybridReplicationType: 'Test string',
          labels: {
            A: 'Test string',
          },
          largeVolumeConstituentCount: 42,
          peerClusterName: 'Test string',
          peerIpAddresses: ['Test string'],
          peerSvmName: 'Test string',
          peerVolumeName: 'Test string',
          replication: 'Test string',
          replicationSchedule: 'Test string',
        },
        kerberosEnabled: true,
        kmsConfig: 'Test string',
        labels: {
          A: 'Test string',
        },
        largeCapacity: true,
        ldapEnabled: true,
        mountOptions: [
          {
            export: 'Test string',
            exportFull: 'Test string',
            instructions: 'Test string',
            ipAddress: 'Test string',
            protocol: 'Test string',
          },
        ],
        multipleEndpoints: true,
        name: 'Test string',
        network: 'Test string',
        protocols: ['Test string'],
        psaRange: 'Test string',
        replicaZone: 'Test string',
        restoreParameters: {
          sourceBackup: 'Test string',
          sourceSnapshot: 'Test string',
        },
        restrictedActions: ['Test string'],
        securityStyle: 'Test string',
        serviceLevel: 'Test string',
        shareName: 'Test string',
        smbSettings: ['Test string'],
        snapReserve: 42,
        snapshotDirectory: true,
        snapshotPolicy: {
          dailySchedule: {
            hour: 42,
            minute: 42,
            snapshotsToKeep: 42,
          },
          enabled: true,
          hourlySchedule: {
            minute: 42,
            snapshotsToKeep: 42,
          },
          monthlySchedule: {
            daysOfMonth: 'Test string',
            hour: 42,
            minute: 42,
            snapshotsToKeep: 42,
          },
          weeklySchedule: {
            day: 'Test string',
            hour: 42,
            minute: 42,
            snapshotsToKeep: 42,
          },
        },
        state: 'Test string',
        stateDetails: 'Test string',
        storagePool: 'Test string',
        throughputMibps: 42,
        tieringPolicy: {
          coolingThresholdDays: 42,
          hotTierBypassModeEnabled: true,
          tierAction: 'Test string',
        },
        unixPermissions: 'Test string',
        usedGib: 'Test string',
        zone: 'Test string',
      },
    );
    /** Restore files from a backup to a volume. */
    await gapi.client.netapp.projects.locations.volumes.restore(
      {
        name: 'Test string',
      },
      {
        backup: 'Test string',
        fileList: ['Test string'],
        restoreDestinationPath: 'Test string',
      },
    );
    /** Revert an existing volume to a specified snapshot. Warning! This operation will permanently revert all changes made after the snapshot was created. */
    await gapi.client.netapp.projects.locations.volumes.revert(
      {
        name: 'Test string',
      },
      {
        snapshotId: 'Test string',
      },
    );
    /** Creates a new quota rule. */
    await gapi.client.netapp.projects.locations.volumes.quotaRules.create(
      {
        parent: 'Test string',
        quotaRuleId: 'Test string',
      },
      {
        createTime: 'Test string',
        description: 'Test string',
        diskLimitMib: 42,
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        target: 'Test string',
        type: 'Test string',
      },
    );
    /** Deletes a quota rule. */
    await gapi.client.netapp.projects.locations.volumes.quotaRules.delete({
      name: 'Test string',
    });
    /** Returns details of the specified quota rule. */
    await gapi.client.netapp.projects.locations.volumes.quotaRules.get({
      name: 'Test string',
    });
    /** Returns list of all quota rules in a location. */
    await gapi.client.netapp.projects.locations.volumes.quotaRules.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates a quota rule. */
    await gapi.client.netapp.projects.locations.volumes.quotaRules.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        createTime: 'Test string',
        description: 'Test string',
        diskLimitMib: 42,
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        target: 'Test string',
        type: 'Test string',
      },
    );
    /** Create a new replication for a volume. */
    await gapi.client.netapp.projects.locations.volumes.replications.create(
      {
        parent: 'Test string',
        replicationId: 'Test string',
      },
      {
        clusterLocation: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        destinationVolume: 'Test string',
        destinationVolumeParameters: {
          description: 'Test string',
          shareName: 'Test string',
          storagePool: 'Test string',
          tieringPolicy: {
            coolingThresholdDays: 42,
            hotTierBypassModeEnabled: true,
            tierAction: 'Test string',
          },
          volumeId: 'Test string',
        },
        healthy: true,
        hybridPeeringDetails: {
          command: 'Test string',
          commandExpiryTime: 'Test string',
          passphrase: 'Test string',
          peerClusterName: 'Test string',
          peerSvmName: 'Test string',
          peerVolumeName: 'Test string',
          subnetIp: 'Test string',
        },
        hybridReplicationType: 'Test string',
        hybridReplicationUserCommands: {
          commands: ['Test string'],
        },
        labels: {
          A: 'Test string',
        },
        mirrorState: 'Test string',
        name: 'Test string',
        replicationSchedule: 'Test string',
        role: 'Test string',
        sourceVolume: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        transferStats: {
          lagDuration: 'Test string',
          lastTransferBytes: 'Test string',
          lastTransferDuration: 'Test string',
          lastTransferEndTime: 'Test string',
          lastTransferError: 'Test string',
          totalTransferDuration: 'Test string',
          transferBytes: 'Test string',
          updateTime: 'Test string',
        },
      },
    );
    /** Deletes a replication. */
    await gapi.client.netapp.projects.locations.volumes.replications.delete({
      name: 'Test string',
    });
    /** Establish replication peering. */
    await gapi.client.netapp.projects.locations.volumes.replications.establishPeering(
      {
        name: 'Test string',
      },
      {
        peerClusterName: 'Test string',
        peerIpAddresses: ['Test string'],
        peerSvmName: 'Test string',
        peerVolumeName: 'Test string',
      },
    );
    /** Describe a replication for a volume. */
    await gapi.client.netapp.projects.locations.volumes.replications.get({
      name: 'Test string',
    });
    /** Returns descriptions of all replications for a volume. */
    await gapi.client.netapp.projects.locations.volumes.replications.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates the settings of a specific replication. */
    await gapi.client.netapp.projects.locations.volumes.replications.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        clusterLocation: 'Test string',
        createTime: 'Test string',
        description: 'Test string',
        destinationVolume: 'Test string',
        destinationVolumeParameters: {
          description: 'Test string',
          shareName: 'Test string',
          storagePool: 'Test string',
          tieringPolicy: {
            coolingThresholdDays: 42,
            hotTierBypassModeEnabled: true,
            tierAction: 'Test string',
          },
          volumeId: 'Test string',
        },
        healthy: true,
        hybridPeeringDetails: {
          command: 'Test string',
          commandExpiryTime: 'Test string',
          passphrase: 'Test string',
          peerClusterName: 'Test string',
          peerSvmName: 'Test string',
          peerVolumeName: 'Test string',
          subnetIp: 'Test string',
        },
        hybridReplicationType: 'Test string',
        hybridReplicationUserCommands: {
          commands: ['Test string'],
        },
        labels: {
          A: 'Test string',
        },
        mirrorState: 'Test string',
        name: 'Test string',
        replicationSchedule: 'Test string',
        role: 'Test string',
        sourceVolume: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        transferStats: {
          lagDuration: 'Test string',
          lastTransferBytes: 'Test string',
          lastTransferDuration: 'Test string',
          lastTransferEndTime: 'Test string',
          lastTransferError: 'Test string',
          totalTransferDuration: 'Test string',
          transferBytes: 'Test string',
          updateTime: 'Test string',
        },
      },
    );
    /** Resume Cross Region Replication. */
    await gapi.client.netapp.projects.locations.volumes.replications.resume(
      {
        name: 'Test string',
      },
      {},
    );
    /** Reverses direction of replication. Source becomes destination and destination becomes source. */
    await gapi.client.netapp.projects.locations.volumes.replications.reverseDirection(
      {
        name: 'Test string',
      },
      {},
    );
    /** Stop Cross Region Replication. */
    await gapi.client.netapp.projects.locations.volumes.replications.stop(
      {
        name: 'Test string',
      },
      {
        force: true,
      },
    );
    /** Syncs the replication. This will invoke one time volume data transfer from source to destination. */
    await gapi.client.netapp.projects.locations.volumes.replications.sync(
      {
        name: 'Test string',
      },
      {},
    );
    /** Create a new snapshot for a volume. */
    await gapi.client.netapp.projects.locations.volumes.snapshots.create(
      {
        parent: 'Test string',
        snapshotId: 'Test string',
      },
      {
        createTime: 'Test string',
        description: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        usedBytes: 42,
      },
    );
    /** Deletes a snapshot. */
    await gapi.client.netapp.projects.locations.volumes.snapshots.delete({
      name: 'Test string',
    });
    /** Describe a snapshot for a volume. */
    await gapi.client.netapp.projects.locations.volumes.snapshots.get({
      name: 'Test string',
    });
    /** Returns descriptions of all snapshots for a volume. */
    await gapi.client.netapp.projects.locations.volumes.snapshots.list({
      filter: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates the settings of a specific snapshot. */
    await gapi.client.netapp.projects.locations.volumes.snapshots.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        createTime: 'Test string',
        description: 'Test string',
        labels: {
          A: 'Test string',
        },
        name: 'Test string',
        state: 'Test string',
        stateDetails: 'Test string',
        usedBytes: 42,
      },
    );
  }
});
