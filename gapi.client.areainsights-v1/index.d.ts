/* Type definitions for non-npm package Places Aggregate API v1 0.0 */
// Project: https://developers.google.com/maps/documentation/places-aggregate/overview
// Definitions by: Maxim Mazurok <https://github.com/Maxim-Mazurok>
//                 Nick Amoscato <https://github.com/namoscato>
//                 Declan Vong <https://github.com/declanvong>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator
// Generated from: https://areainsights.googleapis.com/$discovery/rest?version=v1
// Revision: 20260208

/// <reference types="gapi.client" />

declare namespace gapi.client {
  /** Load Places Aggregate API v1 */
  function load(
    urlOrObject: 'https://areainsights.googleapis.com/$discovery/rest?version=v1',
  ): Promise<void>;
  /** @deprecated Please load APIs with discovery documents. */
  function load(name: 'areainsights', version: 'v1'): Promise<void>;
  /** @deprecated Please load APIs with discovery documents. */
  function load(name: 'areainsights', version: 'v1', callback: () => any): void;

  namespace areainsights {
    interface Circle {
      /** The latitude and longitude of the center of the circle. */
      latLng?: LatLng;
      /** **Format:** Must be in the format `places/PLACE_ID`, where `PLACE_ID` is the unique identifier of a place. For example: `places/ChIJgUbEo8cfqokR5lP9_Wh_DaM`. */
      place?: string;
      /** Optional. The radius of the circle in meters */
      radius?: number;
    }
    interface ComputeInsightsRequest {
      /** Required. Insight filter. */
      filter?: Filter;
      /** Required. Insights to compute. Currently only INSIGHT_COUNT and INSIGHT_PLACES are supported. */
      insights?: string[];
    }
    interface ComputeInsightsResponse {
      /** Result for Insights.INSIGHT_COUNT. */
      count?: string;
      /** Result for Insights.INSIGHT_PLACES. */
      placeInsights?: PlaceInsight[];
    }
    interface CustomArea {
      /** Required. The custom area represented as a polygon */
      polygon?: Polygon;
    }
    interface Filter {
      /** Required. Restricts results to places which are located in the area specified by location filters. */
      locationFilter?: LocationFilter;
      /** Optional. Restricts results to places whose operating status is included on this list. If operating_status is not set, OPERATING_STATUS_OPERATIONAL is used as default. */
      operatingStatus?: string[];
      /** Optional. Restricts results to places whose price level is included on this list. If `price_levels` is not set, all price levels are included in the results. */
      priceLevels?: string[];
      /** Optional. Restricts results to places whose average user ratings are in the range specified by rating_filter. If rating_filter is not set, all ratings are included in the result. */
      ratingFilter?: RatingFilter;
      /** Required. Place type filters. */
      typeFilter?: TypeFilter;
    }
    interface LatLng {
      /** The latitude in degrees. It must be in the range [-90.0, +90.0]. */
      latitude?: number;
      /** The longitude in degrees. It must be in the range [-180.0, +180.0]. */
      longitude?: number;
    }
    interface LocationFilter {
      /** Area as a circle. */
      circle?: Circle;
      /** Custom area specified by a polygon. */
      customArea?: CustomArea;
      /** Area as region. */
      region?: Region;
    }
    interface PlaceInsight {
      /** The unique identifier of the place. This resource name can be used to retrieve details about the place using the [Places API](https://developers.google.com/maps/documentation/places/web-service/reference/rest/v1/places/get). */
      place?: string;
    }
    interface Polygon {
      /** Optional. The coordinates that define the polygon. */
      coordinates?: LatLng[];
    }
    interface RatingFilter {
      /** Optional. Restricts results to places whose average user rating is strictly less than or equal to max_rating. Values must be between 1.0 and 5.0. */
      maxRating?: number;
      /** Optional. Restricts results to places whose average user rating is greater than or equal to min_rating. Values must be between 1.0 and 5.0. */
      minRating?: number;
    }
    interface Region {
      /** The [place ID](https://developers.google.com/maps/documentation/places/web-service/place-id) of the geographic region. Not all region types are supported; see documentation for details. **Format:** Must be in the format `places/PLACE_ID`, where `PLACE_ID` is the unique identifier of a place. For example: `places/ChIJPV4oX_65j4ARVW8IJ6IJUYs`. */
      place?: string;
    }
    interface TypeFilter {
      /** Optional. Excluded primary Place types. */
      excludedPrimaryTypes?: string[];
      /** Optional. Excluded Place types. */
      excludedTypes?: string[];
      /** Optional. Included primary Place types. */
      includedPrimaryTypes?: string[];
      /** Optional. Included Place types. */
      includedTypes?: string[];
    }
    interface V1Resource {
      /** This method lets you retrieve insights about areas using a variety of filter such as: area, place type, operating status, price level and ratings. Currently "count" and "places" insights are supported. With "count" insights you can answer questions such as "How many restaurant are located in California that are operational, are inexpensive and have an average rating of at least 4 stars" (see `insight` enum for more details). With "places" insights, you can determine which places match the requested filter. Clients can then use those place resource names to fetch more details about each individual place using the Places API. */
      computeInsights(request: {
        /** V1 error format. */
        '$.xgafv'?: string;
        /** OAuth access token. */
        access_token?: string;
        /** Data format for response. */
        alt?: string;
        /** JSONP */
        callback?: string;
        /** Selector specifying which fields to include in a partial response. */
        fields?: string;
        /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
        key?: string;
        /** OAuth 2.0 token for the current user. */
        oauth_token?: string;
        /** Returns response with indentations and line breaks. */
        prettyPrint?: boolean;
        /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
        quotaUser?: string;
        /** Upload protocol for media (e.g. "raw", "multipart"). */
        upload_protocol?: string;
        /** Legacy upload protocol for media (e.g. "media", "multipart"). */
        uploadType?: string;
        /** Request body */
        resource: ComputeInsightsRequest;
      }): Request<ComputeInsightsResponse>;
      computeInsights(
        request: {
          /** V1 error format. */
          '$.xgafv'?: string;
          /** OAuth access token. */
          access_token?: string;
          /** Data format for response. */
          alt?: string;
          /** JSONP */
          callback?: string;
          /** Selector specifying which fields to include in a partial response. */
          fields?: string;
          /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
          key?: string;
          /** OAuth 2.0 token for the current user. */
          oauth_token?: string;
          /** Returns response with indentations and line breaks. */
          prettyPrint?: boolean;
          /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
          quotaUser?: string;
          /** Upload protocol for media (e.g. "raw", "multipart"). */
          upload_protocol?: string;
          /** Legacy upload protocol for media (e.g. "media", "multipart"). */
          uploadType?: string;
        },
        body: ComputeInsightsRequest,
      ): Request<ComputeInsightsResponse>;
    }

    const v1: V1Resource;
  }
}
