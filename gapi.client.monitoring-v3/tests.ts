/* This is stub file for gapi.client.monitoring-v3 definition tests */
// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator

// Revision: 20240526

gapi.load('client', async () => {
  /** now we can use gapi.client */

  await gapi.client.load(
    'https://monitoring.googleapis.com/$discovery/rest?version=v3'
  );
  /** now we can use gapi.client.monitoring */

  /** don't forget to authenticate your client before sending any request to resources: */
  /** declare client_id registered in Google Developers Console */
  const client_id = '<<PUT YOUR CLIENT ID HERE>>';
  const scope = [
    /** See, edit, configure, and delete your Google Cloud data and see the email address for your Google Account. */
    'https://www.googleapis.com/auth/cloud-platform',
    /** View and write monitoring data for all of your Google and third-party Cloud and API projects */
    'https://www.googleapis.com/auth/monitoring',
    /** View monitoring data for all of your Google Cloud and third-party projects */
    'https://www.googleapis.com/auth/monitoring.read',
    /** Publish metric data to your Google Cloud projects */
    'https://www.googleapis.com/auth/monitoring.write',
  ];
  const immediate = false;
  gapi.auth.authorize({client_id, scope, immediate}, authResult => {
    if (authResult && !authResult.error) {
      /** handle successful authorization */
      void run();
    } else {
      /** handle authorization error */
    }
  });

  async function run() {
    /** Lists time series that match a filter. */
    await gapi.client.monitoring.folders.timeSeries.list({
      'aggregation.alignmentPeriod': 'Test string',
      'aggregation.crossSeriesReducer': 'Test string',
      'aggregation.groupByFields': 'Test string',
      'aggregation.perSeriesAligner': 'Test string',
      filter: 'Test string',
      'interval.endTime': 'Test string',
      'interval.startTime': 'Test string',
      name: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      'secondaryAggregation.alignmentPeriod': 'Test string',
      'secondaryAggregation.crossSeriesReducer': 'Test string',
      'secondaryAggregation.groupByFields': 'Test string',
      'secondaryAggregation.perSeriesAligner': 'Test string',
      view: 'Test string',
    });
    /** Lists time series that match a filter. */
    await gapi.client.monitoring.organizations.timeSeries.list({
      'aggregation.alignmentPeriod': 'Test string',
      'aggregation.crossSeriesReducer': 'Test string',
      'aggregation.groupByFields': 'Test string',
      'aggregation.perSeriesAligner': 'Test string',
      filter: 'Test string',
      'interval.endTime': 'Test string',
      'interval.startTime': 'Test string',
      name: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      'secondaryAggregation.alignmentPeriod': 'Test string',
      'secondaryAggregation.crossSeriesReducer': 'Test string',
      'secondaryAggregation.groupByFields': 'Test string',
      'secondaryAggregation.perSeriesAligner': 'Test string',
      view: 'Test string',
    });
    /** Creates a new alerting policy.Design your application to single-thread API calls that modify the state of alerting policies in a single project. This includes calls to CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy. */
    await gapi.client.monitoring.projects.alertPolicies.create(
      {
        name: 'Test string',
      },
      {
        alertStrategy: {
          autoClose: 'Test string',
          notificationChannelStrategy: [
            {
              notificationChannelNames: ['Test string'],
              renotifyInterval: 'Test string',
            },
          ],
          notificationRateLimit: {
            period: 'Test string',
          },
        },
        combiner: 'Test string',
        conditions: [
          {
            conditionAbsent: {
              aggregations: [
                {
                  alignmentPeriod: 'Test string',
                  crossSeriesReducer: 'Test string',
                  groupByFields: ['Test string'],
                  perSeriesAligner: 'Test string',
                },
              ],
              duration: 'Test string',
              filter: 'Test string',
              trigger: {
                count: 42,
                percent: 42,
              },
            },
            conditionMatchedLog: {
              filter: 'Test string',
              labelExtractors: {
                A: 'Test string',
              },
            },
            conditionMonitoringQueryLanguage: {
              duration: 'Test string',
              evaluationMissingData: 'Test string',
              query: 'Test string',
              trigger: {
                count: 42,
                percent: 42,
              },
            },
            conditionPrometheusQueryLanguage: {
              alertRule: 'Test string',
              duration: 'Test string',
              evaluationInterval: 'Test string',
              labels: {
                A: 'Test string',
              },
              query: 'Test string',
              ruleGroup: 'Test string',
            },
            conditionThreshold: {
              aggregations: [
                {
                  alignmentPeriod: 'Test string',
                  crossSeriesReducer: 'Test string',
                  groupByFields: ['Test string'],
                  perSeriesAligner: 'Test string',
                },
              ],
              comparison: 'Test string',
              denominatorAggregations: [
                {
                  alignmentPeriod: 'Test string',
                  crossSeriesReducer: 'Test string',
                  groupByFields: ['Test string'],
                  perSeriesAligner: 'Test string',
                },
              ],
              denominatorFilter: 'Test string',
              duration: 'Test string',
              evaluationMissingData: 'Test string',
              filter: 'Test string',
              forecastOptions: {
                forecastHorizon: 'Test string',
              },
              thresholdValue: 42,
              trigger: {
                count: 42,
                percent: 42,
              },
            },
            displayName: 'Test string',
            name: 'Test string',
          },
        ],
        creationRecord: {
          mutatedBy: 'Test string',
          mutateTime: 'Test string',
        },
        displayName: 'Test string',
        documentation: {
          content: 'Test string',
          mimeType: 'Test string',
          subject: 'Test string',
        },
        enabled: true,
        mutationRecord: {
          mutatedBy: 'Test string',
          mutateTime: 'Test string',
        },
        name: 'Test string',
        notificationChannels: ['Test string'],
        severity: 'Test string',
        userLabels: {
          A: 'Test string',
        },
        validity: {
          code: 42,
          details: [
            {
              A: 42,
            },
          ],
          message: 'Test string',
        },
      }
    );
    /** Deletes an alerting policy.Design your application to single-thread API calls that modify the state of alerting policies in a single project. This includes calls to CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy. */
    await gapi.client.monitoring.projects.alertPolicies.delete({
      name: 'Test string',
    });
    /** Gets a single alerting policy. */
    await gapi.client.monitoring.projects.alertPolicies.get({
      name: 'Test string',
    });
    /** Lists the existing alerting policies for the workspace. */
    await gapi.client.monitoring.projects.alertPolicies.list({
      filter: 'Test string',
      name: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Updates an alerting policy. You can either replace the entire policy with a new one or replace only certain fields in the current alerting policy by specifying the fields to be updated via updateMask. Returns the updated alerting policy.Design your application to single-thread API calls that modify the state of alerting policies in a single project. This includes calls to CreateAlertPolicy, DeleteAlertPolicy and UpdateAlertPolicy. */
    await gapi.client.monitoring.projects.alertPolicies.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        alertStrategy: {
          autoClose: 'Test string',
          notificationChannelStrategy: [
            {
              notificationChannelNames: ['Test string'],
              renotifyInterval: 'Test string',
            },
          ],
          notificationRateLimit: {
            period: 'Test string',
          },
        },
        combiner: 'Test string',
        conditions: [
          {
            conditionAbsent: {
              aggregations: [
                {
                  alignmentPeriod: 'Test string',
                  crossSeriesReducer: 'Test string',
                  groupByFields: ['Test string'],
                  perSeriesAligner: 'Test string',
                },
              ],
              duration: 'Test string',
              filter: 'Test string',
              trigger: {
                count: 42,
                percent: 42,
              },
            },
            conditionMatchedLog: {
              filter: 'Test string',
              labelExtractors: {
                A: 'Test string',
              },
            },
            conditionMonitoringQueryLanguage: {
              duration: 'Test string',
              evaluationMissingData: 'Test string',
              query: 'Test string',
              trigger: {
                count: 42,
                percent: 42,
              },
            },
            conditionPrometheusQueryLanguage: {
              alertRule: 'Test string',
              duration: 'Test string',
              evaluationInterval: 'Test string',
              labels: {
                A: 'Test string',
              },
              query: 'Test string',
              ruleGroup: 'Test string',
            },
            conditionThreshold: {
              aggregations: [
                {
                  alignmentPeriod: 'Test string',
                  crossSeriesReducer: 'Test string',
                  groupByFields: ['Test string'],
                  perSeriesAligner: 'Test string',
                },
              ],
              comparison: 'Test string',
              denominatorAggregations: [
                {
                  alignmentPeriod: 'Test string',
                  crossSeriesReducer: 'Test string',
                  groupByFields: ['Test string'],
                  perSeriesAligner: 'Test string',
                },
              ],
              denominatorFilter: 'Test string',
              duration: 'Test string',
              evaluationMissingData: 'Test string',
              filter: 'Test string',
              forecastOptions: {
                forecastHorizon: 'Test string',
              },
              thresholdValue: 42,
              trigger: {
                count: 42,
                percent: 42,
              },
            },
            displayName: 'Test string',
            name: 'Test string',
          },
        ],
        creationRecord: {
          mutatedBy: 'Test string',
          mutateTime: 'Test string',
        },
        displayName: 'Test string',
        documentation: {
          content: 'Test string',
          mimeType: 'Test string',
          subject: 'Test string',
        },
        enabled: true,
        mutationRecord: {
          mutatedBy: 'Test string',
          mutateTime: 'Test string',
        },
        name: 'Test string',
        notificationChannels: ['Test string'],
        severity: 'Test string',
        userLabels: {
          A: 'Test string',
        },
        validity: {
          code: 42,
          details: [
            {
              A: 42,
            },
          ],
          message: 'Test string',
        },
      }
    );
    /** Cloud Monitoring Agent only: Creates a new time series.This method is only for use by the Cloud Monitoring Agent. Use projects.timeSeries.create instead. */
    await gapi.client.monitoring.projects.collectdTimeSeries.create(
      {
        name: 'Test string',
      },
      {
        collectdPayloads: [
          {
            endTime: 'Test string',
            metadata: {
              A: {
                boolValue: true,
                distributionValue: {
                  bucketCounts: ['Test string'],
                  bucketOptions: {
                    explicitBuckets: {
                      bounds: [42],
                    },
                    exponentialBuckets: {
                      growthFactor: 42,
                      numFiniteBuckets: 42,
                      scale: 42,
                    },
                    linearBuckets: {
                      numFiniteBuckets: 42,
                      offset: 42,
                      width: 42,
                    },
                  },
                  count: 'Test string',
                  exemplars: [
                    {
                      attachments: [
                        {
                          A: 42,
                        },
                      ],
                      timestamp: 'Test string',
                      value: 42,
                    },
                  ],
                  mean: 42,
                  range: {
                    max: 42,
                    min: 42,
                  },
                  sumOfSquaredDeviation: 42,
                },
                doubleValue: 42,
                int64Value: 'Test string',
                stringValue: 'Test string',
              },
            },
            plugin: 'Test string',
            pluginInstance: 'Test string',
            startTime: 'Test string',
            type: 'Test string',
            typeInstance: 'Test string',
            values: [
              {
                dataSourceName: 'Test string',
                dataSourceType: 'Test string',
                value: {
                  boolValue: true,
                  distributionValue: {
                    bucketCounts: ['Test string'],
                    bucketOptions: {
                      explicitBuckets: {
                        bounds: [42],
                      },
                      exponentialBuckets: {
                        growthFactor: 42,
                        numFiniteBuckets: 42,
                        scale: 42,
                      },
                      linearBuckets: {
                        numFiniteBuckets: 42,
                        offset: 42,
                        width: 42,
                      },
                    },
                    count: 'Test string',
                    exemplars: [
                      {
                        attachments: [
                          {
                            A: 42,
                          },
                        ],
                        timestamp: 'Test string',
                        value: 42,
                      },
                    ],
                    mean: 42,
                    range: {
                      max: 42,
                      min: 42,
                    },
                    sumOfSquaredDeviation: 42,
                  },
                  doubleValue: 42,
                  int64Value: 'Test string',
                  stringValue: 'Test string',
                },
              },
            ],
          },
        ],
        collectdVersion: 'Test string',
        resource: {
          labels: {
            A: 'Test string',
          },
          type: 'Test string',
        },
      }
    );
    /** Creates a new group. */
    await gapi.client.monitoring.projects.groups.create(
      {
        name: 'Test string',
        validateOnly: true,
      },
      {
        displayName: 'Test string',
        filter: 'Test string',
        isCluster: true,
        name: 'Test string',
        parentName: 'Test string',
      }
    );
    /** Deletes an existing group. */
    await gapi.client.monitoring.projects.groups.delete({
      name: 'Test string',
      recursive: true,
    });
    /** Gets a single group. */
    await gapi.client.monitoring.projects.groups.get({
      name: 'Test string',
    });
    /** Lists the existing groups. */
    await gapi.client.monitoring.projects.groups.list({
      ancestorsOfGroup: 'Test string',
      childrenOfGroup: 'Test string',
      descendantsOfGroup: 'Test string',
      name: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Updates an existing group. You can change any group attributes except name. */
    await gapi.client.monitoring.projects.groups.update(
      {
        name: 'Test string',
        validateOnly: true,
      },
      {
        displayName: 'Test string',
        filter: 'Test string',
        isCluster: true,
        name: 'Test string',
        parentName: 'Test string',
      }
    );
    /** Lists the monitored resources that are members of a group. */
    await gapi.client.monitoring.projects.groups.members.list({
      filter: 'Test string',
      'interval.endTime': 'Test string',
      'interval.startTime': 'Test string',
      name: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Creates a new metric descriptor. The creation is executed asynchronously. User-created metric descriptors define custom metrics (https://cloud.google.com/monitoring/custom-metrics). The metric descriptor is updated if it already exists, except that metric labels are never removed. */
    await gapi.client.monitoring.projects.metricDescriptors.create(
      {
        name: 'Test string',
      },
      {
        description: 'Test string',
        displayName: 'Test string',
        labels: [
          {
            description: 'Test string',
            key: 'Test string',
            valueType: 'Test string',
          },
        ],
        launchStage: 'Test string',
        metadata: {
          ingestDelay: 'Test string',
          launchStage: 'Test string',
          samplePeriod: 'Test string',
        },
        metricKind: 'Test string',
        monitoredResourceTypes: ['Test string'],
        name: 'Test string',
        type: 'Test string',
        unit: 'Test string',
        valueType: 'Test string',
      }
    );
    /** Deletes a metric descriptor. Only user-created custom metrics (https://cloud.google.com/monitoring/custom-metrics) can be deleted. */
    await gapi.client.monitoring.projects.metricDescriptors.delete({
      name: 'Test string',
    });
    /** Gets a single metric descriptor. */
    await gapi.client.monitoring.projects.metricDescriptors.get({
      name: 'Test string',
    });
    /** Lists metric descriptors that match a filter. */
    await gapi.client.monitoring.projects.metricDescriptors.list({
      filter: 'Test string',
      name: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Gets a single monitored resource descriptor. */
    await gapi.client.monitoring.projects.monitoredResourceDescriptors.get({
      name: 'Test string',
    });
    /** Lists monitored resource descriptors that match a filter. */
    await gapi.client.monitoring.projects.monitoredResourceDescriptors.list({
      filter: 'Test string',
      name: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Gets a single channel descriptor. The descriptor indicates which fields are expected / permitted for a notification channel of the given type. */
    await gapi.client.monitoring.projects.notificationChannelDescriptors.get({
      name: 'Test string',
    });
    /** Lists the descriptors for supported channel types. The use of descriptors makes it possible for new channel types to be dynamically added. */
    await gapi.client.monitoring.projects.notificationChannelDescriptors.list({
      name: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Creates a new notification channel, representing a single notification endpoint such as an email address, SMS number, or PagerDuty service.Design your application to single-thread API calls that modify the state of notification channels in a single project. This includes calls to CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel. */
    await gapi.client.monitoring.projects.notificationChannels.create(
      {
        name: 'Test string',
      },
      {
        creationRecord: {
          mutatedBy: 'Test string',
          mutateTime: 'Test string',
        },
        description: 'Test string',
        displayName: 'Test string',
        enabled: true,
        labels: {
          A: 'Test string',
        },
        mutationRecords: [
          {
            mutatedBy: 'Test string',
            mutateTime: 'Test string',
          },
        ],
        name: 'Test string',
        type: 'Test string',
        userLabels: {
          A: 'Test string',
        },
        verificationStatus: 'Test string',
      }
    );
    /** Deletes a notification channel.Design your application to single-thread API calls that modify the state of notification channels in a single project. This includes calls to CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel. */
    await gapi.client.monitoring.projects.notificationChannels.delete({
      force: true,
      name: 'Test string',
    });
    /** Gets a single notification channel. The channel includes the relevant configuration details with which the channel was created. However, the response may truncate or omit passwords, API keys, or other private key matter and thus the response may not be 100% identical to the information that was supplied in the call to the create method. */
    await gapi.client.monitoring.projects.notificationChannels.get({
      name: 'Test string',
    });
    /** Requests a verification code for an already verified channel that can then be used in a call to VerifyNotificationChannel() on a different channel with an equivalent identity in the same or in a different project. This makes it possible to copy a channel between projects without requiring manual reverification of the channel. If the channel is not in the verified state, this method will fail (in other words, this may only be used if the SendNotificationChannelVerificationCode and VerifyNotificationChannel paths have already been used to put the given channel into the verified state).There is no guarantee that the verification codes returned by this method will be of a similar structure or form as the ones that are delivered to the channel via SendNotificationChannelVerificationCode; while VerifyNotificationChannel() will recognize both the codes delivered via SendNotificationChannelVerificationCode() and returned from GetNotificationChannelVerificationCode(), it is typically the case that the verification codes delivered via SendNotificationChannelVerificationCode() will be shorter and also have a shorter expiration (e.g. codes such as "G-123456") whereas GetVerificationCode() will typically return a much longer, websafe base 64 encoded string that has a longer expiration time. */
    await gapi.client.monitoring.projects.notificationChannels.getVerificationCode(
      {
        name: 'Test string',
      },
      {
        expireTime: 'Test string',
      }
    );
    /** Lists the notification channels that have been created for the project. To list the types of notification channels that are supported, use the ListNotificationChannelDescriptors method. */
    await gapi.client.monitoring.projects.notificationChannels.list({
      filter: 'Test string',
      name: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
    });
    /** Updates a notification channel. Fields not specified in the field mask remain unchanged.Design your application to single-thread API calls that modify the state of notification channels in a single project. This includes calls to CreateNotificationChannel, DeleteNotificationChannel and UpdateNotificationChannel. */
    await gapi.client.monitoring.projects.notificationChannels.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        creationRecord: {
          mutatedBy: 'Test string',
          mutateTime: 'Test string',
        },
        description: 'Test string',
        displayName: 'Test string',
        enabled: true,
        labels: {
          A: 'Test string',
        },
        mutationRecords: [
          {
            mutatedBy: 'Test string',
            mutateTime: 'Test string',
          },
        ],
        name: 'Test string',
        type: 'Test string',
        userLabels: {
          A: 'Test string',
        },
        verificationStatus: 'Test string',
      }
    );
    /** Causes a verification code to be delivered to the channel. The code can then be supplied in VerifyNotificationChannel to verify the channel. */
    await gapi.client.monitoring.projects.notificationChannels.sendVerificationCode(
      {
        name: 'Test string',
      },
      {}
    );
    /** Verifies a NotificationChannel by proving receipt of the code delivered to the channel as a result of calling SendNotificationChannelVerificationCode. */
    await gapi.client.monitoring.projects.notificationChannels.verify(
      {
        name: 'Test string',
      },
      {
        code: 'Test string',
      }
    );
    /** Creates a Snooze that will prevent alerts, which match the provided criteria, from being opened. The Snooze applies for a specific time interval. */
    await gapi.client.monitoring.projects.snoozes.create(
      {
        parent: 'Test string',
      },
      {
        criteria: {
          policies: ['Test string'],
        },
        displayName: 'Test string',
        interval: {
          endTime: 'Test string',
          startTime: 'Test string',
        },
        name: 'Test string',
      }
    );
    /** Retrieves a Snooze by name. */
    await gapi.client.monitoring.projects.snoozes.get({
      name: 'Test string',
    });
    /** Lists the Snoozes associated with a project. Can optionally pass in filter, which specifies predicates to match Snoozes. */
    await gapi.client.monitoring.projects.snoozes.list({
      filter: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates a Snooze, identified by its name, with the parameters in the given Snooze object. */
    await gapi.client.monitoring.projects.snoozes.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        criteria: {
          policies: ['Test string'],
        },
        displayName: 'Test string',
        interval: {
          endTime: 'Test string',
          startTime: 'Test string',
        },
        name: 'Test string',
      }
    );
    /** Creates or adds data to one or more time series. The response is empty if all time series in the request were written. If any time series could not be written, a corresponding failure message is included in the error response. This method does not support resource locations constraint of an organization policy (https://cloud.google.com/resource-manager/docs/organization-policy/defining-locations#setting_the_organization_policy). */
    await gapi.client.monitoring.projects.timeSeries.create(
      {
        name: 'Test string',
      },
      {
        timeSeries: [
          {
            metadata: {
              systemLabels: {
                A: 42,
              },
              userLabels: {
                A: 'Test string',
              },
            },
            metric: {
              labels: {
                A: 'Test string',
              },
              type: 'Test string',
            },
            metricKind: 'Test string',
            points: [
              {
                interval: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                value: {
                  boolValue: true,
                  distributionValue: {
                    bucketCounts: ['Test string'],
                    bucketOptions: {
                      explicitBuckets: {
                        bounds: [42],
                      },
                      exponentialBuckets: {
                        growthFactor: 42,
                        numFiniteBuckets: 42,
                        scale: 42,
                      },
                      linearBuckets: {
                        numFiniteBuckets: 42,
                        offset: 42,
                        width: 42,
                      },
                    },
                    count: 'Test string',
                    exemplars: [
                      {
                        attachments: [
                          {
                            A: 42,
                          },
                        ],
                        timestamp: 'Test string',
                        value: 42,
                      },
                    ],
                    mean: 42,
                    range: {
                      max: 42,
                      min: 42,
                    },
                    sumOfSquaredDeviation: 42,
                  },
                  doubleValue: 42,
                  int64Value: 'Test string',
                  stringValue: 'Test string',
                },
              },
            ],
            resource: {
              labels: {
                A: 'Test string',
              },
              type: 'Test string',
            },
            unit: 'Test string',
            valueType: 'Test string',
          },
        ],
      }
    );
    /** Creates or adds data to one or more service time series. A service time series is a time series for a metric from a Google Cloud service. The response is empty if all time series in the request were written. If any time series could not be written, a corresponding failure message is included in the error response. This endpoint rejects writes to user-defined metrics. This method is only for use by Google Cloud services. Use projects.timeSeries.create instead. */
    await gapi.client.monitoring.projects.timeSeries.createService(
      {
        name: 'Test string',
      },
      {
        timeSeries: [
          {
            metadata: {
              systemLabels: {
                A: 42,
              },
              userLabels: {
                A: 'Test string',
              },
            },
            metric: {
              labels: {
                A: 'Test string',
              },
              type: 'Test string',
            },
            metricKind: 'Test string',
            points: [
              {
                interval: {
                  endTime: 'Test string',
                  startTime: 'Test string',
                },
                value: {
                  boolValue: true,
                  distributionValue: {
                    bucketCounts: ['Test string'],
                    bucketOptions: {
                      explicitBuckets: {
                        bounds: [42],
                      },
                      exponentialBuckets: {
                        growthFactor: 42,
                        numFiniteBuckets: 42,
                        scale: 42,
                      },
                      linearBuckets: {
                        numFiniteBuckets: 42,
                        offset: 42,
                        width: 42,
                      },
                    },
                    count: 'Test string',
                    exemplars: [
                      {
                        attachments: [
                          {
                            A: 42,
                          },
                        ],
                        timestamp: 'Test string',
                        value: 42,
                      },
                    ],
                    mean: 42,
                    range: {
                      max: 42,
                      min: 42,
                    },
                    sumOfSquaredDeviation: 42,
                  },
                  doubleValue: 42,
                  int64Value: 'Test string',
                  stringValue: 'Test string',
                },
              },
            ],
            resource: {
              labels: {
                A: 'Test string',
              },
              type: 'Test string',
            },
            unit: 'Test string',
            valueType: 'Test string',
          },
        ],
      }
    );
    /** Lists time series that match a filter. */
    await gapi.client.monitoring.projects.timeSeries.list({
      'aggregation.alignmentPeriod': 'Test string',
      'aggregation.crossSeriesReducer': 'Test string',
      'aggregation.groupByFields': 'Test string',
      'aggregation.perSeriesAligner': 'Test string',
      filter: 'Test string',
      'interval.endTime': 'Test string',
      'interval.startTime': 'Test string',
      name: 'Test string',
      orderBy: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      'secondaryAggregation.alignmentPeriod': 'Test string',
      'secondaryAggregation.crossSeriesReducer': 'Test string',
      'secondaryAggregation.groupByFields': 'Test string',
      'secondaryAggregation.perSeriesAligner': 'Test string',
      view: 'Test string',
    });
    /** Queries time series using Monitoring Query Language. */
    await gapi.client.monitoring.projects.timeSeries.query(
      {
        name: 'Test string',
      },
      {
        pageSize: 42,
        pageToken: 'Test string',
        query: 'Test string',
      }
    );
    /** Creates a new Uptime check configuration. */
    await gapi.client.monitoring.projects.uptimeCheckConfigs.create(
      {
        parent: 'Test string',
      },
      {
        checkerType: 'Test string',
        contentMatchers: [
          {
            content: 'Test string',
            jsonPathMatcher: {
              jsonMatcher: 'Test string',
              jsonPath: 'Test string',
            },
            matcher: 'Test string',
          },
        ],
        displayName: 'Test string',
        httpCheck: {
          acceptedResponseStatusCodes: [
            {
              statusClass: 'Test string',
              statusValue: 42,
            },
          ],
          authInfo: {
            password: 'Test string',
            username: 'Test string',
          },
          body: 'Test string',
          contentType: 'Test string',
          customContentType: 'Test string',
          headers: {
            A: 'Test string',
          },
          maskHeaders: true,
          path: 'Test string',
          pingConfig: {
            pingsCount: 42,
          },
          port: 42,
          requestMethod: 'Test string',
          serviceAgentAuthentication: {
            type: 'Test string',
          },
          useSsl: true,
          validateSsl: true,
        },
        internalCheckers: [
          {
            displayName: 'Test string',
            gcpZone: 'Test string',
            name: 'Test string',
            network: 'Test string',
            peerProjectId: 'Test string',
            state: 'Test string',
          },
        ],
        isInternal: true,
        monitoredResource: {
          labels: {
            A: 'Test string',
          },
          type: 'Test string',
        },
        name: 'Test string',
        period: 'Test string',
        resourceGroup: {
          groupId: 'Test string',
          resourceType: 'Test string',
        },
        selectedRegions: ['Test string'],
        syntheticMonitor: {
          cloudFunctionV2: {
            cloudRunRevision: {
              labels: {
                A: 'Test string',
              },
              type: 'Test string',
            },
            name: 'Test string',
          },
        },
        tcpCheck: {
          pingConfig: {
            pingsCount: 42,
          },
          port: 42,
        },
        timeout: 'Test string',
        userLabels: {
          A: 'Test string',
        },
      }
    );
    /** Deletes an Uptime check configuration. Note that this method will fail if the Uptime check configuration is referenced by an alert policy or other dependent configs that would be rendered invalid by the deletion. */
    await gapi.client.monitoring.projects.uptimeCheckConfigs.delete({
      name: 'Test string',
    });
    /** Gets a single Uptime check configuration. */
    await gapi.client.monitoring.projects.uptimeCheckConfigs.get({
      name: 'Test string',
    });
    /** Lists the existing valid Uptime check configurations for the project (leaving out any invalid configurations). */
    await gapi.client.monitoring.projects.uptimeCheckConfigs.list({
      filter: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Updates an Uptime check configuration. You can either replace the entire configuration with a new one or replace only certain fields in the current configuration by specifying the fields to be updated via updateMask. Returns the updated configuration. */
    await gapi.client.monitoring.projects.uptimeCheckConfigs.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        checkerType: 'Test string',
        contentMatchers: [
          {
            content: 'Test string',
            jsonPathMatcher: {
              jsonMatcher: 'Test string',
              jsonPath: 'Test string',
            },
            matcher: 'Test string',
          },
        ],
        displayName: 'Test string',
        httpCheck: {
          acceptedResponseStatusCodes: [
            {
              statusClass: 'Test string',
              statusValue: 42,
            },
          ],
          authInfo: {
            password: 'Test string',
            username: 'Test string',
          },
          body: 'Test string',
          contentType: 'Test string',
          customContentType: 'Test string',
          headers: {
            A: 'Test string',
          },
          maskHeaders: true,
          path: 'Test string',
          pingConfig: {
            pingsCount: 42,
          },
          port: 42,
          requestMethod: 'Test string',
          serviceAgentAuthentication: {
            type: 'Test string',
          },
          useSsl: true,
          validateSsl: true,
        },
        internalCheckers: [
          {
            displayName: 'Test string',
            gcpZone: 'Test string',
            name: 'Test string',
            network: 'Test string',
            peerProjectId: 'Test string',
            state: 'Test string',
          },
        ],
        isInternal: true,
        monitoredResource: {
          labels: {
            A: 'Test string',
          },
          type: 'Test string',
        },
        name: 'Test string',
        period: 'Test string',
        resourceGroup: {
          groupId: 'Test string',
          resourceType: 'Test string',
        },
        selectedRegions: ['Test string'],
        syntheticMonitor: {
          cloudFunctionV2: {
            cloudRunRevision: {
              labels: {
                A: 'Test string',
              },
              type: 'Test string',
            },
            name: 'Test string',
          },
        },
        tcpCheck: {
          pingConfig: {
            pingsCount: 42,
          },
          port: 42,
        },
        timeout: 'Test string',
        userLabels: {
          A: 'Test string',
        },
      }
    );
    /** Create a Service. */
    await gapi.client.monitoring.services.create(
      {
        parent: 'Test string',
        serviceId: 'Test string',
      },
      {
        appEngine: {
          moduleId: 'Test string',
        },
        basicService: {
          serviceLabels: {
            A: 'Test string',
          },
          serviceType: 'Test string',
        },
        cloudEndpoints: {
          service: 'Test string',
        },
        cloudRun: {
          location: 'Test string',
          serviceName: 'Test string',
        },
        clusterIstio: {
          clusterName: 'Test string',
          location: 'Test string',
          serviceName: 'Test string',
          serviceNamespace: 'Test string',
        },
        custom: {},
        displayName: 'Test string',
        gkeNamespace: {
          clusterName: 'Test string',
          location: 'Test string',
          namespaceName: 'Test string',
          projectId: 'Test string',
        },
        gkeService: {
          clusterName: 'Test string',
          location: 'Test string',
          namespaceName: 'Test string',
          projectId: 'Test string',
          serviceName: 'Test string',
        },
        gkeWorkload: {
          clusterName: 'Test string',
          location: 'Test string',
          namespaceName: 'Test string',
          projectId: 'Test string',
          topLevelControllerName: 'Test string',
          topLevelControllerType: 'Test string',
        },
        istioCanonicalService: {
          canonicalService: 'Test string',
          canonicalServiceNamespace: 'Test string',
          meshUid: 'Test string',
        },
        meshIstio: {
          meshUid: 'Test string',
          serviceName: 'Test string',
          serviceNamespace: 'Test string',
        },
        name: 'Test string',
        telemetry: {
          resourceName: 'Test string',
        },
        userLabels: {
          A: 'Test string',
        },
      }
    );
    /** Soft delete this Service. */
    await gapi.client.monitoring.services.delete({
      name: 'Test string',
    });
    /** Get the named Service. */
    await gapi.client.monitoring.services.get({
      name: 'Test string',
    });
    /** List Services for this Metrics Scope. */
    await gapi.client.monitoring.services.list({
      filter: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
    });
    /** Update this Service. */
    await gapi.client.monitoring.services.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        appEngine: {
          moduleId: 'Test string',
        },
        basicService: {
          serviceLabels: {
            A: 'Test string',
          },
          serviceType: 'Test string',
        },
        cloudEndpoints: {
          service: 'Test string',
        },
        cloudRun: {
          location: 'Test string',
          serviceName: 'Test string',
        },
        clusterIstio: {
          clusterName: 'Test string',
          location: 'Test string',
          serviceName: 'Test string',
          serviceNamespace: 'Test string',
        },
        custom: {},
        displayName: 'Test string',
        gkeNamespace: {
          clusterName: 'Test string',
          location: 'Test string',
          namespaceName: 'Test string',
          projectId: 'Test string',
        },
        gkeService: {
          clusterName: 'Test string',
          location: 'Test string',
          namespaceName: 'Test string',
          projectId: 'Test string',
          serviceName: 'Test string',
        },
        gkeWorkload: {
          clusterName: 'Test string',
          location: 'Test string',
          namespaceName: 'Test string',
          projectId: 'Test string',
          topLevelControllerName: 'Test string',
          topLevelControllerType: 'Test string',
        },
        istioCanonicalService: {
          canonicalService: 'Test string',
          canonicalServiceNamespace: 'Test string',
          meshUid: 'Test string',
        },
        meshIstio: {
          meshUid: 'Test string',
          serviceName: 'Test string',
          serviceNamespace: 'Test string',
        },
        name: 'Test string',
        telemetry: {
          resourceName: 'Test string',
        },
        userLabels: {
          A: 'Test string',
        },
      }
    );
    /** Create a ServiceLevelObjective for the given Service. */
    await gapi.client.monitoring.services.serviceLevelObjectives.create(
      {
        parent: 'Test string',
        serviceLevelObjectiveId: 'Test string',
      },
      {
        calendarPeriod: 'Test string',
        displayName: 'Test string',
        goal: 42,
        name: 'Test string',
        rollingPeriod: 'Test string',
        serviceLevelIndicator: {
          basicSli: {
            availability: {},
            latency: {
              threshold: 'Test string',
            },
            location: ['Test string'],
            method: ['Test string'],
            version: ['Test string'],
          },
          requestBased: {
            distributionCut: {
              distributionFilter: 'Test string',
              range: {
                max: 42,
                min: 42,
              },
            },
            goodTotalRatio: {
              badServiceFilter: 'Test string',
              goodServiceFilter: 'Test string',
              totalServiceFilter: 'Test string',
            },
          },
          windowsBased: {
            goodBadMetricFilter: 'Test string',
            goodTotalRatioThreshold: {
              basicSliPerformance: {
                availability: {},
                latency: {
                  threshold: 'Test string',
                },
                location: ['Test string'],
                method: ['Test string'],
                version: ['Test string'],
              },
              performance: {
                distributionCut: {
                  distributionFilter: 'Test string',
                  range: {
                    max: 42,
                    min: 42,
                  },
                },
                goodTotalRatio: {
                  badServiceFilter: 'Test string',
                  goodServiceFilter: 'Test string',
                  totalServiceFilter: 'Test string',
                },
              },
              threshold: 42,
            },
            metricMeanInRange: {
              range: {
                max: 42,
                min: 42,
              },
              timeSeries: 'Test string',
            },
            metricSumInRange: {
              range: {
                max: 42,
                min: 42,
              },
              timeSeries: 'Test string',
            },
            windowPeriod: 'Test string',
          },
        },
        userLabels: {
          A: 'Test string',
        },
      }
    );
    /** Delete the given ServiceLevelObjective. */
    await gapi.client.monitoring.services.serviceLevelObjectives.delete({
      name: 'Test string',
    });
    /** Get a ServiceLevelObjective by name. */
    await gapi.client.monitoring.services.serviceLevelObjectives.get({
      name: 'Test string',
      view: 'Test string',
    });
    /** List the ServiceLevelObjectives for the given Service. */
    await gapi.client.monitoring.services.serviceLevelObjectives.list({
      filter: 'Test string',
      pageSize: 42,
      pageToken: 'Test string',
      parent: 'Test string',
      view: 'Test string',
    });
    /** Update the given ServiceLevelObjective. */
    await gapi.client.monitoring.services.serviceLevelObjectives.patch(
      {
        name: 'Test string',
        updateMask: 'Test string',
      },
      {
        calendarPeriod: 'Test string',
        displayName: 'Test string',
        goal: 42,
        name: 'Test string',
        rollingPeriod: 'Test string',
        serviceLevelIndicator: {
          basicSli: {
            availability: {},
            latency: {
              threshold: 'Test string',
            },
            location: ['Test string'],
            method: ['Test string'],
            version: ['Test string'],
          },
          requestBased: {
            distributionCut: {
              distributionFilter: 'Test string',
              range: {
                max: 42,
                min: 42,
              },
            },
            goodTotalRatio: {
              badServiceFilter: 'Test string',
              goodServiceFilter: 'Test string',
              totalServiceFilter: 'Test string',
            },
          },
          windowsBased: {
            goodBadMetricFilter: 'Test string',
            goodTotalRatioThreshold: {
              basicSliPerformance: {
                availability: {},
                latency: {
                  threshold: 'Test string',
                },
                location: ['Test string'],
                method: ['Test string'],
                version: ['Test string'],
              },
              performance: {
                distributionCut: {
                  distributionFilter: 'Test string',
                  range: {
                    max: 42,
                    min: 42,
                  },
                },
                goodTotalRatio: {
                  badServiceFilter: 'Test string',
                  goodServiceFilter: 'Test string',
                  totalServiceFilter: 'Test string',
                },
              },
              threshold: 42,
            },
            metricMeanInRange: {
              range: {
                max: 42,
                min: 42,
              },
              timeSeries: 'Test string',
            },
            metricSumInRange: {
              range: {
                max: 42,
                min: 42,
              },
              timeSeries: 'Test string',
            },
            windowPeriod: 'Test string',
          },
        },
        userLabels: {
          A: 'Test string',
        },
      }
    );
    /** Returns the list of IP addresses that checkers run from. */
    await gapi.client.monitoring.uptimeCheckIps.list({
      pageSize: 42,
      pageToken: 'Test string',
    });
  }
});
