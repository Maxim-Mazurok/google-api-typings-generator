/* This is stub file for gapi.client.compute-v1 definition tests */
// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator

// Revision: 20230610

gapi.load('client', async () => {
    /** now we can use gapi.client */

    await gapi.client.load('https://www.googleapis.com/discovery/v1/apis/compute/v1/rest');
    /** now we can use gapi.client.compute */

    /** don't forget to authenticate your client before sending any request to resources: */
    /** declare client_id registered in Google Developers Console */
    const client_id = '<<PUT YOUR CLIENT ID HERE>>';
    const scope = [
        /** See, edit, configure, and delete your Google Cloud data and see the email address for your Google Account. */
        'https://www.googleapis.com/auth/cloud-platform',
        /** View and manage your Google Compute Engine resources */
        'https://www.googleapis.com/auth/compute',
        /** View your Google Compute Engine resources */
        'https://www.googleapis.com/auth/compute.readonly',
        /** Manage your data and permissions in Cloud Storage and see the email address for your Google Account */
        'https://www.googleapis.com/auth/devstorage.full_control',
        /** View your data in Google Cloud Storage */
        'https://www.googleapis.com/auth/devstorage.read_only',
        /** Manage your data in Cloud Storage and see the email address of your Google Account */
        'https://www.googleapis.com/auth/devstorage.read_write',
    ];
    const immediate = false;
    gapi.auth.authorize({ client_id, scope, immediate }, authResult => {
        if (authResult && !authResult.error) {
            /** handle successful authorization */
            run();
        } else {
            /** handle authorization error */
        }
    });

    async function run() {
        /** Retrieves an aggregated list of accelerator types. */
        await gapi.client.compute.acceleratorTypes.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Returns the specified accelerator type. */
        await gapi.client.compute.acceleratorTypes.get({
            acceleratorType: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of accelerator types that are available to the specified project. */
        await gapi.client.compute.acceleratorTypes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Retrieves an aggregated list of addresses. */
        await gapi.client.compute.addresses.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified address resource. */
        await gapi.client.compute.addresses.delete({
            address: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified address resource. */
        await gapi.client.compute.addresses.get({
            address: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates an address resource in the specified project by using the data included in the request. */
        await gapi.client.compute.addresses.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            address: "Test string",
            addressType: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            ipv6EndpointType: "Test string",
            ipVersion: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            networkTier: "Test string",
            prefixLength: 42,
            purpose: "Test string",
            region: "Test string",
            selfLink: "Test string",
            status: "Test string",
            subnetwork: "Test string",
            users: [
                "Test string"
            ],
        });
        /** Retrieves a list of addresses contained within the specified region. */
        await gapi.client.compute.addresses.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Moves the specified address resource. */
        await gapi.client.compute.addresses.move({
            address: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            description: "Test string",
            destinationAddress: "Test string",
        });
        /** Sets the labels on an Address. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.addresses.setLabels({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Retrieves an aggregated list of autoscalers. */
        await gapi.client.compute.autoscalers.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified autoscaler. */
        await gapi.client.compute.autoscalers.delete({
            autoscaler: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Returns the specified autoscaler resource. */
        await gapi.client.compute.autoscalers.get({
            autoscaler: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Creates an autoscaler in the specified project using the data included in the request. */
        await gapi.client.compute.autoscalers.insert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            autoscalingPolicy: {
                coolDownPeriodSec: 42,
                cpuUtilization: {
                    predictiveMethod: "Test string",
                    utilizationTarget: 42,
                },
                customMetricUtilizations: [
                    {
                        filter: "Test string",
                        metric: "Test string",
                        singleInstanceAssignment: 42,
                        utilizationTarget: 42,
                        utilizationTargetType: "Test string",
                    }
                ],
                loadBalancingUtilization: {
                    utilizationTarget: 42,
                },
                maxNumReplicas: 42,
                minNumReplicas: 42,
                mode: "Test string",
                scaleInControl: {
                    maxScaledInReplicas: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                    timeWindowSec: 42,
                },
                scalingSchedules: {
                    A: {
                        description: "Test string",
                        disabled: true,
                        durationSec: 42,
                        minRequiredReplicas: 42,
                        schedule: "Test string",
                        timeZone: "Test string",
                    }
                },
            },
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            recommendedSize: 42,
            region: "Test string",
            scalingScheduleStatus: {
                A: {
                    lastStartTime: "Test string",
                    nextStartTime: "Test string",
                    state: "Test string",
                }
            },
            selfLink: "Test string",
            status: "Test string",
            statusDetails: [
                {
                    message: "Test string",
                    type: "Test string",
                }
            ],
            target: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of autoscalers contained within the specified zone. */
        await gapi.client.compute.autoscalers.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. */
        await gapi.client.compute.autoscalers.patch({
            autoscaler: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            autoscalingPolicy: {
                coolDownPeriodSec: 42,
                cpuUtilization: {
                    predictiveMethod: "Test string",
                    utilizationTarget: 42,
                },
                customMetricUtilizations: [
                    {
                        filter: "Test string",
                        metric: "Test string",
                        singleInstanceAssignment: 42,
                        utilizationTarget: 42,
                        utilizationTargetType: "Test string",
                    }
                ],
                loadBalancingUtilization: {
                    utilizationTarget: 42,
                },
                maxNumReplicas: 42,
                minNumReplicas: 42,
                mode: "Test string",
                scaleInControl: {
                    maxScaledInReplicas: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                    timeWindowSec: 42,
                },
                scalingSchedules: {
                    A: {
                        description: "Test string",
                        disabled: true,
                        durationSec: 42,
                        minRequiredReplicas: 42,
                        schedule: "Test string",
                        timeZone: "Test string",
                    }
                },
            },
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            recommendedSize: 42,
            region: "Test string",
            scalingScheduleStatus: {
                A: {
                    lastStartTime: "Test string",
                    nextStartTime: "Test string",
                    state: "Test string",
                }
            },
            selfLink: "Test string",
            status: "Test string",
            statusDetails: [
                {
                    message: "Test string",
                    type: "Test string",
                }
            ],
            target: "Test string",
            zone: "Test string",
        });
        /** Updates an autoscaler in the specified project using the data included in the request. */
        await gapi.client.compute.autoscalers.update({
            autoscaler: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            autoscalingPolicy: {
                coolDownPeriodSec: 42,
                cpuUtilization: {
                    predictiveMethod: "Test string",
                    utilizationTarget: 42,
                },
                customMetricUtilizations: [
                    {
                        filter: "Test string",
                        metric: "Test string",
                        singleInstanceAssignment: 42,
                        utilizationTarget: 42,
                        utilizationTargetType: "Test string",
                    }
                ],
                loadBalancingUtilization: {
                    utilizationTarget: 42,
                },
                maxNumReplicas: 42,
                minNumReplicas: 42,
                mode: "Test string",
                scaleInControl: {
                    maxScaledInReplicas: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                    timeWindowSec: 42,
                },
                scalingSchedules: {
                    A: {
                        description: "Test string",
                        disabled: true,
                        durationSec: 42,
                        minRequiredReplicas: 42,
                        schedule: "Test string",
                        timeZone: "Test string",
                    }
                },
            },
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            recommendedSize: 42,
            region: "Test string",
            scalingScheduleStatus: {
                A: {
                    lastStartTime: "Test string",
                    nextStartTime: "Test string",
                    state: "Test string",
                }
            },
            selfLink: "Test string",
            status: "Test string",
            statusDetails: [
                {
                    message: "Test string",
                    type: "Test string",
                }
            ],
            target: "Test string",
            zone: "Test string",
        });
        /** Adds a key for validating requests with signed URLs for this backend bucket. */
        await gapi.client.compute.backendBuckets.addSignedUrlKey({
            backendBucket: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            keyName: "Test string",
            keyValue: "Test string",
        });
        /** Deletes the specified BackendBucket resource. */
        await gapi.client.compute.backendBuckets.delete({
            backendBucket: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Deletes a key for validating requests with signed URLs for this backend bucket. */
        await gapi.client.compute.backendBuckets.deleteSignedUrlKey({
            backendBucket: "Test string",
            keyName: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified BackendBucket resource. */
        await gapi.client.compute.backendBuckets.get({
            backendBucket: "Test string",
            project: "Test string",
        });
        /** Creates a BackendBucket resource in the specified project using the data included in the request. */
        await gapi.client.compute.backendBuckets.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            bucketName: "Test string",
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            compressionMode: "Test string",
            creationTimestamp: "Test string",
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCdn: true,
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            selfLink: "Test string",
        });
        /** Retrieves the list of BackendBucket resources available to the specified project. */
        await gapi.client.compute.backendBuckets.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Updates the specified BackendBucket resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. */
        await gapi.client.compute.backendBuckets.patch({
            backendBucket: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            bucketName: "Test string",
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            compressionMode: "Test string",
            creationTimestamp: "Test string",
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCdn: true,
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            selfLink: "Test string",
        });
        /** Sets the edge security policy for the specified backend bucket. */
        await gapi.client.compute.backendBuckets.setEdgeSecurityPolicy({
            backendBucket: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            securityPolicy: "Test string",
        });
        /** Updates the specified BackendBucket resource with the data included in the request. */
        await gapi.client.compute.backendBuckets.update({
            backendBucket: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            bucketName: "Test string",
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            compressionMode: "Test string",
            creationTimestamp: "Test string",
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCdn: true,
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            selfLink: "Test string",
        });
        /** Adds a key for validating requests with signed URLs for this backend service. */
        await gapi.client.compute.backendServices.addSignedUrlKey({
            backendService: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            keyName: "Test string",
            keyValue: "Test string",
        });
        /** Retrieves the list of all BackendService resources, regional and global, available to the specified project. */
        await gapi.client.compute.backendServices.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified BackendService resource. */
        await gapi.client.compute.backendServices.delete({
            backendService: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Deletes a key for validating requests with signed URLs for this backend service. */
        await gapi.client.compute.backendServices.deleteSignedUrlKey({
            backendService: "Test string",
            keyName: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified BackendService resource. */
        await gapi.client.compute.backendServices.get({
            backendService: "Test string",
            project: "Test string",
        });
        /** Gets the most recent health check results for this BackendService. Example request body: { "group": "/zones/us-east1-b/instanceGroups/lb-backend-example" } */
        await gapi.client.compute.backendServices.getHealth({
            backendService: "Test string",
            project: "Test string",
        }, {
            group: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.backendServices.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
        });
        /** Creates a BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview . */
        await gapi.client.compute.backendServices.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            affinityCookieTtlSec: 42,
            backends: [
                {
                    balancingMode: "Test string",
                    capacityScaler: 42,
                    description: "Test string",
                    failover: true,
                    group: "Test string",
                    maxConnections: 42,
                    maxConnectionsPerEndpoint: 42,
                    maxConnectionsPerInstance: 42,
                    maxRate: 42,
                    maxRatePerEndpoint: 42,
                    maxRatePerInstance: 42,
                    maxUtilization: 42,
                }
            ],
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHost: true,
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    includeNamedCookies: [
                        "Test string"
                    ],
                    includeProtocol: true,
                    includeQueryString: true,
                    queryStringBlacklist: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            circuitBreakers: {
                maxConnections: 42,
                maxPendingRequests: 42,
                maxRequests: 42,
                maxRequestsPerConnection: 42,
                maxRetries: 42,
            },
            compressionMode: "Test string",
            connectionDraining: {
                drainingTimeoutSec: 42,
            },
            connectionTrackingPolicy: {
                connectionPersistenceOnUnhealthyBackends: "Test string",
                enableStrongAffinity: true,
                idleTimeoutSec: 42,
                trackingMode: "Test string",
            },
            consistentHash: {
                httpCookie: {
                    name: "Test string",
                    path: "Test string",
                    ttl: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                },
                httpHeaderName: "Test string",
                minimumRingSize: "Test string",
            },
            creationTimestamp: "Test string",
            customRequestHeaders: [
                "Test string"
            ],
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCDN: true,
            failoverPolicy: {
                disableConnectionDrainOnFailover: true,
                dropTrafficIfUnhealthy: true,
                failoverRatio: 42,
            },
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            iap: {
                enabled: true,
                oauth2ClientId: "Test string",
                oauth2ClientSecret: "Test string",
                oauth2ClientSecretSha256: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            loadBalancingScheme: "Test string",
            localityLbPolicies: [
                {
                    customPolicy: {
                        data: "Test string",
                        name: "Test string",
                    },
                    policy: {
                        name: "Test string",
                    },
                }
            ],
            localityLbPolicy: "Test string",
            logConfig: {
                enable: true,
                optionalFields: [
                    "Test string"
                ],
                optionalMode: "Test string",
                sampleRate: 42,
            },
            maxStreamDuration: {
                nanos: 42,
                seconds: "Test string",
            },
            metadatas: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            outlierDetection: {
                baseEjectionTime: {
                    nanos: 42,
                    seconds: "Test string",
                },
                consecutiveErrors: 42,
                consecutiveGatewayFailure: 42,
                enforcingConsecutiveErrors: 42,
                enforcingConsecutiveGatewayFailure: 42,
                enforcingSuccessRate: 42,
                interval: {
                    nanos: 42,
                    seconds: "Test string",
                },
                maxEjectionPercent: 42,
                successRateMinimumHosts: 42,
                successRateRequestVolume: 42,
                successRateStdevFactor: 42,
            },
            port: 42,
            portName: "Test string",
            protocol: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            securitySettings: {
                clientTlsPolicy: "Test string",
                subjectAltNames: [
                    "Test string"
                ],
            },
            selfLink: "Test string",
            serviceBindings: [
                "Test string"
            ],
            sessionAffinity: "Test string",
            subsetting: {
                policy: "Test string",
            },
            timeoutSec: 42,
        });
        /** Retrieves the list of BackendService resources available to the specified project. */
        await gapi.client.compute.backendServices.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Patches the specified BackendService resource with the data included in the request. For more information, see Backend services overview. This method supports PATCH semantics and uses
         * the JSON merge patch format and processing rules.
         */
        await gapi.client.compute.backendServices.patch({
            backendService: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            affinityCookieTtlSec: 42,
            backends: [
                {
                    balancingMode: "Test string",
                    capacityScaler: 42,
                    description: "Test string",
                    failover: true,
                    group: "Test string",
                    maxConnections: 42,
                    maxConnectionsPerEndpoint: 42,
                    maxConnectionsPerInstance: 42,
                    maxRate: 42,
                    maxRatePerEndpoint: 42,
                    maxRatePerInstance: 42,
                    maxUtilization: 42,
                }
            ],
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHost: true,
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    includeNamedCookies: [
                        "Test string"
                    ],
                    includeProtocol: true,
                    includeQueryString: true,
                    queryStringBlacklist: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            circuitBreakers: {
                maxConnections: 42,
                maxPendingRequests: 42,
                maxRequests: 42,
                maxRequestsPerConnection: 42,
                maxRetries: 42,
            },
            compressionMode: "Test string",
            connectionDraining: {
                drainingTimeoutSec: 42,
            },
            connectionTrackingPolicy: {
                connectionPersistenceOnUnhealthyBackends: "Test string",
                enableStrongAffinity: true,
                idleTimeoutSec: 42,
                trackingMode: "Test string",
            },
            consistentHash: {
                httpCookie: {
                    name: "Test string",
                    path: "Test string",
                    ttl: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                },
                httpHeaderName: "Test string",
                minimumRingSize: "Test string",
            },
            creationTimestamp: "Test string",
            customRequestHeaders: [
                "Test string"
            ],
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCDN: true,
            failoverPolicy: {
                disableConnectionDrainOnFailover: true,
                dropTrafficIfUnhealthy: true,
                failoverRatio: 42,
            },
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            iap: {
                enabled: true,
                oauth2ClientId: "Test string",
                oauth2ClientSecret: "Test string",
                oauth2ClientSecretSha256: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            loadBalancingScheme: "Test string",
            localityLbPolicies: [
                {
                    customPolicy: {
                        data: "Test string",
                        name: "Test string",
                    },
                    policy: {
                        name: "Test string",
                    },
                }
            ],
            localityLbPolicy: "Test string",
            logConfig: {
                enable: true,
                optionalFields: [
                    "Test string"
                ],
                optionalMode: "Test string",
                sampleRate: 42,
            },
            maxStreamDuration: {
                nanos: 42,
                seconds: "Test string",
            },
            metadatas: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            outlierDetection: {
                baseEjectionTime: {
                    nanos: 42,
                    seconds: "Test string",
                },
                consecutiveErrors: 42,
                consecutiveGatewayFailure: 42,
                enforcingConsecutiveErrors: 42,
                enforcingConsecutiveGatewayFailure: 42,
                enforcingSuccessRate: 42,
                interval: {
                    nanos: 42,
                    seconds: "Test string",
                },
                maxEjectionPercent: 42,
                successRateMinimumHosts: 42,
                successRateRequestVolume: 42,
                successRateStdevFactor: 42,
            },
            port: 42,
            portName: "Test string",
            protocol: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            securitySettings: {
                clientTlsPolicy: "Test string",
                subjectAltNames: [
                    "Test string"
                ],
            },
            selfLink: "Test string",
            serviceBindings: [
                "Test string"
            ],
            sessionAffinity: "Test string",
            subsetting: {
                policy: "Test string",
            },
            timeoutSec: 42,
        });
        /** Sets the edge security policy for the specified backend service. */
        await gapi.client.compute.backendServices.setEdgeSecurityPolicy({
            backendService: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            securityPolicy: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.backendServices.setIamPolicy({
            project: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Sets the Google Cloud Armor security policy for the specified backend service. For more information, see Google Cloud Armor Overview */
        await gapi.client.compute.backendServices.setSecurityPolicy({
            backendService: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            securityPolicy: "Test string",
        });
        /** Updates the specified BackendService resource with the data included in the request. For more information, see Backend services overview. */
        await gapi.client.compute.backendServices.update({
            backendService: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            affinityCookieTtlSec: 42,
            backends: [
                {
                    balancingMode: "Test string",
                    capacityScaler: 42,
                    description: "Test string",
                    failover: true,
                    group: "Test string",
                    maxConnections: 42,
                    maxConnectionsPerEndpoint: 42,
                    maxConnectionsPerInstance: 42,
                    maxRate: 42,
                    maxRatePerEndpoint: 42,
                    maxRatePerInstance: 42,
                    maxUtilization: 42,
                }
            ],
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHost: true,
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    includeNamedCookies: [
                        "Test string"
                    ],
                    includeProtocol: true,
                    includeQueryString: true,
                    queryStringBlacklist: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            circuitBreakers: {
                maxConnections: 42,
                maxPendingRequests: 42,
                maxRequests: 42,
                maxRequestsPerConnection: 42,
                maxRetries: 42,
            },
            compressionMode: "Test string",
            connectionDraining: {
                drainingTimeoutSec: 42,
            },
            connectionTrackingPolicy: {
                connectionPersistenceOnUnhealthyBackends: "Test string",
                enableStrongAffinity: true,
                idleTimeoutSec: 42,
                trackingMode: "Test string",
            },
            consistentHash: {
                httpCookie: {
                    name: "Test string",
                    path: "Test string",
                    ttl: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                },
                httpHeaderName: "Test string",
                minimumRingSize: "Test string",
            },
            creationTimestamp: "Test string",
            customRequestHeaders: [
                "Test string"
            ],
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCDN: true,
            failoverPolicy: {
                disableConnectionDrainOnFailover: true,
                dropTrafficIfUnhealthy: true,
                failoverRatio: 42,
            },
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            iap: {
                enabled: true,
                oauth2ClientId: "Test string",
                oauth2ClientSecret: "Test string",
                oauth2ClientSecretSha256: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            loadBalancingScheme: "Test string",
            localityLbPolicies: [
                {
                    customPolicy: {
                        data: "Test string",
                        name: "Test string",
                    },
                    policy: {
                        name: "Test string",
                    },
                }
            ],
            localityLbPolicy: "Test string",
            logConfig: {
                enable: true,
                optionalFields: [
                    "Test string"
                ],
                optionalMode: "Test string",
                sampleRate: 42,
            },
            maxStreamDuration: {
                nanos: 42,
                seconds: "Test string",
            },
            metadatas: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            outlierDetection: {
                baseEjectionTime: {
                    nanos: 42,
                    seconds: "Test string",
                },
                consecutiveErrors: 42,
                consecutiveGatewayFailure: 42,
                enforcingConsecutiveErrors: 42,
                enforcingConsecutiveGatewayFailure: 42,
                enforcingSuccessRate: 42,
                interval: {
                    nanos: 42,
                    seconds: "Test string",
                },
                maxEjectionPercent: 42,
                successRateMinimumHosts: 42,
                successRateRequestVolume: 42,
                successRateStdevFactor: 42,
            },
            port: 42,
            portName: "Test string",
            protocol: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            securitySettings: {
                clientTlsPolicy: "Test string",
                subjectAltNames: [
                    "Test string"
                ],
            },
            selfLink: "Test string",
            serviceBindings: [
                "Test string"
            ],
            sessionAffinity: "Test string",
            subsetting: {
                policy: "Test string",
            },
            timeoutSec: 42,
        });
        /** Adds existing resource policies to a disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation. */
        await gapi.client.compute.disks.addResourcePolicies({
            disk: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            resourcePolicies: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of persistent disks. */
        await gapi.client.compute.disks.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Bulk create a set of disks. */
        await gapi.client.compute.disks.bulkInsert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            sourceConsistencyGroupPolicy: "Test string",
        });
        /**
         * Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating
         * snapshots in a project different from the source disk project.
         */
        await gapi.client.compute.disks.createSnapshot({
            disk: "Test string",
            guestFlush: true,
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            architecture: "Test string",
            autoCreated: true,
            chainName: "Test string",
            creationSizeBytes: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            diskSizeGb: "Test string",
            downloadBytes: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            locationHint: "Test string",
            name: "Test string",
            satisfiesPzs: true,
            selfLink: "Test string",
            snapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            snapshotType: "Test string",
            sourceDisk: "Test string",
            sourceDiskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceDiskId: "Test string",
            sourceSnapshotSchedulePolicy: "Test string",
            sourceSnapshotSchedulePolicyId: "Test string",
            status: "Test string",
            storageBytes: "Test string",
            storageBytesStatus: "Test string",
            storageLocations: [
                "Test string"
            ],
        });
        /**
         * Deletes the specified persistent disk. Deleting a disk removes its data permanently and is irreversible. However, deleting a disk does not delete any snapshots previously made from the
         * disk. You must separately delete snapshots.
         */
        await gapi.client.compute.disks.delete({
            disk: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Returns the specified persistent disk. */
        await gapi.client.compute.disks.get({
            disk: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.disks.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        });
        /**
         * Creates a persistent disk in the specified project using the data in the request. You can create a disk from a source (sourceImage, sourceSnapshot, or sourceDisk) or create an empty 500
         * GB data disk by omitting all properties. You can also create a disk that is larger than the default size by specifying the sizeGb property.
         */
        await gapi.client.compute.disks.insert({
            project: "Test string",
            requestId: "Test string",
            sourceImage: "Test string",
            zone: "Test string",
        }, {
            architecture: "Test string",
            asyncPrimaryDisk: {
                consistencyGroupPolicy: "Test string",
                consistencyGroupPolicyId: "Test string",
                disk: "Test string",
                diskId: "Test string",
            },
            asyncSecondaryDisks: {
                A: {
                    asyncReplicationDisk: {
                        consistencyGroupPolicy: "Test string",
                        consistencyGroupPolicyId: "Test string",
                        disk: "Test string",
                        diskId: "Test string",
                    },
                }
            },
            creationTimestamp: "Test string",
            description: "Test string",
            diskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            guestOsFeatures: [
                {
                    type: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            lastAttachTimestamp: "Test string",
            lastDetachTimestamp: "Test string",
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            locationHint: "Test string",
            name: "Test string",
            options: "Test string",
            params: {
                resourceManagerTags: {
                    A: "Test string"
                },
            },
            physicalBlockSizeBytes: "Test string",
            provisionedIops: "Test string",
            provisionedThroughput: "Test string",
            region: "Test string",
            replicaZones: [
                "Test string"
            ],
            resourcePolicies: [
                "Test string"
            ],
            resourceStatus: {
                asyncPrimaryDisk: {
                    state: "Test string",
                },
                asyncSecondaryDisks: {
                    A: {
                        state: "Test string",
                    }
                },
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            sizeGb: "Test string",
            sourceConsistencyGroupPolicy: "Test string",
            sourceConsistencyGroupPolicyId: "Test string",
            sourceDisk: "Test string",
            sourceDiskId: "Test string",
            sourceImage: "Test string",
            sourceImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceImageId: "Test string",
            sourceSnapshot: "Test string",
            sourceSnapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceSnapshotId: "Test string",
            sourceStorageObject: "Test string",
            status: "Test string",
            type: "Test string",
            users: [
                "Test string"
            ],
            zone: "Test string",
        });
        /** Retrieves a list of persistent disks contained within the specified zone. */
        await gapi.client.compute.disks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Removes resource policies from a disk. */
        await gapi.client.compute.disks.removeResourcePolicies({
            disk: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            resourcePolicies: [
                "Test string"
            ],
        });
        /** Resizes the specified persistent disk. You can only increase the size of the disk. */
        await gapi.client.compute.disks.resize({
            disk: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            sizeGb: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.disks.setIamPolicy({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Sets the labels on a disk. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.disks.setLabels({
            project: "Test string",
            requestId: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Starts asynchronous replication. Must be invoked on the primary disk. */
        await gapi.client.compute.disks.startAsyncReplication({
            disk: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            asyncSecondaryDisk: "Test string",
        });
        /** Stops asynchronous replication. Can be invoked either on the primary or on the secondary disk. */
        await gapi.client.compute.disks.stopAsyncReplication({
            disk: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Stops asynchronous replication for a consistency group of disks. Can be invoked either in the primary or secondary scope. */
        await gapi.client.compute.disks.stopGroupAsyncReplication({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            resourcePolicy: "Test string",
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.disks.testIamPermissions({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /**
         * Updates the specified disk with the data included in the request. The update is performed only on selected fields included as part of update-mask. Only the following fields can be
         * modified: user_license.
         */
        await gapi.client.compute.disks.update({
            disk: "Test string",
            paths: "Test string",
            project: "Test string",
            requestId: "Test string",
            updateMask: "Test string",
            zone: "Test string",
        }, {
            architecture: "Test string",
            asyncPrimaryDisk: {
                consistencyGroupPolicy: "Test string",
                consistencyGroupPolicyId: "Test string",
                disk: "Test string",
                diskId: "Test string",
            },
            asyncSecondaryDisks: {
                A: {
                    asyncReplicationDisk: {
                        consistencyGroupPolicy: "Test string",
                        consistencyGroupPolicyId: "Test string",
                        disk: "Test string",
                        diskId: "Test string",
                    },
                }
            },
            creationTimestamp: "Test string",
            description: "Test string",
            diskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            guestOsFeatures: [
                {
                    type: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            lastAttachTimestamp: "Test string",
            lastDetachTimestamp: "Test string",
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            locationHint: "Test string",
            name: "Test string",
            options: "Test string",
            params: {
                resourceManagerTags: {
                    A: "Test string"
                },
            },
            physicalBlockSizeBytes: "Test string",
            provisionedIops: "Test string",
            provisionedThroughput: "Test string",
            region: "Test string",
            replicaZones: [
                "Test string"
            ],
            resourcePolicies: [
                "Test string"
            ],
            resourceStatus: {
                asyncPrimaryDisk: {
                    state: "Test string",
                },
                asyncSecondaryDisks: {
                    A: {
                        state: "Test string",
                    }
                },
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            sizeGb: "Test string",
            sourceConsistencyGroupPolicy: "Test string",
            sourceConsistencyGroupPolicyId: "Test string",
            sourceDisk: "Test string",
            sourceDiskId: "Test string",
            sourceImage: "Test string",
            sourceImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceImageId: "Test string",
            sourceSnapshot: "Test string",
            sourceSnapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceSnapshotId: "Test string",
            sourceStorageObject: "Test string",
            status: "Test string",
            type: "Test string",
            users: [
                "Test string"
            ],
            zone: "Test string",
        });
        /** Retrieves an aggregated list of disk types. */
        await gapi.client.compute.diskTypes.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Returns the specified disk type. */
        await gapi.client.compute.diskTypes.get({
            diskType: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of disk types available to the specified project. */
        await gapi.client.compute.diskTypes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Deletes the specified externalVpnGateway. */
        await gapi.client.compute.externalVpnGateways.delete({
            externalVpnGateway: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified externalVpnGateway. Get a list of available externalVpnGateways by making a list() request. */
        await gapi.client.compute.externalVpnGateways.get({
            externalVpnGateway: "Test string",
            project: "Test string",
        });
        /** Creates a ExternalVpnGateway in the specified project using the data included in the request. */
        await gapi.client.compute.externalVpnGateways.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            interfaces: [
                {
                    id: 42,
                    ipAddress: "Test string",
                }
            ],
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            redundancyType: "Test string",
            selfLink: "Test string",
        });
        /** Retrieves the list of ExternalVpnGateway available to the specified project. */
        await gapi.client.compute.externalVpnGateways.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the labels on an ExternalVpnGateway. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.externalVpnGateways.setLabels({
            project: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.externalVpnGateways.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Inserts an association for the specified firewall policy. */
        await gapi.client.compute.firewallPolicies.addAssociation({
            firewallPolicy: "Test string",
            replaceExistingAssociation: true,
            requestId: "Test string",
        }, {
            attachmentTarget: "Test string",
            displayName: "Test string",
            firewallPolicyId: "Test string",
            name: "Test string",
            shortName: "Test string",
        });
        /** Inserts a rule into a firewall policy. */
        await gapi.client.compute.firewallPolicies.addRule({
            firewallPolicy: "Test string",
            requestId: "Test string",
        }, {
            action: "Test string",
            description: "Test string",
            direction: "Test string",
            disabled: true,
            enableLogging: true,
            kind: "Test string",
            match: {
                destAddressGroups: [
                    "Test string"
                ],
                destFqdns: [
                    "Test string"
                ],
                destIpRanges: [
                    "Test string"
                ],
                destRegionCodes: [
                    "Test string"
                ],
                destThreatIntelligences: [
                    "Test string"
                ],
                layer4Configs: [
                    {
                        ipProtocol: "Test string",
                        ports: [
                            "Test string"
                        ],
                    }
                ],
                srcAddressGroups: [
                    "Test string"
                ],
                srcFqdns: [
                    "Test string"
                ],
                srcIpRanges: [
                    "Test string"
                ],
                srcRegionCodes: [
                    "Test string"
                ],
                srcSecureTags: [
                    {
                        name: "Test string",
                        state: "Test string",
                    }
                ],
                srcThreatIntelligences: [
                    "Test string"
                ],
            },
            priority: 42,
            ruleName: "Test string",
            ruleTupleCount: 42,
            targetResources: [
                "Test string"
            ],
            targetSecureTags: [
                {
                    name: "Test string",
                    state: "Test string",
                }
            ],
            targetServiceAccounts: [
                "Test string"
            ],
        });
        /** Copies rules to the specified firewall policy. */
        await gapi.client.compute.firewallPolicies.cloneRules({
            firewallPolicy: "Test string",
            requestId: "Test string",
            sourceFirewallPolicy: "Test string",
        });
        /** Deletes the specified policy. */
        await gapi.client.compute.firewallPolicies.delete({
            firewallPolicy: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified firewall policy. */
        await gapi.client.compute.firewallPolicies.get({
            firewallPolicy: "Test string",
        });
        /** Gets an association with the specified name. */
        await gapi.client.compute.firewallPolicies.getAssociation({
            firewallPolicy: "Test string",
            name: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.firewallPolicies.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            resource: "Test string",
        });
        /** Gets a rule of the specified priority. */
        await gapi.client.compute.firewallPolicies.getRule({
            firewallPolicy: "Test string",
            priority: 42,
        });
        /** Creates a new policy in the specified project using the data included in the request. */
        await gapi.client.compute.firewallPolicies.insert({
            parentId: "Test string",
            requestId: "Test string",
        }, {
            associations: [
                {
                    attachmentTarget: "Test string",
                    displayName: "Test string",
                    firewallPolicyId: "Test string",
                    name: "Test string",
                    shortName: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            displayName: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            parent: "Test string",
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    direction: "Test string",
                    disabled: true,
                    enableLogging: true,
                    kind: "Test string",
                    match: {
                        destAddressGroups: [
                            "Test string"
                        ],
                        destFqdns: [
                            "Test string"
                        ],
                        destIpRanges: [
                            "Test string"
                        ],
                        destRegionCodes: [
                            "Test string"
                        ],
                        destThreatIntelligences: [
                            "Test string"
                        ],
                        layer4Configs: [
                            {
                                ipProtocol: "Test string",
                                ports: [
                                    "Test string"
                                ],
                            }
                        ],
                        srcAddressGroups: [
                            "Test string"
                        ],
                        srcFqdns: [
                            "Test string"
                        ],
                        srcIpRanges: [
                            "Test string"
                        ],
                        srcRegionCodes: [
                            "Test string"
                        ],
                        srcSecureTags: [
                            {
                                name: "Test string",
                                state: "Test string",
                            }
                        ],
                        srcThreatIntelligences: [
                            "Test string"
                        ],
                    },
                    priority: 42,
                    ruleName: "Test string",
                    ruleTupleCount: 42,
                    targetResources: [
                        "Test string"
                    ],
                    targetSecureTags: [
                        {
                            name: "Test string",
                            state: "Test string",
                        }
                    ],
                    targetServiceAccounts: [
                        "Test string"
                    ],
                }
            ],
            ruleTupleCount: 42,
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            shortName: "Test string",
        });
        /** Lists all the policies that have been configured for the specified folder or organization. */
        await gapi.client.compute.firewallPolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            parentId: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists associations of a specified target, i.e., organization or folder. */
        await gapi.client.compute.firewallPolicies.listAssociations({
            targetResource: "Test string",
        });
        /** Moves the specified firewall policy. */
        await gapi.client.compute.firewallPolicies.move({
            firewallPolicy: "Test string",
            parentId: "Test string",
            requestId: "Test string",
        });
        /** Patches the specified policy with the data included in the request. */
        await gapi.client.compute.firewallPolicies.patch({
            firewallPolicy: "Test string",
            requestId: "Test string",
        }, {
            associations: [
                {
                    attachmentTarget: "Test string",
                    displayName: "Test string",
                    firewallPolicyId: "Test string",
                    name: "Test string",
                    shortName: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            displayName: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            parent: "Test string",
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    direction: "Test string",
                    disabled: true,
                    enableLogging: true,
                    kind: "Test string",
                    match: {
                        destAddressGroups: [
                            "Test string"
                        ],
                        destFqdns: [
                            "Test string"
                        ],
                        destIpRanges: [
                            "Test string"
                        ],
                        destRegionCodes: [
                            "Test string"
                        ],
                        destThreatIntelligences: [
                            "Test string"
                        ],
                        layer4Configs: [
                            {
                                ipProtocol: "Test string",
                                ports: [
                                    "Test string"
                                ],
                            }
                        ],
                        srcAddressGroups: [
                            "Test string"
                        ],
                        srcFqdns: [
                            "Test string"
                        ],
                        srcIpRanges: [
                            "Test string"
                        ],
                        srcRegionCodes: [
                            "Test string"
                        ],
                        srcSecureTags: [
                            {
                                name: "Test string",
                                state: "Test string",
                            }
                        ],
                        srcThreatIntelligences: [
                            "Test string"
                        ],
                    },
                    priority: 42,
                    ruleName: "Test string",
                    ruleTupleCount: 42,
                    targetResources: [
                        "Test string"
                    ],
                    targetSecureTags: [
                        {
                            name: "Test string",
                            state: "Test string",
                        }
                    ],
                    targetServiceAccounts: [
                        "Test string"
                    ],
                }
            ],
            ruleTupleCount: 42,
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            shortName: "Test string",
        });
        /** Patches a rule of the specified priority. */
        await gapi.client.compute.firewallPolicies.patchRule({
            firewallPolicy: "Test string",
            priority: 42,
            requestId: "Test string",
        }, {
            action: "Test string",
            description: "Test string",
            direction: "Test string",
            disabled: true,
            enableLogging: true,
            kind: "Test string",
            match: {
                destAddressGroups: [
                    "Test string"
                ],
                destFqdns: [
                    "Test string"
                ],
                destIpRanges: [
                    "Test string"
                ],
                destRegionCodes: [
                    "Test string"
                ],
                destThreatIntelligences: [
                    "Test string"
                ],
                layer4Configs: [
                    {
                        ipProtocol: "Test string",
                        ports: [
                            "Test string"
                        ],
                    }
                ],
                srcAddressGroups: [
                    "Test string"
                ],
                srcFqdns: [
                    "Test string"
                ],
                srcIpRanges: [
                    "Test string"
                ],
                srcRegionCodes: [
                    "Test string"
                ],
                srcSecureTags: [
                    {
                        name: "Test string",
                        state: "Test string",
                    }
                ],
                srcThreatIntelligences: [
                    "Test string"
                ],
            },
            priority: 42,
            ruleName: "Test string",
            ruleTupleCount: 42,
            targetResources: [
                "Test string"
            ],
            targetSecureTags: [
                {
                    name: "Test string",
                    state: "Test string",
                }
            ],
            targetServiceAccounts: [
                "Test string"
            ],
        });
        /** Removes an association for the specified firewall policy. */
        await gapi.client.compute.firewallPolicies.removeAssociation({
            firewallPolicy: "Test string",
            name: "Test string",
            requestId: "Test string",
        });
        /** Deletes a rule of the specified priority. */
        await gapi.client.compute.firewallPolicies.removeRule({
            firewallPolicy: "Test string",
            priority: 42,
            requestId: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.firewallPolicies.setIamPolicy({
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.firewallPolicies.testIamPermissions({
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Deletes the specified firewall. */
        await gapi.client.compute.firewalls.delete({
            firewall: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified firewall. */
        await gapi.client.compute.firewalls.get({
            firewall: "Test string",
            project: "Test string",
        });
        /** Creates a firewall rule in the specified project using the data included in the request. */
        await gapi.client.compute.firewalls.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            allowed: [
                {
                    IPProtocol: "Test string",
                    ports: [
                        "Test string"
                    ],
                }
            ],
            creationTimestamp: "Test string",
            denied: [
                {
                    IPProtocol: "Test string",
                    ports: [
                        "Test string"
                    ],
                }
            ],
            description: "Test string",
            destinationRanges: [
                "Test string"
            ],
            direction: "Test string",
            disabled: true,
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
                metadata: "Test string",
            },
            name: "Test string",
            network: "Test string",
            priority: 42,
            selfLink: "Test string",
            sourceRanges: [
                "Test string"
            ],
            sourceServiceAccounts: [
                "Test string"
            ],
            sourceTags: [
                "Test string"
            ],
            targetServiceAccounts: [
                "Test string"
            ],
            targetTags: [
                "Test string"
            ],
        });
        /** Retrieves the list of firewall rules available to the specified project. */
        await gapi.client.compute.firewalls.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Updates the specified firewall rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. */
        await gapi.client.compute.firewalls.patch({
            firewall: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            allowed: [
                {
                    IPProtocol: "Test string",
                    ports: [
                        "Test string"
                    ],
                }
            ],
            creationTimestamp: "Test string",
            denied: [
                {
                    IPProtocol: "Test string",
                    ports: [
                        "Test string"
                    ],
                }
            ],
            description: "Test string",
            destinationRanges: [
                "Test string"
            ],
            direction: "Test string",
            disabled: true,
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
                metadata: "Test string",
            },
            name: "Test string",
            network: "Test string",
            priority: 42,
            selfLink: "Test string",
            sourceRanges: [
                "Test string"
            ],
            sourceServiceAccounts: [
                "Test string"
            ],
            sourceTags: [
                "Test string"
            ],
            targetServiceAccounts: [
                "Test string"
            ],
            targetTags: [
                "Test string"
            ],
        });
        /**
         * Updates the specified firewall rule with the data included in the request. Note that all fields will be updated if using PUT, even fields that are not specified. To update individual
         * fields, please use PATCH instead.
         */
        await gapi.client.compute.firewalls.update({
            firewall: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            allowed: [
                {
                    IPProtocol: "Test string",
                    ports: [
                        "Test string"
                    ],
                }
            ],
            creationTimestamp: "Test string",
            denied: [
                {
                    IPProtocol: "Test string",
                    ports: [
                        "Test string"
                    ],
                }
            ],
            description: "Test string",
            destinationRanges: [
                "Test string"
            ],
            direction: "Test string",
            disabled: true,
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
                metadata: "Test string",
            },
            name: "Test string",
            network: "Test string",
            priority: 42,
            selfLink: "Test string",
            sourceRanges: [
                "Test string"
            ],
            sourceServiceAccounts: [
                "Test string"
            ],
            sourceTags: [
                "Test string"
            ],
            targetServiceAccounts: [
                "Test string"
            ],
            targetTags: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of forwarding rules. */
        await gapi.client.compute.forwardingRules.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified ForwardingRule resource. */
        await gapi.client.compute.forwardingRules.delete({
            forwardingRule: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified ForwardingRule resource. */
        await gapi.client.compute.forwardingRules.get({
            forwardingRule: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates a ForwardingRule resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.forwardingRules.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            allowGlobalAccess: true,
            allowPscGlobalAccess: true,
            allPorts: true,
            backendService: "Test string",
            baseForwardingRule: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            IPAddress: "Test string",
            IPProtocol: "Test string",
            ipVersion: "Test string",
            isMirroringCollector: true,
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            loadBalancingScheme: "Test string",
            metadataFilters: [
                {
                    filterLabels: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    filterMatchCriteria: "Test string",
                }
            ],
            name: "Test string",
            network: "Test string",
            networkTier: "Test string",
            noAutomateDnsZone: true,
            portRange: "Test string",
            ports: [
                "Test string"
            ],
            pscConnectionId: "Test string",
            pscConnectionStatus: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serviceDirectoryRegistrations: [
                {
                    namespace: "Test string",
                    service: "Test string",
                    serviceDirectoryRegion: "Test string",
                }
            ],
            serviceLabel: "Test string",
            serviceName: "Test string",
            sourceIpRanges: [
                "Test string"
            ],
            subnetwork: "Test string",
            target: "Test string",
        });
        /** Retrieves a list of ForwardingRule resources available to the specified project and region. */
        await gapi.client.compute.forwardingRules.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently,
         * you can only patch the network_tier field.
         */
        await gapi.client.compute.forwardingRules.patch({
            forwardingRule: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            allowGlobalAccess: true,
            allowPscGlobalAccess: true,
            allPorts: true,
            backendService: "Test string",
            baseForwardingRule: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            IPAddress: "Test string",
            IPProtocol: "Test string",
            ipVersion: "Test string",
            isMirroringCollector: true,
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            loadBalancingScheme: "Test string",
            metadataFilters: [
                {
                    filterLabels: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    filterMatchCriteria: "Test string",
                }
            ],
            name: "Test string",
            network: "Test string",
            networkTier: "Test string",
            noAutomateDnsZone: true,
            portRange: "Test string",
            ports: [
                "Test string"
            ],
            pscConnectionId: "Test string",
            pscConnectionStatus: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serviceDirectoryRegistrations: [
                {
                    namespace: "Test string",
                    service: "Test string",
                    serviceDirectoryRegion: "Test string",
                }
            ],
            serviceLabel: "Test string",
            serviceName: "Test string",
            sourceIpRanges: [
                "Test string"
            ],
            subnetwork: "Test string",
            target: "Test string",
        });
        /** Sets the labels on the specified resource. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.forwardingRules.setLabels({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Changes target URL for forwarding rule. The new target should be of the same type as the old target. */
        await gapi.client.compute.forwardingRules.setTarget({
            forwardingRule: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            target: "Test string",
        });
        /** Deletes the specified address resource. */
        await gapi.client.compute.globalAddresses.delete({
            address: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified address resource. */
        await gapi.client.compute.globalAddresses.get({
            address: "Test string",
            project: "Test string",
        });
        /** Creates an address resource in the specified project by using the data included in the request. */
        await gapi.client.compute.globalAddresses.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            address: "Test string",
            addressType: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            ipv6EndpointType: "Test string",
            ipVersion: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            networkTier: "Test string",
            prefixLength: 42,
            purpose: "Test string",
            region: "Test string",
            selfLink: "Test string",
            status: "Test string",
            subnetwork: "Test string",
            users: [
                "Test string"
            ],
        });
        /** Retrieves a list of global addresses. */
        await gapi.client.compute.globalAddresses.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Moves the specified address resource from one project to another project. */
        await gapi.client.compute.globalAddresses.move({
            address: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            description: "Test string",
            destinationAddress: "Test string",
        });
        /** Sets the labels on a GlobalAddress. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.globalAddresses.setLabels({
            project: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Deletes the specified GlobalForwardingRule resource. */
        await gapi.client.compute.globalForwardingRules.delete({
            forwardingRule: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified GlobalForwardingRule resource. Gets a list of available forwarding rules by making a list() request. */
        await gapi.client.compute.globalForwardingRules.get({
            forwardingRule: "Test string",
            project: "Test string",
        });
        /** Creates a GlobalForwardingRule resource in the specified project using the data included in the request. */
        await gapi.client.compute.globalForwardingRules.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            allowGlobalAccess: true,
            allowPscGlobalAccess: true,
            allPorts: true,
            backendService: "Test string",
            baseForwardingRule: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            IPAddress: "Test string",
            IPProtocol: "Test string",
            ipVersion: "Test string",
            isMirroringCollector: true,
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            loadBalancingScheme: "Test string",
            metadataFilters: [
                {
                    filterLabels: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    filterMatchCriteria: "Test string",
                }
            ],
            name: "Test string",
            network: "Test string",
            networkTier: "Test string",
            noAutomateDnsZone: true,
            portRange: "Test string",
            ports: [
                "Test string"
            ],
            pscConnectionId: "Test string",
            pscConnectionStatus: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serviceDirectoryRegistrations: [
                {
                    namespace: "Test string",
                    service: "Test string",
                    serviceDirectoryRegion: "Test string",
                }
            ],
            serviceLabel: "Test string",
            serviceName: "Test string",
            sourceIpRanges: [
                "Test string"
            ],
            subnetwork: "Test string",
            target: "Test string",
        });
        /** Retrieves a list of GlobalForwardingRule resources available to the specified project. */
        await gapi.client.compute.globalForwardingRules.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates the specified forwarding rule with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. Currently,
         * you can only patch the network_tier field.
         */
        await gapi.client.compute.globalForwardingRules.patch({
            forwardingRule: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            allowGlobalAccess: true,
            allowPscGlobalAccess: true,
            allPorts: true,
            backendService: "Test string",
            baseForwardingRule: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            IPAddress: "Test string",
            IPProtocol: "Test string",
            ipVersion: "Test string",
            isMirroringCollector: true,
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            loadBalancingScheme: "Test string",
            metadataFilters: [
                {
                    filterLabels: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    filterMatchCriteria: "Test string",
                }
            ],
            name: "Test string",
            network: "Test string",
            networkTier: "Test string",
            noAutomateDnsZone: true,
            portRange: "Test string",
            ports: [
                "Test string"
            ],
            pscConnectionId: "Test string",
            pscConnectionStatus: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serviceDirectoryRegistrations: [
                {
                    namespace: "Test string",
                    service: "Test string",
                    serviceDirectoryRegion: "Test string",
                }
            ],
            serviceLabel: "Test string",
            serviceName: "Test string",
            sourceIpRanges: [
                "Test string"
            ],
            subnetwork: "Test string",
            target: "Test string",
        });
        /** Sets the labels on the specified resource. To learn more about labels, read the Labeling resources documentation. */
        await gapi.client.compute.globalForwardingRules.setLabels({
            project: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Changes target URL for the GlobalForwardingRule resource. The new target should be of the same type as the old target. */
        await gapi.client.compute.globalForwardingRules.setTarget({
            forwardingRule: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            target: "Test string",
        });
        /** Attach a network endpoint to the specified network endpoint group. */
        await gapi.client.compute.globalNetworkEndpointGroups.attachNetworkEndpoints({
            networkEndpointGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            networkEndpoints: [
                {
                    annotations: {
                        A: "Test string"
                    },
                    fqdn: "Test string",
                    instance: "Test string",
                    ipAddress: "Test string",
                    port: 42,
                }
            ],
        });
        /** Deletes the specified network endpoint group.Note that the NEG cannot be deleted if there are backend services referencing it. */
        await gapi.client.compute.globalNetworkEndpointGroups.delete({
            networkEndpointGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Detach the network endpoint from the specified network endpoint group. */
        await gapi.client.compute.globalNetworkEndpointGroups.detachNetworkEndpoints({
            networkEndpointGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            networkEndpoints: [
                {
                    annotations: {
                        A: "Test string"
                    },
                    fqdn: "Test string",
                    instance: "Test string",
                    ipAddress: "Test string",
                    port: 42,
                }
            ],
        });
        /** Returns the specified network endpoint group. */
        await gapi.client.compute.globalNetworkEndpointGroups.get({
            networkEndpointGroup: "Test string",
            project: "Test string",
        });
        /** Creates a network endpoint group in the specified project using the parameters that are included in the request. */
        await gapi.client.compute.globalNetworkEndpointGroups.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            annotations: {
                A: "Test string"
            },
            appEngine: {
                service: "Test string",
                urlMask: "Test string",
                version: "Test string",
            },
            cloudFunction: {
                function: "Test string",
                urlMask: "Test string",
            },
            cloudRun: {
                service: "Test string",
                tag: "Test string",
                urlMask: "Test string",
            },
            creationTimestamp: "Test string",
            defaultPort: 42,
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            network: "Test string",
            networkEndpointType: "Test string",
            pscData: {
                consumerPscAddress: "Test string",
                pscConnectionId: "Test string",
                pscConnectionStatus: "Test string",
            },
            pscTargetService: "Test string",
            region: "Test string",
            selfLink: "Test string",
            size: 42,
            subnetwork: "Test string",
            zone: "Test string",
        });
        /** Retrieves the list of network endpoint groups that are located in the specified project. */
        await gapi.client.compute.globalNetworkEndpointGroups.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists the network endpoints in the specified network endpoint group. */
        await gapi.client.compute.globalNetworkEndpointGroups.listNetworkEndpoints({
            filter: "Test string",
            maxResults: 42,
            networkEndpointGroup: "Test string",
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Retrieves an aggregated list of all operations. */
        await gapi.client.compute.globalOperations.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified Operations resource. */
        await gapi.client.compute.globalOperations.delete({
            operation: "Test string",
            project: "Test string",
        });
        /** Retrieves the specified Operations resource. */
        await gapi.client.compute.globalOperations.get({
            operation: "Test string",
            project: "Test string",
        });
        /** Retrieves a list of Operation resources contained within the specified project. */
        await gapi.client.compute.globalOperations.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs
         * from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress.
         * This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might
         * return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation
         * is not `DONE`.
         */
        await gapi.client.compute.globalOperations.wait({
            operation: "Test string",
            project: "Test string",
        });
        /** Deletes the specified Operations resource. */
        await gapi.client.compute.globalOrganizationOperations.delete({
            operation: "Test string",
            parentId: "Test string",
        });
        /** Retrieves the specified Operations resource. Gets a list of operations by making a `list()` request. */
        await gapi.client.compute.globalOrganizationOperations.get({
            operation: "Test string",
            parentId: "Test string",
        });
        /** Retrieves a list of Operation resources contained within the specified organization. */
        await gapi.client.compute.globalOrganizationOperations.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            parentId: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified global PublicDelegatedPrefix. */
        await gapi.client.compute.globalPublicDelegatedPrefixes.delete({
            project: "Test string",
            publicDelegatedPrefix: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified global PublicDelegatedPrefix resource. */
        await gapi.client.compute.globalPublicDelegatedPrefixes.get({
            project: "Test string",
            publicDelegatedPrefix: "Test string",
        });
        /** Creates a global PublicDelegatedPrefix in the specified project using the parameters that are included in the request. */
        await gapi.client.compute.globalPublicDelegatedPrefixes.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            ipCidrRange: "Test string",
            isLiveMigration: true,
            kind: "Test string",
            name: "Test string",
            parentPrefix: "Test string",
            publicDelegatedSubPrefixs: [
                {
                    delegateeProject: "Test string",
                    description: "Test string",
                    ipCidrRange: "Test string",
                    isAddress: true,
                    name: "Test string",
                    region: "Test string",
                    status: "Test string",
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            status: "Test string",
        });
        /** Lists the global PublicDelegatedPrefixes for a project. */
        await gapi.client.compute.globalPublicDelegatedPrefixes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Patches the specified global PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing
         * rules.
         */
        await gapi.client.compute.globalPublicDelegatedPrefixes.patch({
            project: "Test string",
            publicDelegatedPrefix: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            ipCidrRange: "Test string",
            isLiveMigration: true,
            kind: "Test string",
            name: "Test string",
            parentPrefix: "Test string",
            publicDelegatedSubPrefixs: [
                {
                    delegateeProject: "Test string",
                    description: "Test string",
                    ipCidrRange: "Test string",
                    isAddress: true,
                    name: "Test string",
                    region: "Test string",
                    status: "Test string",
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            status: "Test string",
        });
        /** Retrieves the list of all HealthCheck resources, regional and global, available to the specified project. */
        await gapi.client.compute.healthChecks.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified HealthCheck resource. */
        await gapi.client.compute.healthChecks.delete({
            healthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified HealthCheck resource. */
        await gapi.client.compute.healthChecks.get({
            healthCheck: "Test string",
            project: "Test string",
        });
        /** Creates a HealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.healthChecks.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            grpcHealthCheck: {
                grpcServiceName: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
            },
            healthyThreshold: 42,
            http2HealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpsHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
            },
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
            sslHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            tcpHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            timeoutSec: 42,
            type: "Test string",
            unhealthyThreshold: 42,
        });
        /** Retrieves the list of HealthCheck resources available to the specified project. */
        await gapi.client.compute.healthChecks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing
         * rules.
         */
        await gapi.client.compute.healthChecks.patch({
            healthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            grpcHealthCheck: {
                grpcServiceName: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
            },
            healthyThreshold: 42,
            http2HealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpsHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
            },
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
            sslHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            tcpHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            timeoutSec: 42,
            type: "Test string",
            unhealthyThreshold: 42,
        });
        /** Updates a HealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.healthChecks.update({
            healthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            grpcHealthCheck: {
                grpcServiceName: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
            },
            healthyThreshold: 42,
            http2HealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpsHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
            },
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
            sslHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            tcpHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            timeoutSec: 42,
            type: "Test string",
            unhealthyThreshold: 42,
        });
        /** Deletes the specified HttpHealthCheck resource. */
        await gapi.client.compute.httpHealthChecks.delete({
            httpHealthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified HttpHealthCheck resource. */
        await gapi.client.compute.httpHealthChecks.get({
            httpHealthCheck: "Test string",
            project: "Test string",
        });
        /** Creates a HttpHealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.httpHealthChecks.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            healthyThreshold: 42,
            host: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            port: 42,
            requestPath: "Test string",
            selfLink: "Test string",
            timeoutSec: 42,
            unhealthyThreshold: 42,
        });
        /** Retrieves the list of HttpHealthCheck resources available to the specified project. */
        await gapi.client.compute.httpHealthChecks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates a HttpHealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and
         * processing rules.
         */
        await gapi.client.compute.httpHealthChecks.patch({
            httpHealthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            healthyThreshold: 42,
            host: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            port: 42,
            requestPath: "Test string",
            selfLink: "Test string",
            timeoutSec: 42,
            unhealthyThreshold: 42,
        });
        /** Updates a HttpHealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.httpHealthChecks.update({
            httpHealthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            healthyThreshold: 42,
            host: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            port: 42,
            requestPath: "Test string",
            selfLink: "Test string",
            timeoutSec: 42,
            unhealthyThreshold: 42,
        });
        /** Deletes the specified HttpsHealthCheck resource. */
        await gapi.client.compute.httpsHealthChecks.delete({
            httpsHealthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified HttpsHealthCheck resource. */
        await gapi.client.compute.httpsHealthChecks.get({
            httpsHealthCheck: "Test string",
            project: "Test string",
        });
        /** Creates a HttpsHealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.httpsHealthChecks.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            healthyThreshold: 42,
            host: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            port: 42,
            requestPath: "Test string",
            selfLink: "Test string",
            timeoutSec: 42,
            unhealthyThreshold: 42,
        });
        /** Retrieves the list of HttpsHealthCheck resources available to the specified project. */
        await gapi.client.compute.httpsHealthChecks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates a HttpsHealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and
         * processing rules.
         */
        await gapi.client.compute.httpsHealthChecks.patch({
            httpsHealthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            healthyThreshold: 42,
            host: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            port: 42,
            requestPath: "Test string",
            selfLink: "Test string",
            timeoutSec: 42,
            unhealthyThreshold: 42,
        });
        /** Updates a HttpsHealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.httpsHealthChecks.update({
            httpsHealthCheck: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            healthyThreshold: 42,
            host: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            port: 42,
            requestPath: "Test string",
            selfLink: "Test string",
            timeoutSec: 42,
            unhealthyThreshold: 42,
        });
        /** Returns the latest image that is part of an image family, is not deprecated and is rolled out in the specified zone. */
        await gapi.client.compute.imageFamilyViews.get({
            family: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Deletes the specified image. */
        await gapi.client.compute.images.delete({
            image: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Sets the deprecation status of an image. If an empty request body is given, clears the deprecation status instead. */
        await gapi.client.compute.images.deprecate({
            image: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            deleted: "Test string",
            deprecated: "Test string",
            obsolete: "Test string",
            replacement: "Test string",
            state: "Test string",
        });
        /** Returns the specified image. */
        await gapi.client.compute.images.get({
            image: "Test string",
            project: "Test string",
        });
        /** Returns the latest image that is part of an image family and is not deprecated. For more information on image families, see Public image families documentation. */
        await gapi.client.compute.images.getFromFamily({
            family: "Test string",
            project: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.images.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
        });
        /** Creates an image in the specified project using the data included in the request. */
        await gapi.client.compute.images.insert({
            forceCreate: true,
            project: "Test string",
            requestId: "Test string",
        }, {
            architecture: "Test string",
            archiveSizeBytes: "Test string",
            creationTimestamp: "Test string",
            deprecated: {
                deleted: "Test string",
                deprecated: "Test string",
                obsolete: "Test string",
                replacement: "Test string",
                state: "Test string",
            },
            description: "Test string",
            diskSizeGb: "Test string",
            family: "Test string",
            guestOsFeatures: [
                {
                    type: "Test string",
                }
            ],
            id: "Test string",
            imageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            name: "Test string",
            rawDisk: {
                containerType: "Test string",
                sha1Checksum: "Test string",
                source: "Test string",
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            shieldedInstanceInitialState: {
                dbs: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                dbxs: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                keks: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                pk: {
                    content: "Test string",
                    fileType: "Test string",
                },
            },
            sourceDisk: "Test string",
            sourceDiskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceDiskId: "Test string",
            sourceImage: "Test string",
            sourceImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceImageId: "Test string",
            sourceSnapshot: "Test string",
            sourceSnapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceSnapshotId: "Test string",
            sourceType: "Test string",
            status: "Test string",
            storageLocations: [
                "Test string"
            ],
        });
        /**
         * Retrieves the list of custom images available to the specified project. Custom images are images you create that belong to your project. This method does not get any images that belong
         * to other projects, including publicly-available images, like Debian 8. If you want to get a list of publicly-available images, use this method to make a request to the respective image
         * project, such as debian-cloud or windows-cloud.
         */
        await gapi.client.compute.images.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified image with the data included in the request. Only the following fields can be modified: family, description, deprecation status. */
        await gapi.client.compute.images.patch({
            image: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            architecture: "Test string",
            archiveSizeBytes: "Test string",
            creationTimestamp: "Test string",
            deprecated: {
                deleted: "Test string",
                deprecated: "Test string",
                obsolete: "Test string",
                replacement: "Test string",
                state: "Test string",
            },
            description: "Test string",
            diskSizeGb: "Test string",
            family: "Test string",
            guestOsFeatures: [
                {
                    type: "Test string",
                }
            ],
            id: "Test string",
            imageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            name: "Test string",
            rawDisk: {
                containerType: "Test string",
                sha1Checksum: "Test string",
                source: "Test string",
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            shieldedInstanceInitialState: {
                dbs: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                dbxs: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                keks: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                pk: {
                    content: "Test string",
                    fileType: "Test string",
                },
            },
            sourceDisk: "Test string",
            sourceDiskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceDiskId: "Test string",
            sourceImage: "Test string",
            sourceImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceImageId: "Test string",
            sourceSnapshot: "Test string",
            sourceSnapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceSnapshotId: "Test string",
            sourceType: "Test string",
            status: "Test string",
            storageLocations: [
                "Test string"
            ],
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.images.setIamPolicy({
            project: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Sets the labels on an image. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.images.setLabels({
            project: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.images.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /**
         * Flags the specified instances to be removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any target pools
         * that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation is marked as
         * DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the
         * listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has
         * elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
         */
        await gapi.client.compute.instanceGroupManagers.abandonInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            instances: [
                "Test string"
            ],
        });
        /** Retrieves the list of managed instance groups and groups them by zone. */
        await gapi.client.compute.instanceGroupManagers.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Applies changes to selected instances on the managed instance group. This method can be used to apply new overrides and/or new versions. */
        await gapi.client.compute.instanceGroupManagers.applyUpdatesToInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            zone: "Test string",
        }, {
            allInstances: true,
            instances: [
                "Test string"
            ],
            minimalAction: "Test string",
            mostDisruptiveAllowedAction: "Test string",
        });
        /**
         * Creates instances with per-instance configurations in this managed instance group. Instances are created using the current instance template. The create instances operation is marked
         * DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the
         * listmanagedinstances method.
         */
        await gapi.client.compute.instanceGroupManagers.createInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            instances: [
                {
                    fingerprint: "Test string",
                    name: "Test string",
                    preservedState: {
                        disks: {
                            A: {
                                autoDelete: "Test string",
                                mode: "Test string",
                                source: "Test string",
                            }
                        },
                        metadata: {
                            A: "Test string"
                        },
                    },
                    status: "Test string",
                }
            ],
        });
        /**
         * Deletes the specified managed instance group and all of the instances in that group. Note that the instance group must not belong to a backend service. Read Deleting an instance group
         * for more information.
         */
        await gapi.client.compute.instanceGroupManagers.delete({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /**
         * Flags the specified instances in the managed instance group for immediate deletion. The instances are also removed from any target pools of which they were a member. This method reduces
         * the targetSize of the managed instance group by the number of instances that you delete. This operation is marked as DONE when the action is scheduled even if the instances are still
         * being deleted. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a backend service that has enabled connection
         * draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with
         * this method per request.
         */
        await gapi.client.compute.instanceGroupManagers.deleteInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            instances: [
                "Test string"
            ],
            skipInstancesOnValidationError: true,
        });
        /** Deletes selected per-instance configurations for the managed instance group. */
        await gapi.client.compute.instanceGroupManagers.deletePerInstanceConfigs({
            instanceGroupManager: "Test string",
            project: "Test string",
            zone: "Test string",
        }, {
            names: [
                "Test string"
            ],
        });
        /** Returns all of the details about the specified managed instance group. */
        await gapi.client.compute.instanceGroupManagers.get({
            instanceGroupManager: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /**
         * Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance
         * template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the
         * individual instances with the listmanagedinstances method. A managed instance group can have up to 1000 VM instances per group. Please contact Cloud Support if you need an increase in
         * this limit.
         */
        await gapi.client.compute.instanceGroupManagers.insert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            autoHealingPolicies: [
                {
                    healthCheck: "Test string",
                    initialDelaySec: 42,
                }
            ],
            baseInstanceName: "Test string",
            creationTimestamp: "Test string",
            currentActions: {
                abandoning: 42,
                creating: 42,
                creatingWithoutRetries: 42,
                deleting: 42,
                none: 42,
                recreating: 42,
                refreshing: 42,
                restarting: 42,
                resuming: 42,
                starting: 42,
                stopping: 42,
                suspending: 42,
                verifying: 42,
            },
            description: "Test string",
            distributionPolicy: {
                targetShape: "Test string",
                zones: [
                    {
                        zone: "Test string",
                    }
                ],
            },
            fingerprint: "Test string",
            id: "Test string",
            instanceGroup: "Test string",
            instanceTemplate: "Test string",
            kind: "Test string",
            listManagedInstancesResults: "Test string",
            name: "Test string",
            namedPorts: [
                {
                    name: "Test string",
                    port: 42,
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            statefulPolicy: {
                preservedState: {
                    disks: {
                        A: {
                            autoDelete: "Test string",
                        }
                    },
                },
            },
            status: {
                autoscaler: "Test string",
                isStable: true,
                stateful: {
                    hasStatefulConfig: true,
                    perInstanceConfigs: {
                        allEffective: true,
                    },
                },
                versionTarget: {
                    isReached: true,
                },
            },
            targetPools: [
                "Test string"
            ],
            targetSize: 42,
            updatePolicy: {
                instanceRedistributionType: "Test string",
                maxSurge: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                maxUnavailable: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                minimalAction: "Test string",
                mostDisruptiveAllowedAction: "Test string",
                replacementMethod: "Test string",
                type: "Test string",
            },
            versions: [
                {
                    instanceTemplate: "Test string",
                    name: "Test string",
                    targetSize: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                }
            ],
            zone: "Test string",
        });
        /** Retrieves a list of managed instance groups that are contained within the specified project and zone. */
        await gapi.client.compute.instanceGroupManagers.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Lists all errors thrown by actions on instances for a given managed instance group. The filter and orderBy query parameters are not supported. */
        await gapi.client.compute.instanceGroupManagers.listErrors({
            filter: "Test string",
            instanceGroupManager: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /**
         * Lists all of the instances in the managed instance group. Each instance in the list has a currentAction, which indicates the action that the managed instance group is performing on the
         * instance. For example, if the group is still creating an instance, the currentAction is CREATING. If a previous action failed, the list displays the errors for that failed action. The
         * orderBy query parameter is not supported. The `pageToken` query parameter is supported only in the alpha and beta API and only if the group's `listManagedInstancesResults` field is set
         * to `PAGINATED`.
         */
        await gapi.client.compute.instanceGroupManagers.listManagedInstances({
            filter: "Test string",
            instanceGroupManager: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported. */
        await gapi.client.compute.instanceGroupManagers.listPerInstanceConfigs({
            filter: "Test string",
            instanceGroupManager: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /**
         * Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are
         * still in the process of being patched. You must separately verify the status of the individual instances with the listManagedInstances method. This method supports PATCH semantics and
         * uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for
         * each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG.
         */
        await gapi.client.compute.instanceGroupManagers.patch({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            autoHealingPolicies: [
                {
                    healthCheck: "Test string",
                    initialDelaySec: 42,
                }
            ],
            baseInstanceName: "Test string",
            creationTimestamp: "Test string",
            currentActions: {
                abandoning: 42,
                creating: 42,
                creatingWithoutRetries: 42,
                deleting: 42,
                none: 42,
                recreating: 42,
                refreshing: 42,
                restarting: 42,
                resuming: 42,
                starting: 42,
                stopping: 42,
                suspending: 42,
                verifying: 42,
            },
            description: "Test string",
            distributionPolicy: {
                targetShape: "Test string",
                zones: [
                    {
                        zone: "Test string",
                    }
                ],
            },
            fingerprint: "Test string",
            id: "Test string",
            instanceGroup: "Test string",
            instanceTemplate: "Test string",
            kind: "Test string",
            listManagedInstancesResults: "Test string",
            name: "Test string",
            namedPorts: [
                {
                    name: "Test string",
                    port: 42,
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            statefulPolicy: {
                preservedState: {
                    disks: {
                        A: {
                            autoDelete: "Test string",
                        }
                    },
                },
            },
            status: {
                autoscaler: "Test string",
                isStable: true,
                stateful: {
                    hasStatefulConfig: true,
                    perInstanceConfigs: {
                        allEffective: true,
                    },
                },
                versionTarget: {
                    isReached: true,
                },
            },
            targetPools: [
                "Test string"
            ],
            targetSize: 42,
            updatePolicy: {
                instanceRedistributionType: "Test string",
                maxSurge: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                maxUnavailable: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                minimalAction: "Test string",
                mostDisruptiveAllowedAction: "Test string",
                replacementMethod: "Test string",
                type: "Test string",
            },
            versions: [
                {
                    instanceTemplate: "Test string",
                    name: "Test string",
                    targetSize: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                }
            ],
            zone: "Test string",
        });
        /** Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. */
        await gapi.client.compute.instanceGroupManagers.patchPerInstanceConfigs({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            perInstanceConfigs: [
                {
                    fingerprint: "Test string",
                    name: "Test string",
                    preservedState: {
                        disks: {
                            A: {
                                autoDelete: "Test string",
                                mode: "Test string",
                                source: "Test string",
                            }
                        },
                        metadata: {
                            A: "Test string"
                        },
                    },
                    status: "Test string",
                }
            ],
        });
        /**
         * Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked
         * as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more
         * information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the
         * connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
         */
        await gapi.client.compute.instanceGroupManagers.recreateInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            instances: [
                "Test string"
            ],
        });
        /**
         * Resizes the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the group deletes instances.
         * The resize operation is marked DONE when the resize actions are scheduled even if the group has not yet added or deleted any instances. You must separately verify the status of the
         * creating or deleting actions with the listmanagedinstances method. When resizing down, the instance group arbitrarily chooses the order in which VMs are deleted. The group takes into
         * account some VM attributes when making the selection including: + The status of the VM instance. + The health of the VM instance. + The instance template version the VM is based on. +
         * For regional managed instance groups, the location of the VM instance. This list is subject to change. If the group is part of a backend service that has enabled connection draining, it
         * can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted.
         */
        await gapi.client.compute.instanceGroupManagers.resize({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            size: 42,
            zone: "Test string",
        });
        /**
         * Specifies the instance template to use when creating new instances in this group. The templates for existing instances in the group do not change unless you run recreateInstances, run
         * applyUpdatesToInstances, or set the group's updatePolicy.type to PROACTIVE.
         */
        await gapi.client.compute.instanceGroupManagers.setInstanceTemplate({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            instanceTemplate: "Test string",
        });
        /**
         * Modifies the target pools to which all instances in this managed instance group are assigned. The target pools automatically apply to all of the instances in the managed instance group.
         * This operation is marked DONE when you make the request even if the instances have not yet been added to their target pools. The change might take some time to apply to all of the
         * instances in the group depending on the size of the group.
         */
        await gapi.client.compute.instanceGroupManagers.setTargetPools({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            fingerprint: "Test string",
            targetPools: [
                "Test string"
            ],
        });
        /** Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. */
        await gapi.client.compute.instanceGroupManagers.updatePerInstanceConfigs({
            instanceGroupManager: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            perInstanceConfigs: [
                {
                    fingerprint: "Test string",
                    name: "Test string",
                    preservedState: {
                        disks: {
                            A: {
                                autoDelete: "Test string",
                                mode: "Test string",
                                source: "Test string",
                            }
                        },
                        metadata: {
                            A: "Test string"
                        },
                    },
                    status: "Test string",
                }
            ],
        });
        /** Adds a list of instances to the specified instance group. All of the instances in the instance group must be in the same network/subnetwork. Read Adding instances for more information. */
        await gapi.client.compute.instanceGroups.addInstances({
            instanceGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            instances: [
                {
                    instance: "Test string",
                }
            ],
        });
        /** Retrieves the list of instance groups and sorts them by zone. */
        await gapi.client.compute.instanceGroups.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Deletes the specified instance group. The instances in the group are not deleted. Note that instance group must not belong to a backend service. Read Deleting an instance group for more
         * information.
         */
        await gapi.client.compute.instanceGroups.delete({
            instanceGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /**
         * Returns the specified zonal instance group. Get a list of available zonal instance groups by making a list() request. For managed instance groups, use the instanceGroupManagers or
         * regionInstanceGroupManagers methods instead.
         */
        await gapi.client.compute.instanceGroups.get({
            instanceGroup: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Creates an instance group in the specified project using the parameters that are included in the request. */
        await gapi.client.compute.instanceGroups.insert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            namedPorts: [
                {
                    name: "Test string",
                    port: 42,
                }
            ],
            network: "Test string",
            region: "Test string",
            selfLink: "Test string",
            size: 42,
            subnetwork: "Test string",
            zone: "Test string",
        });
        /**
         * Retrieves the list of zonal instance group resources contained within the specified zone. For managed instance groups, use the instanceGroupManagers or regionInstanceGroupManagers
         * methods instead.
         */
        await gapi.client.compute.instanceGroups.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /**
         * Lists the instances in the specified instance group. The orderBy query parameter is not supported. The filter query parameter is supported, but only for expressions that use `eq`
         * (equal) or `ne` (not equal) operators.
         */
        await gapi.client.compute.instanceGroups.listInstances({
            filter: "Test string",
            instanceGroup: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        }, {
            instanceState: "Test string",
        });
        /**
         * Removes one or more instances from the specified instance group, but does not delete those instances. If the group is part of a backend service that has enabled connection draining, it
         * can take up to 60 seconds after the connection draining duration before the VM instance is removed or deleted.
         */
        await gapi.client.compute.instanceGroups.removeInstances({
            instanceGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            instances: [
                {
                    instance: "Test string",
                }
            ],
        });
        /** Sets the named ports for the specified instance group. */
        await gapi.client.compute.instanceGroups.setNamedPorts({
            instanceGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            fingerprint: "Test string",
            namedPorts: [
                {
                    name: "Test string",
                    port: 42,
                }
            ],
        });
        /** Adds an access config to an instance's network interface. */
        await gapi.client.compute.instances.addAccessConfig({
            instance: "Test string",
            networkInterface: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            externalIpv6: "Test string",
            externalIpv6PrefixLength: 42,
            kind: "Test string",
            name: "Test string",
            natIP: "Test string",
            networkTier: "Test string",
            publicPtrDomainName: "Test string",
            setPublicPtr: true,
            type: "Test string",
        });
        /** Adds existing resource policies to an instance. You can only add one policy right now which will be applied to this instance for scheduling live migrations. */
        await gapi.client.compute.instances.addResourcePolicies({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            resourcePolicies: [
                "Test string"
            ],
        });
        /**
         * Retrieves an aggregated list of all of the instances in your project across all regions and zones. The performance of this method degrades when a filter is specified on a project that
         * has a very large number of instances.
         */
        await gapi.client.compute.instances.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Attaches an existing Disk resource to an instance. You must first create the disk before you can attach it. It is not possible to create and attach a disk at the same time. For more
         * information, read Adding a persistent disk to your instance.
         */
        await gapi.client.compute.instances.attachDisk({
            forceAttach: true,
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            architecture: "Test string",
            autoDelete: true,
            boot: true,
            deviceName: "Test string",
            diskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            diskSizeGb: "Test string",
            forceAttach: true,
            guestOsFeatures: [
                {
                    type: "Test string",
                }
            ],
            index: 42,
            initializeParams: {
                architecture: "Test string",
                description: "Test string",
                diskName: "Test string",
                diskSizeGb: "Test string",
                diskType: "Test string",
                labels: {
                    A: "Test string"
                },
                licenses: [
                    "Test string"
                ],
                onUpdateAction: "Test string",
                provisionedIops: "Test string",
                provisionedThroughput: "Test string",
                replicaZones: [
                    "Test string"
                ],
                resourceManagerTags: {
                    A: "Test string"
                },
                resourcePolicies: [
                    "Test string"
                ],
                sourceImage: "Test string",
                sourceImageEncryptionKey: {
                    kmsKeyName: "Test string",
                    kmsKeyServiceAccount: "Test string",
                    rawKey: "Test string",
                    rsaEncryptedKey: "Test string",
                    sha256: "Test string",
                },
                sourceSnapshot: "Test string",
                sourceSnapshotEncryptionKey: {
                    kmsKeyName: "Test string",
                    kmsKeyServiceAccount: "Test string",
                    rawKey: "Test string",
                    rsaEncryptedKey: "Test string",
                    sha256: "Test string",
                },
            },
            interface: "Test string",
            kind: "Test string",
            licenses: [
                "Test string"
            ],
            mode: "Test string",
            savedState: "Test string",
            shieldedInstanceInitialState: {
                dbs: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                dbxs: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                keks: [
                    {
                        content: "Test string",
                        fileType: "Test string",
                    }
                ],
                pk: {
                    content: "Test string",
                    fileType: "Test string",
                },
            },
            source: "Test string",
            type: "Test string",
        });
        /** Creates multiple instances. Count specifies the number of instances to create. For more information, see About bulk creation of VMs. */
        await gapi.client.compute.instances.bulkInsert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            count: "Test string",
            instanceProperties: {
                advancedMachineFeatures: {
                    enableNestedVirtualization: true,
                    enableUefiNetworking: true,
                    threadsPerCore: 42,
                    visibleCoreCount: 42,
                },
                canIpForward: true,
                confidentialInstanceConfig: {
                    enableConfidentialCompute: true,
                },
                description: "Test string",
                disks: [
                    {
                        architecture: "Test string",
                        autoDelete: true,
                        boot: true,
                        deviceName: "Test string",
                        diskEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        diskSizeGb: "Test string",
                        forceAttach: true,
                        guestOsFeatures: [
                            {
                                type: "Test string",
                            }
                        ],
                        index: 42,
                        initializeParams: {
                            architecture: "Test string",
                            description: "Test string",
                            diskName: "Test string",
                            diskSizeGb: "Test string",
                            diskType: "Test string",
                            labels: {
                                A: "Test string"
                            },
                            licenses: [
                                "Test string"
                            ],
                            onUpdateAction: "Test string",
                            provisionedIops: "Test string",
                            provisionedThroughput: "Test string",
                            replicaZones: [
                                "Test string"
                            ],
                            resourceManagerTags: {
                                A: "Test string"
                            },
                            resourcePolicies: [
                                "Test string"
                            ],
                            sourceImage: "Test string",
                            sourceImageEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                            sourceSnapshot: "Test string",
                            sourceSnapshotEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                        },
                        interface: "Test string",
                        kind: "Test string",
                        licenses: [
                            "Test string"
                        ],
                        mode: "Test string",
                        savedState: "Test string",
                        shieldedInstanceInitialState: {
                            dbs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            dbxs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            keks: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            pk: {
                                content: "Test string",
                                fileType: "Test string",
                            },
                        },
                        source: "Test string",
                        type: "Test string",
                    }
                ],
                guestAccelerators: [
                    {
                        acceleratorCount: 42,
                        acceleratorType: "Test string",
                    }
                ],
                keyRevocationActionType: "Test string",
                labels: {
                    A: "Test string"
                },
                machineType: "Test string",
                metadata: {
                    fingerprint: "Test string",
                    items: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    kind: "Test string",
                },
                minCpuPlatform: "Test string",
                networkInterfaces: [
                    {
                        accessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        aliasIpRanges: [
                            {
                                ipCidrRange: "Test string",
                                subnetworkRangeName: "Test string",
                            }
                        ],
                        fingerprint: "Test string",
                        internalIpv6PrefixLength: 42,
                        ipv6AccessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        ipv6AccessType: "Test string",
                        ipv6Address: "Test string",
                        kind: "Test string",
                        name: "Test string",
                        network: "Test string",
                        networkAttachment: "Test string",
                        networkIP: "Test string",
                        nicType: "Test string",
                        queueCount: 42,
                        stackType: "Test string",
                        subnetwork: "Test string",
                    }
                ],
                networkPerformanceConfig: {
                    totalEgressBandwidthTier: "Test string",
                },
                privateIpv6GoogleAccess: "Test string",
                reservationAffinity: {
                    consumeReservationType: "Test string",
                    key: "Test string",
                    values: [
                        "Test string"
                    ],
                },
                resourceManagerTags: {
                    A: "Test string"
                },
                resourcePolicies: [
                    "Test string"
                ],
                scheduling: {
                    automaticRestart: true,
                    instanceTerminationAction: "Test string",
                    locationHint: "Test string",
                    minNodeCpus: 42,
                    nodeAffinities: [
                        {
                            key: "Test string",
                            operator: "Test string",
                            values: [
                                "Test string"
                            ],
                        }
                    ],
                    onHostMaintenance: "Test string",
                    preemptible: true,
                    provisioningModel: "Test string",
                },
                serviceAccounts: [
                    {
                        email: "Test string",
                        scopes: [
                            "Test string"
                        ],
                    }
                ],
                shieldedInstanceConfig: {
                    enableIntegrityMonitoring: true,
                    enableSecureBoot: true,
                    enableVtpm: true,
                },
                tags: {
                    fingerprint: "Test string",
                    items: [
                        "Test string"
                    ],
                },
            },
            locationPolicy: {
                locations: {
                    A: {
                        constraints: {
                            maxCount: 42,
                        },
                        preference: "Test string",
                    }
                },
                targetShape: "Test string",
            },
            minCount: "Test string",
            namePattern: "Test string",
            perInstanceProperties: {
                A: {
                    name: "Test string",
                }
            },
            sourceInstanceTemplate: "Test string",
        });
        /** Deletes the specified Instance resource. For more information, see Deleting an instance. */
        await gapi.client.compute.instances.delete({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Deletes an access config from an instance's network interface. */
        await gapi.client.compute.instances.deleteAccessConfig({
            accessConfig: "Test string",
            instance: "Test string",
            networkInterface: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Detaches a disk from an instance. */
        await gapi.client.compute.instances.detachDisk({
            deviceName: "Test string",
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Returns the specified Instance resource. */
        await gapi.client.compute.instances.get({
            instance: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Returns effective firewalls applied to an interface of the instance. */
        await gapi.client.compute.instances.getEffectiveFirewalls({
            instance: "Test string",
            networkInterface: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Returns the specified guest attributes entry. */
        await gapi.client.compute.instances.getGuestAttributes({
            instance: "Test string",
            project: "Test string",
            queryPath: "Test string",
            variableKey: "Test string",
            zone: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.instances.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        });
        /** Returns the screenshot from the specified instance. */
        await gapi.client.compute.instances.getScreenshot({
            instance: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Returns the last 1 MB of serial port output from the specified instance. */
        await gapi.client.compute.instances.getSerialPortOutput({
            instance: "Test string",
            port: 42,
            project: "Test string",
            start: "Test string",
            zone: "Test string",
        });
        /** Returns the Shielded Instance Identity of an instance */
        await gapi.client.compute.instances.getShieldedInstanceIdentity({
            instance: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Creates an instance resource in the specified project using the data included in the request. */
        await gapi.client.compute.instances.insert({
            project: "Test string",
            requestId: "Test string",
            sourceInstanceTemplate: "Test string",
            sourceMachineImage: "Test string",
            zone: "Test string",
        }, {
            advancedMachineFeatures: {
                enableNestedVirtualization: true,
                enableUefiNetworking: true,
                threadsPerCore: 42,
                visibleCoreCount: 42,
            },
            canIpForward: true,
            confidentialInstanceConfig: {
                enableConfidentialCompute: true,
            },
            cpuPlatform: "Test string",
            creationTimestamp: "Test string",
            deletionProtection: true,
            description: "Test string",
            disks: [
                {
                    architecture: "Test string",
                    autoDelete: true,
                    boot: true,
                    deviceName: "Test string",
                    diskEncryptionKey: {
                        kmsKeyName: "Test string",
                        kmsKeyServiceAccount: "Test string",
                        rawKey: "Test string",
                        rsaEncryptedKey: "Test string",
                        sha256: "Test string",
                    },
                    diskSizeGb: "Test string",
                    forceAttach: true,
                    guestOsFeatures: [
                        {
                            type: "Test string",
                        }
                    ],
                    index: 42,
                    initializeParams: {
                        architecture: "Test string",
                        description: "Test string",
                        diskName: "Test string",
                        diskSizeGb: "Test string",
                        diskType: "Test string",
                        labels: {
                            A: "Test string"
                        },
                        licenses: [
                            "Test string"
                        ],
                        onUpdateAction: "Test string",
                        provisionedIops: "Test string",
                        provisionedThroughput: "Test string",
                        replicaZones: [
                            "Test string"
                        ],
                        resourceManagerTags: {
                            A: "Test string"
                        },
                        resourcePolicies: [
                            "Test string"
                        ],
                        sourceImage: "Test string",
                        sourceImageEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        sourceSnapshot: "Test string",
                        sourceSnapshotEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                    },
                    interface: "Test string",
                    kind: "Test string",
                    licenses: [
                        "Test string"
                    ],
                    mode: "Test string",
                    savedState: "Test string",
                    shieldedInstanceInitialState: {
                        dbs: [
                            {
                                content: "Test string",
                                fileType: "Test string",
                            }
                        ],
                        dbxs: [
                            {
                                content: "Test string",
                                fileType: "Test string",
                            }
                        ],
                        keks: [
                            {
                                content: "Test string",
                                fileType: "Test string",
                            }
                        ],
                        pk: {
                            content: "Test string",
                            fileType: "Test string",
                        },
                    },
                    source: "Test string",
                    type: "Test string",
                }
            ],
            displayDevice: {
                enableDisplay: true,
            },
            fingerprint: "Test string",
            guestAccelerators: [
                {
                    acceleratorCount: 42,
                    acceleratorType: "Test string",
                }
            ],
            hostname: "Test string",
            id: "Test string",
            instanceEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            keyRevocationActionType: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            lastStartTimestamp: "Test string",
            lastStopTimestamp: "Test string",
            lastSuspendedTimestamp: "Test string",
            machineType: "Test string",
            metadata: {
                fingerprint: "Test string",
                items: [
                    {
                        key: "Test string",
                        value: "Test string",
                    }
                ],
                kind: "Test string",
            },
            minCpuPlatform: "Test string",
            name: "Test string",
            networkInterfaces: [
                {
                    accessConfigs: [
                        {
                            externalIpv6: "Test string",
                            externalIpv6PrefixLength: 42,
                            kind: "Test string",
                            name: "Test string",
                            natIP: "Test string",
                            networkTier: "Test string",
                            publicPtrDomainName: "Test string",
                            setPublicPtr: true,
                            type: "Test string",
                        }
                    ],
                    aliasIpRanges: [
                        {
                            ipCidrRange: "Test string",
                            subnetworkRangeName: "Test string",
                        }
                    ],
                    fingerprint: "Test string",
                    internalIpv6PrefixLength: 42,
                    ipv6AccessConfigs: [
                        {
                            externalIpv6: "Test string",
                            externalIpv6PrefixLength: 42,
                            kind: "Test string",
                            name: "Test string",
                            natIP: "Test string",
                            networkTier: "Test string",
                            publicPtrDomainName: "Test string",
                            setPublicPtr: true,
                            type: "Test string",
                        }
                    ],
                    ipv6AccessType: "Test string",
                    ipv6Address: "Test string",
                    kind: "Test string",
                    name: "Test string",
                    network: "Test string",
                    networkAttachment: "Test string",
                    networkIP: "Test string",
                    nicType: "Test string",
                    queueCount: 42,
                    stackType: "Test string",
                    subnetwork: "Test string",
                }
            ],
            networkPerformanceConfig: {
                totalEgressBandwidthTier: "Test string",
            },
            params: {
                resourceManagerTags: {
                    A: "Test string"
                },
            },
            privateIpv6GoogleAccess: "Test string",
            reservationAffinity: {
                consumeReservationType: "Test string",
                key: "Test string",
                values: [
                    "Test string"
                ],
            },
            resourcePolicies: [
                "Test string"
            ],
            resourceStatus: {
                physicalHost: "Test string",
            },
            satisfiesPzs: true,
            scheduling: {
                automaticRestart: true,
                instanceTerminationAction: "Test string",
                locationHint: "Test string",
                minNodeCpus: 42,
                nodeAffinities: [
                    {
                        key: "Test string",
                        operator: "Test string",
                        values: [
                            "Test string"
                        ],
                    }
                ],
                onHostMaintenance: "Test string",
                preemptible: true,
                provisioningModel: "Test string",
            },
            selfLink: "Test string",
            serviceAccounts: [
                {
                    email: "Test string",
                    scopes: [
                        "Test string"
                    ],
                }
            ],
            shieldedInstanceConfig: {
                enableIntegrityMonitoring: true,
                enableSecureBoot: true,
                enableVtpm: true,
            },
            shieldedInstanceIntegrityPolicy: {
                updateAutoLearnPolicy: true,
            },
            sourceMachineImage: "Test string",
            sourceMachineImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            startRestricted: true,
            status: "Test string",
            statusMessage: "Test string",
            tags: {
                fingerprint: "Test string",
                items: [
                    "Test string"
                ],
            },
            zone: "Test string",
        });
        /** Retrieves the list of instances contained within the specified zone. */
        await gapi.client.compute.instances.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /**
         * Retrieves a list of resources that refer to the VM instance specified in the request. For example, if the VM instance is part of a managed or unmanaged instance group, the referrers
         * list includes the instance group. For more information, read Viewing referrers to VM instances.
         */
        await gapi.client.compute.instances.listReferrers({
            filter: "Test string",
            instance: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Removes resource policies from an instance. */
        await gapi.client.compute.instances.removeResourcePolicies({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            resourcePolicies: [
                "Test string"
            ],
        });
        /** Performs a reset on the instance. This is a hard reset. The VM does not do a graceful shutdown. For more information, see Resetting an instance. */
        await gapi.client.compute.instances.reset({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Resumes an instance that was suspended using the instances().suspend method. */
        await gapi.client.compute.instances.resume({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Sends diagnostic interrupt to the instance. */
        await gapi.client.compute.instances.sendDiagnosticInterrupt({
            instance: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Sets deletion protection on the instance. */
        await gapi.client.compute.instances.setDeletionProtection({
            deletionProtection: true,
            project: "Test string",
            requestId: "Test string",
            resource: "Test string",
            zone: "Test string",
        });
        /** Sets the auto-delete flag for a disk attached to an instance. */
        await gapi.client.compute.instances.setDiskAutoDelete({
            autoDelete: true,
            deviceName: "Test string",
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.instances.setIamPolicy({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Sets labels on an instance. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.instances.setLabels({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Changes the number and/or type of accelerator for a stopped instance to the values specified in the request. */
        await gapi.client.compute.instances.setMachineResources({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            guestAccelerators: [
                {
                    acceleratorCount: 42,
                    acceleratorType: "Test string",
                }
            ],
        });
        /** Changes the machine type for a stopped instance to the machine type specified in the request. */
        await gapi.client.compute.instances.setMachineType({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            machineType: "Test string",
        });
        /** Sets metadata for the specified instance to the data included in the request. */
        await gapi.client.compute.instances.setMetadata({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            fingerprint: "Test string",
            items: [
                {
                    key: "Test string",
                    value: "Test string",
                }
            ],
            kind: "Test string",
        });
        /** Changes the minimum CPU platform that this instance should use. This method can only be called on a stopped instance. For more information, read Specifying a Minimum CPU Platform. */
        await gapi.client.compute.instances.setMinCpuPlatform({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            minCpuPlatform: "Test string",
        });
        /** Sets name of an instance. */
        await gapi.client.compute.instances.setName({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            currentName: "Test string",
            name: "Test string",
        });
        /**
         * Sets an instance's scheduling options. You can only call this method on a stopped instance, that is, a VM instance that is in a `TERMINATED` state. See Instance Life Cycle for more
         * information on the possible instance states. For more information about setting scheduling options for a VM, see Set VM host maintenance policy.
         */
        await gapi.client.compute.instances.setScheduling({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            automaticRestart: true,
            instanceTerminationAction: "Test string",
            locationHint: "Test string",
            minNodeCpus: 42,
            nodeAffinities: [
                {
                    key: "Test string",
                    operator: "Test string",
                    values: [
                        "Test string"
                    ],
                }
            ],
            onHostMaintenance: "Test string",
            preemptible: true,
            provisioningModel: "Test string",
        });
        /** Sets the service account on the instance. For more information, read Changing the service account and access scopes for an instance. */
        await gapi.client.compute.instances.setServiceAccount({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            email: "Test string",
            scopes: [
                "Test string"
            ],
        });
        /**
         * Sets the Shielded Instance integrity policy for an instance. You can only use this method on a running instance. This method supports PATCH semantics and uses the JSON merge patch
         * format and processing rules.
         */
        await gapi.client.compute.instances.setShieldedInstanceIntegrityPolicy({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            updateAutoLearnPolicy: true,
        });
        /** Sets network tags for the specified instance to the data included in the request. */
        await gapi.client.compute.instances.setTags({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            fingerprint: "Test string",
            items: [
                "Test string"
            ],
        });
        /** Simulates a host maintenance event on a VM. For more information, see Simulate a host maintenance event. */
        await gapi.client.compute.instances.simulateMaintenanceEvent({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance. */
        await gapi.client.compute.instances.start({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Starts an instance that was stopped using the instances().stop method. For more information, see Restart an instance. */
        await gapi.client.compute.instances.startWithEncryptionKey({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            disks: [
                {
                    diskEncryptionKey: {
                        kmsKeyName: "Test string",
                        kmsKeyServiceAccount: "Test string",
                        rawKey: "Test string",
                        rsaEncryptedKey: "Test string",
                        sha256: "Test string",
                    },
                    source: "Test string",
                }
            ],
        });
        /**
         * Stops a running instance, shutting it down cleanly, and allows you to restart the instance at a later time. Stopped instances do not incur VM usage charges while they are stopped.
         * However, resources that the VM is using, such as persistent disks and static IP addresses, will continue to be charged until they are deleted. For more information, see Stopping an
         * instance.
         */
        await gapi.client.compute.instances.stop({
            discardLocalSsd: true,
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /**
         * This method suspends a running instance, saving its state to persistent storage, and allows you to resume the instance at a later time. Suspended instances have no compute costs (cores
         * or RAM), and incur only storage charges for the saved VM memory and localSSD data. Any charged resources the virtual machine was using, such as persistent disks and static IP addresses,
         * will continue to be charged while the instance is suspended. For more information, see Suspending and resuming an instance.
         */
        await gapi.client.compute.instances.suspend({
            discardLocalSsd: true,
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.instances.testIamPermissions({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /**
         * Updates an instance only if the necessary resources are available. This method can update only a specific set of instance properties. See Updating a running instance for a list of
         * updatable instance properties.
         */
        await gapi.client.compute.instances.update({
            instance: "Test string",
            minimalAction: "Test string",
            mostDisruptiveAllowedAction: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            advancedMachineFeatures: {
                enableNestedVirtualization: true,
                enableUefiNetworking: true,
                threadsPerCore: 42,
                visibleCoreCount: 42,
            },
            canIpForward: true,
            confidentialInstanceConfig: {
                enableConfidentialCompute: true,
            },
            cpuPlatform: "Test string",
            creationTimestamp: "Test string",
            deletionProtection: true,
            description: "Test string",
            disks: [
                {
                    architecture: "Test string",
                    autoDelete: true,
                    boot: true,
                    deviceName: "Test string",
                    diskEncryptionKey: {
                        kmsKeyName: "Test string",
                        kmsKeyServiceAccount: "Test string",
                        rawKey: "Test string",
                        rsaEncryptedKey: "Test string",
                        sha256: "Test string",
                    },
                    diskSizeGb: "Test string",
                    forceAttach: true,
                    guestOsFeatures: [
                        {
                            type: "Test string",
                        }
                    ],
                    index: 42,
                    initializeParams: {
                        architecture: "Test string",
                        description: "Test string",
                        diskName: "Test string",
                        diskSizeGb: "Test string",
                        diskType: "Test string",
                        labels: {
                            A: "Test string"
                        },
                        licenses: [
                            "Test string"
                        ],
                        onUpdateAction: "Test string",
                        provisionedIops: "Test string",
                        provisionedThroughput: "Test string",
                        replicaZones: [
                            "Test string"
                        ],
                        resourceManagerTags: {
                            A: "Test string"
                        },
                        resourcePolicies: [
                            "Test string"
                        ],
                        sourceImage: "Test string",
                        sourceImageEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        sourceSnapshot: "Test string",
                        sourceSnapshotEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                    },
                    interface: "Test string",
                    kind: "Test string",
                    licenses: [
                        "Test string"
                    ],
                    mode: "Test string",
                    savedState: "Test string",
                    shieldedInstanceInitialState: {
                        dbs: [
                            {
                                content: "Test string",
                                fileType: "Test string",
                            }
                        ],
                        dbxs: [
                            {
                                content: "Test string",
                                fileType: "Test string",
                            }
                        ],
                        keks: [
                            {
                                content: "Test string",
                                fileType: "Test string",
                            }
                        ],
                        pk: {
                            content: "Test string",
                            fileType: "Test string",
                        },
                    },
                    source: "Test string",
                    type: "Test string",
                }
            ],
            displayDevice: {
                enableDisplay: true,
            },
            fingerprint: "Test string",
            guestAccelerators: [
                {
                    acceleratorCount: 42,
                    acceleratorType: "Test string",
                }
            ],
            hostname: "Test string",
            id: "Test string",
            instanceEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            keyRevocationActionType: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            lastStartTimestamp: "Test string",
            lastStopTimestamp: "Test string",
            lastSuspendedTimestamp: "Test string",
            machineType: "Test string",
            metadata: {
                fingerprint: "Test string",
                items: [
                    {
                        key: "Test string",
                        value: "Test string",
                    }
                ],
                kind: "Test string",
            },
            minCpuPlatform: "Test string",
            name: "Test string",
            networkInterfaces: [
                {
                    accessConfigs: [
                        {
                            externalIpv6: "Test string",
                            externalIpv6PrefixLength: 42,
                            kind: "Test string",
                            name: "Test string",
                            natIP: "Test string",
                            networkTier: "Test string",
                            publicPtrDomainName: "Test string",
                            setPublicPtr: true,
                            type: "Test string",
                        }
                    ],
                    aliasIpRanges: [
                        {
                            ipCidrRange: "Test string",
                            subnetworkRangeName: "Test string",
                        }
                    ],
                    fingerprint: "Test string",
                    internalIpv6PrefixLength: 42,
                    ipv6AccessConfigs: [
                        {
                            externalIpv6: "Test string",
                            externalIpv6PrefixLength: 42,
                            kind: "Test string",
                            name: "Test string",
                            natIP: "Test string",
                            networkTier: "Test string",
                            publicPtrDomainName: "Test string",
                            setPublicPtr: true,
                            type: "Test string",
                        }
                    ],
                    ipv6AccessType: "Test string",
                    ipv6Address: "Test string",
                    kind: "Test string",
                    name: "Test string",
                    network: "Test string",
                    networkAttachment: "Test string",
                    networkIP: "Test string",
                    nicType: "Test string",
                    queueCount: 42,
                    stackType: "Test string",
                    subnetwork: "Test string",
                }
            ],
            networkPerformanceConfig: {
                totalEgressBandwidthTier: "Test string",
            },
            params: {
                resourceManagerTags: {
                    A: "Test string"
                },
            },
            privateIpv6GoogleAccess: "Test string",
            reservationAffinity: {
                consumeReservationType: "Test string",
                key: "Test string",
                values: [
                    "Test string"
                ],
            },
            resourcePolicies: [
                "Test string"
            ],
            resourceStatus: {
                physicalHost: "Test string",
            },
            satisfiesPzs: true,
            scheduling: {
                automaticRestart: true,
                instanceTerminationAction: "Test string",
                locationHint: "Test string",
                minNodeCpus: 42,
                nodeAffinities: [
                    {
                        key: "Test string",
                        operator: "Test string",
                        values: [
                            "Test string"
                        ],
                    }
                ],
                onHostMaintenance: "Test string",
                preemptible: true,
                provisioningModel: "Test string",
            },
            selfLink: "Test string",
            serviceAccounts: [
                {
                    email: "Test string",
                    scopes: [
                        "Test string"
                    ],
                }
            ],
            shieldedInstanceConfig: {
                enableIntegrityMonitoring: true,
                enableSecureBoot: true,
                enableVtpm: true,
            },
            shieldedInstanceIntegrityPolicy: {
                updateAutoLearnPolicy: true,
            },
            sourceMachineImage: "Test string",
            sourceMachineImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            startRestricted: true,
            status: "Test string",
            statusMessage: "Test string",
            tags: {
                fingerprint: "Test string",
                items: [
                    "Test string"
                ],
            },
            zone: "Test string",
        });
        /**
         * Updates the specified access config from an instance's network interface with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format
         * and processing rules.
         */
        await gapi.client.compute.instances.updateAccessConfig({
            instance: "Test string",
            networkInterface: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            externalIpv6: "Test string",
            externalIpv6PrefixLength: 42,
            kind: "Test string",
            name: "Test string",
            natIP: "Test string",
            networkTier: "Test string",
            publicPtrDomainName: "Test string",
            setPublicPtr: true,
            type: "Test string",
        });
        /**
         * Updates the Display config for a VM instance. You can only use this method on a stopped VM instance. This method supports PATCH semantics and uses the JSON merge patch format and
         * processing rules.
         */
        await gapi.client.compute.instances.updateDisplayDevice({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            enableDisplay: true,
        });
        /**
         * Updates an instance's network interface. This method can only update an interface's alias IP range and attached network. See Modifying alias IP ranges for an existing instance for
         * instructions on changing alias IP ranges. See Migrating a VM between networks for instructions on migrating an interface. This method follows PATCH semantics.
         */
        await gapi.client.compute.instances.updateNetworkInterface({
            instance: "Test string",
            networkInterface: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            accessConfigs: [
                {
                    externalIpv6: "Test string",
                    externalIpv6PrefixLength: 42,
                    kind: "Test string",
                    name: "Test string",
                    natIP: "Test string",
                    networkTier: "Test string",
                    publicPtrDomainName: "Test string",
                    setPublicPtr: true,
                    type: "Test string",
                }
            ],
            aliasIpRanges: [
                {
                    ipCidrRange: "Test string",
                    subnetworkRangeName: "Test string",
                }
            ],
            fingerprint: "Test string",
            internalIpv6PrefixLength: 42,
            ipv6AccessConfigs: [
                {
                    externalIpv6: "Test string",
                    externalIpv6PrefixLength: 42,
                    kind: "Test string",
                    name: "Test string",
                    natIP: "Test string",
                    networkTier: "Test string",
                    publicPtrDomainName: "Test string",
                    setPublicPtr: true,
                    type: "Test string",
                }
            ],
            ipv6AccessType: "Test string",
            ipv6Address: "Test string",
            kind: "Test string",
            name: "Test string",
            network: "Test string",
            networkAttachment: "Test string",
            networkIP: "Test string",
            nicType: "Test string",
            queueCount: 42,
            stackType: "Test string",
            subnetwork: "Test string",
        });
        /**
         * Updates the Shielded Instance config for an instance. You can only use this method on a stopped instance. This method supports PATCH semantics and uses the JSON merge patch format and
         * processing rules.
         */
        await gapi.client.compute.instances.updateShieldedInstanceConfig({
            instance: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            enableIntegrityMonitoring: true,
            enableSecureBoot: true,
            enableVtpm: true,
        });
        /** Retrieves the list of all InstanceTemplates resources, regional and global, available to the specified project. */
        await gapi.client.compute.instanceTemplates.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Deletes the specified instance template. Deleting an instance template is permanent and cannot be undone. It is not possible to delete templates that are already in use by a managed
         * instance group.
         */
        await gapi.client.compute.instanceTemplates.delete({
            instanceTemplate: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified instance template. */
        await gapi.client.compute.instanceTemplates.get({
            instanceTemplate: "Test string",
            project: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.instanceTemplates.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
        });
        /**
         * Creates an instance template in the specified project using the data that is included in the request. If you are creating a new template to update an existing instance group, your new
         * instance template must use the same network or, if applicable, the same subnetwork as the original template.
         */
        await gapi.client.compute.instanceTemplates.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            properties: {
                advancedMachineFeatures: {
                    enableNestedVirtualization: true,
                    enableUefiNetworking: true,
                    threadsPerCore: 42,
                    visibleCoreCount: 42,
                },
                canIpForward: true,
                confidentialInstanceConfig: {
                    enableConfidentialCompute: true,
                },
                description: "Test string",
                disks: [
                    {
                        architecture: "Test string",
                        autoDelete: true,
                        boot: true,
                        deviceName: "Test string",
                        diskEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        diskSizeGb: "Test string",
                        forceAttach: true,
                        guestOsFeatures: [
                            {
                                type: "Test string",
                            }
                        ],
                        index: 42,
                        initializeParams: {
                            architecture: "Test string",
                            description: "Test string",
                            diskName: "Test string",
                            diskSizeGb: "Test string",
                            diskType: "Test string",
                            labels: {
                                A: "Test string"
                            },
                            licenses: [
                                "Test string"
                            ],
                            onUpdateAction: "Test string",
                            provisionedIops: "Test string",
                            provisionedThroughput: "Test string",
                            replicaZones: [
                                "Test string"
                            ],
                            resourceManagerTags: {
                                A: "Test string"
                            },
                            resourcePolicies: [
                                "Test string"
                            ],
                            sourceImage: "Test string",
                            sourceImageEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                            sourceSnapshot: "Test string",
                            sourceSnapshotEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                        },
                        interface: "Test string",
                        kind: "Test string",
                        licenses: [
                            "Test string"
                        ],
                        mode: "Test string",
                        savedState: "Test string",
                        shieldedInstanceInitialState: {
                            dbs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            dbxs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            keks: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            pk: {
                                content: "Test string",
                                fileType: "Test string",
                            },
                        },
                        source: "Test string",
                        type: "Test string",
                    }
                ],
                guestAccelerators: [
                    {
                        acceleratorCount: 42,
                        acceleratorType: "Test string",
                    }
                ],
                keyRevocationActionType: "Test string",
                labels: {
                    A: "Test string"
                },
                machineType: "Test string",
                metadata: {
                    fingerprint: "Test string",
                    items: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    kind: "Test string",
                },
                minCpuPlatform: "Test string",
                networkInterfaces: [
                    {
                        accessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        aliasIpRanges: [
                            {
                                ipCidrRange: "Test string",
                                subnetworkRangeName: "Test string",
                            }
                        ],
                        fingerprint: "Test string",
                        internalIpv6PrefixLength: 42,
                        ipv6AccessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        ipv6AccessType: "Test string",
                        ipv6Address: "Test string",
                        kind: "Test string",
                        name: "Test string",
                        network: "Test string",
                        networkAttachment: "Test string",
                        networkIP: "Test string",
                        nicType: "Test string",
                        queueCount: 42,
                        stackType: "Test string",
                        subnetwork: "Test string",
                    }
                ],
                networkPerformanceConfig: {
                    totalEgressBandwidthTier: "Test string",
                },
                privateIpv6GoogleAccess: "Test string",
                reservationAffinity: {
                    consumeReservationType: "Test string",
                    key: "Test string",
                    values: [
                        "Test string"
                    ],
                },
                resourceManagerTags: {
                    A: "Test string"
                },
                resourcePolicies: [
                    "Test string"
                ],
                scheduling: {
                    automaticRestart: true,
                    instanceTerminationAction: "Test string",
                    locationHint: "Test string",
                    minNodeCpus: 42,
                    nodeAffinities: [
                        {
                            key: "Test string",
                            operator: "Test string",
                            values: [
                                "Test string"
                            ],
                        }
                    ],
                    onHostMaintenance: "Test string",
                    preemptible: true,
                    provisioningModel: "Test string",
                },
                serviceAccounts: [
                    {
                        email: "Test string",
                        scopes: [
                            "Test string"
                        ],
                    }
                ],
                shieldedInstanceConfig: {
                    enableIntegrityMonitoring: true,
                    enableSecureBoot: true,
                    enableVtpm: true,
                },
                tags: {
                    fingerprint: "Test string",
                    items: [
                        "Test string"
                    ],
                },
            },
            region: "Test string",
            selfLink: "Test string",
            sourceInstance: "Test string",
            sourceInstanceParams: {
                diskConfigs: [
                    {
                        autoDelete: true,
                        customImage: "Test string",
                        deviceName: "Test string",
                        instantiateFrom: "Test string",
                    }
                ],
            },
        });
        /** Retrieves a list of instance templates that are contained within the specified project. */
        await gapi.client.compute.instanceTemplates.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.instanceTemplates.setIamPolicy({
            project: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.instanceTemplates.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of interconnect attachments. */
        await gapi.client.compute.interconnectAttachments.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified interconnect attachment. */
        await gapi.client.compute.interconnectAttachments.delete({
            interconnectAttachment: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified interconnect attachment. */
        await gapi.client.compute.interconnectAttachments.get({
            interconnectAttachment: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates an InterconnectAttachment in the specified project using the data included in the request. */
        await gapi.client.compute.interconnectAttachments.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            validateOnly: true,
        }, {
            adminEnabled: true,
            bandwidth: "Test string",
            candidateIpv6Subnets: [
                "Test string"
            ],
            candidateSubnets: [
                "Test string"
            ],
            cloudRouterIpAddress: "Test string",
            cloudRouterIpv6Address: "Test string",
            cloudRouterIpv6InterfaceId: "Test string",
            configurationConstraints: {
                bgpMd5: "Test string",
                bgpPeerAsnRanges: [
                    {
                        max: 42,
                        min: 42,
                    }
                ],
            },
            creationTimestamp: "Test string",
            customerRouterIpAddress: "Test string",
            customerRouterIpv6Address: "Test string",
            customerRouterIpv6InterfaceId: "Test string",
            dataplaneVersion: 42,
            description: "Test string",
            edgeAvailabilityDomain: "Test string",
            encryption: "Test string",
            googleReferenceId: "Test string",
            id: "Test string",
            interconnect: "Test string",
            ipsecInternalAddresses: [
                "Test string"
            ],
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            mtu: 42,
            name: "Test string",
            operationalStatus: "Test string",
            pairingKey: "Test string",
            partnerAsn: "Test string",
            partnerMetadata: {
                interconnectName: "Test string",
                partnerName: "Test string",
                portalUrl: "Test string",
            },
            privateInterconnectInfo: {
                tag8021q: 42,
            },
            region: "Test string",
            remoteService: "Test string",
            router: "Test string",
            satisfiesPzs: true,
            selfLink: "Test string",
            stackType: "Test string",
            state: "Test string",
            subnetLength: 42,
            type: "Test string",
            vlanTag8021q: 42,
        });
        /** Retrieves the list of interconnect attachments contained within the specified region. */
        await gapi.client.compute.interconnectAttachments.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Updates the specified interconnect attachment with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. */
        await gapi.client.compute.interconnectAttachments.patch({
            interconnectAttachment: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            adminEnabled: true,
            bandwidth: "Test string",
            candidateIpv6Subnets: [
                "Test string"
            ],
            candidateSubnets: [
                "Test string"
            ],
            cloudRouterIpAddress: "Test string",
            cloudRouterIpv6Address: "Test string",
            cloudRouterIpv6InterfaceId: "Test string",
            configurationConstraints: {
                bgpMd5: "Test string",
                bgpPeerAsnRanges: [
                    {
                        max: 42,
                        min: 42,
                    }
                ],
            },
            creationTimestamp: "Test string",
            customerRouterIpAddress: "Test string",
            customerRouterIpv6Address: "Test string",
            customerRouterIpv6InterfaceId: "Test string",
            dataplaneVersion: 42,
            description: "Test string",
            edgeAvailabilityDomain: "Test string",
            encryption: "Test string",
            googleReferenceId: "Test string",
            id: "Test string",
            interconnect: "Test string",
            ipsecInternalAddresses: [
                "Test string"
            ],
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            mtu: 42,
            name: "Test string",
            operationalStatus: "Test string",
            pairingKey: "Test string",
            partnerAsn: "Test string",
            partnerMetadata: {
                interconnectName: "Test string",
                partnerName: "Test string",
                portalUrl: "Test string",
            },
            privateInterconnectInfo: {
                tag8021q: 42,
            },
            region: "Test string",
            remoteService: "Test string",
            router: "Test string",
            satisfiesPzs: true,
            selfLink: "Test string",
            stackType: "Test string",
            state: "Test string",
            subnetLength: 42,
            type: "Test string",
            vlanTag8021q: 42,
        });
        /** Sets the labels on an InterconnectAttachment. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.interconnectAttachments.setLabels({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Returns the details for the specified interconnect location. Gets a list of available interconnect locations by making a list() request. */
        await gapi.client.compute.interconnectLocations.get({
            interconnectLocation: "Test string",
            project: "Test string",
        });
        /** Retrieves the list of interconnect locations available to the specified project. */
        await gapi.client.compute.interconnectLocations.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Returns the details for the specified interconnect remote location. Gets a list of available interconnect remote locations by making a list() request. */
        await gapi.client.compute.interconnectRemoteLocations.get({
            interconnectRemoteLocation: "Test string",
            project: "Test string",
        });
        /** Retrieves the list of interconnect remote locations available to the specified project. */
        await gapi.client.compute.interconnectRemoteLocations.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified Interconnect. */
        await gapi.client.compute.interconnects.delete({
            interconnect: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified Interconnect. Get a list of available Interconnects by making a list() request. */
        await gapi.client.compute.interconnects.get({
            interconnect: "Test string",
            project: "Test string",
        });
        /** Returns the interconnectDiagnostics for the specified Interconnect. */
        await gapi.client.compute.interconnects.getDiagnostics({
            interconnect: "Test string",
            project: "Test string",
        });
        /** Creates an Interconnect in the specified project using the data included in the request. */
        await gapi.client.compute.interconnects.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            adminEnabled: true,
            circuitInfos: [
                {
                    customerDemarcId: "Test string",
                    googleCircuitId: "Test string",
                    googleDemarcId: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            customerName: "Test string",
            description: "Test string",
            expectedOutages: [
                {
                    affectedCircuits: [
                        "Test string"
                    ],
                    description: "Test string",
                    endTime: "Test string",
                    issueType: "Test string",
                    name: "Test string",
                    source: "Test string",
                    startTime: "Test string",
                    state: "Test string",
                }
            ],
            googleIpAddress: "Test string",
            googleReferenceId: "Test string",
            id: "Test string",
            interconnectAttachments: [
                "Test string"
            ],
            interconnectType: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            linkType: "Test string",
            location: "Test string",
            name: "Test string",
            nocContactEmail: "Test string",
            operationalStatus: "Test string",
            peerIpAddress: "Test string",
            provisionedLinkCount: 42,
            remoteLocation: "Test string",
            requestedLinkCount: 42,
            satisfiesPzs: true,
            selfLink: "Test string",
            state: "Test string",
        });
        /** Retrieves the list of Interconnects available to the specified project. */
        await gapi.client.compute.interconnects.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Updates the specified Interconnect with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. */
        await gapi.client.compute.interconnects.patch({
            interconnect: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            adminEnabled: true,
            circuitInfos: [
                {
                    customerDemarcId: "Test string",
                    googleCircuitId: "Test string",
                    googleDemarcId: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            customerName: "Test string",
            description: "Test string",
            expectedOutages: [
                {
                    affectedCircuits: [
                        "Test string"
                    ],
                    description: "Test string",
                    endTime: "Test string",
                    issueType: "Test string",
                    name: "Test string",
                    source: "Test string",
                    startTime: "Test string",
                    state: "Test string",
                }
            ],
            googleIpAddress: "Test string",
            googleReferenceId: "Test string",
            id: "Test string",
            interconnectAttachments: [
                "Test string"
            ],
            interconnectType: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            linkType: "Test string",
            location: "Test string",
            name: "Test string",
            nocContactEmail: "Test string",
            operationalStatus: "Test string",
            peerIpAddress: "Test string",
            provisionedLinkCount: 42,
            remoteLocation: "Test string",
            requestedLinkCount: 42,
            satisfiesPzs: true,
            selfLink: "Test string",
            state: "Test string",
        });
        /** Sets the labels on an Interconnect. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.interconnects.setLabels({
            project: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /**
         * Return a specified license code. License codes are mirrored across all projects that have permissions to read the License Code. *Caution* This resource is intended for use only by
         * third-party partners who are creating Cloud Marketplace images.
         */
        await gapi.client.compute.licenseCodes.get({
            licenseCode: "Test string",
            project: "Test string",
        });
        /** Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images. */
        await gapi.client.compute.licenseCodes.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Deletes the specified license. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images. */
        await gapi.client.compute.licenses.delete({
            license: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified License resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images. */
        await gapi.client.compute.licenses.get({
            license: "Test string",
            project: "Test string",
        });
        /**
         * Gets the access control policy for a resource. May be empty if no such policy or resource exists. *Caution* This resource is intended for use only by third-party partners who are
         * creating Cloud Marketplace images.
         */
        await gapi.client.compute.licenses.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
        });
        /** Create a License resource in the specified project. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images. */
        await gapi.client.compute.licenses.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            chargesUseFee: true,
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            licenseCode: "Test string",
            name: "Test string",
            resourceRequirements: {
                minGuestCpuCount: 42,
                minMemoryMb: 42,
            },
            selfLink: "Test string",
            transferable: true,
        });
        /**
         * Retrieves the list of licenses available in the specified project. This method does not get any licenses that belong to other projects, including licenses attached to publicly-available
         * images, like Debian 9. If you want to get a list of publicly-available licenses, use this method to make a request to the respective image project, such as debian-cloud or
         * windows-cloud. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images.
         */
        await gapi.client.compute.licenses.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Sets the access control policy on the specified resource. Replaces any existing policy. *Caution* This resource is intended for use only by third-party partners who are creating Cloud
         * Marketplace images.
         */
        await gapi.client.compute.licenses.setIamPolicy({
            project: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. *Caution* This resource is intended for use only by third-party partners who are creating Cloud Marketplace images. */
        await gapi.client.compute.licenses.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Deletes the specified machine image. Deleting a machine image is permanent and cannot be undone. */
        await gapi.client.compute.machineImages.delete({
            machineImage: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified machine image. */
        await gapi.client.compute.machineImages.get({
            machineImage: "Test string",
            project: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.machineImages.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
        });
        /**
         * Creates a machine image in the specified project using the data that is included in the request. If you are creating a new machine image to update an existing instance, your new machine
         * image should use the same network or, if applicable, the same subnetwork as the original instance.
         */
        await gapi.client.compute.machineImages.insert({
            project: "Test string",
            requestId: "Test string",
            sourceInstance: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            guestFlush: true,
            id: "Test string",
            instanceProperties: {
                advancedMachineFeatures: {
                    enableNestedVirtualization: true,
                    enableUefiNetworking: true,
                    threadsPerCore: 42,
                    visibleCoreCount: 42,
                },
                canIpForward: true,
                confidentialInstanceConfig: {
                    enableConfidentialCompute: true,
                },
                description: "Test string",
                disks: [
                    {
                        architecture: "Test string",
                        autoDelete: true,
                        boot: true,
                        deviceName: "Test string",
                        diskEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        diskSizeGb: "Test string",
                        forceAttach: true,
                        guestOsFeatures: [
                            {
                                type: "Test string",
                            }
                        ],
                        index: 42,
                        initializeParams: {
                            architecture: "Test string",
                            description: "Test string",
                            diskName: "Test string",
                            diskSizeGb: "Test string",
                            diskType: "Test string",
                            labels: {
                                A: "Test string"
                            },
                            licenses: [
                                "Test string"
                            ],
                            onUpdateAction: "Test string",
                            provisionedIops: "Test string",
                            provisionedThroughput: "Test string",
                            replicaZones: [
                                "Test string"
                            ],
                            resourceManagerTags: {
                                A: "Test string"
                            },
                            resourcePolicies: [
                                "Test string"
                            ],
                            sourceImage: "Test string",
                            sourceImageEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                            sourceSnapshot: "Test string",
                            sourceSnapshotEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                        },
                        interface: "Test string",
                        kind: "Test string",
                        licenses: [
                            "Test string"
                        ],
                        mode: "Test string",
                        savedState: "Test string",
                        shieldedInstanceInitialState: {
                            dbs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            dbxs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            keks: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            pk: {
                                content: "Test string",
                                fileType: "Test string",
                            },
                        },
                        source: "Test string",
                        type: "Test string",
                    }
                ],
                guestAccelerators: [
                    {
                        acceleratorCount: 42,
                        acceleratorType: "Test string",
                    }
                ],
                keyRevocationActionType: "Test string",
                labels: {
                    A: "Test string"
                },
                machineType: "Test string",
                metadata: {
                    fingerprint: "Test string",
                    items: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    kind: "Test string",
                },
                minCpuPlatform: "Test string",
                networkInterfaces: [
                    {
                        accessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        aliasIpRanges: [
                            {
                                ipCidrRange: "Test string",
                                subnetworkRangeName: "Test string",
                            }
                        ],
                        fingerprint: "Test string",
                        internalIpv6PrefixLength: 42,
                        ipv6AccessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        ipv6AccessType: "Test string",
                        ipv6Address: "Test string",
                        kind: "Test string",
                        name: "Test string",
                        network: "Test string",
                        networkAttachment: "Test string",
                        networkIP: "Test string",
                        nicType: "Test string",
                        queueCount: 42,
                        stackType: "Test string",
                        subnetwork: "Test string",
                    }
                ],
                networkPerformanceConfig: {
                    totalEgressBandwidthTier: "Test string",
                },
                privateIpv6GoogleAccess: "Test string",
                reservationAffinity: {
                    consumeReservationType: "Test string",
                    key: "Test string",
                    values: [
                        "Test string"
                    ],
                },
                resourceManagerTags: {
                    A: "Test string"
                },
                resourcePolicies: [
                    "Test string"
                ],
                scheduling: {
                    automaticRestart: true,
                    instanceTerminationAction: "Test string",
                    locationHint: "Test string",
                    minNodeCpus: 42,
                    nodeAffinities: [
                        {
                            key: "Test string",
                            operator: "Test string",
                            values: [
                                "Test string"
                            ],
                        }
                    ],
                    onHostMaintenance: "Test string",
                    preemptible: true,
                    provisioningModel: "Test string",
                },
                serviceAccounts: [
                    {
                        email: "Test string",
                        scopes: [
                            "Test string"
                        ],
                    }
                ],
                shieldedInstanceConfig: {
                    enableIntegrityMonitoring: true,
                    enableSecureBoot: true,
                    enableVtpm: true,
                },
                tags: {
                    fingerprint: "Test string",
                    items: [
                        "Test string"
                    ],
                },
            },
            kind: "Test string",
            machineImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            name: "Test string",
            satisfiesPzs: true,
            savedDisks: [
                {
                    architecture: "Test string",
                    kind: "Test string",
                    sourceDisk: "Test string",
                    storageBytes: "Test string",
                    storageBytesStatus: "Test string",
                }
            ],
            selfLink: "Test string",
            sourceDiskEncryptionKeys: [
                {
                    diskEncryptionKey: {
                        kmsKeyName: "Test string",
                        kmsKeyServiceAccount: "Test string",
                        rawKey: "Test string",
                        rsaEncryptedKey: "Test string",
                        sha256: "Test string",
                    },
                    sourceDisk: "Test string",
                }
            ],
            sourceInstance: "Test string",
            sourceInstanceProperties: {
                canIpForward: true,
                deletionProtection: true,
                description: "Test string",
                disks: [
                    {
                        autoDelete: true,
                        boot: true,
                        deviceName: "Test string",
                        diskEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        diskSizeGb: "Test string",
                        diskType: "Test string",
                        guestOsFeatures: [
                            {
                                type: "Test string",
                            }
                        ],
                        index: 42,
                        interface: "Test string",
                        kind: "Test string",
                        licenses: [
                            "Test string"
                        ],
                        mode: "Test string",
                        source: "Test string",
                        storageBytes: "Test string",
                        storageBytesStatus: "Test string",
                        type: "Test string",
                    }
                ],
                guestAccelerators: [
                    {
                        acceleratorCount: 42,
                        acceleratorType: "Test string",
                    }
                ],
                keyRevocationActionType: "Test string",
                labels: {
                    A: "Test string"
                },
                machineType: "Test string",
                metadata: {
                    fingerprint: "Test string",
                    items: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    kind: "Test string",
                },
                minCpuPlatform: "Test string",
                networkInterfaces: [
                    {
                        accessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        aliasIpRanges: [
                            {
                                ipCidrRange: "Test string",
                                subnetworkRangeName: "Test string",
                            }
                        ],
                        fingerprint: "Test string",
                        internalIpv6PrefixLength: 42,
                        ipv6AccessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        ipv6AccessType: "Test string",
                        ipv6Address: "Test string",
                        kind: "Test string",
                        name: "Test string",
                        network: "Test string",
                        networkAttachment: "Test string",
                        networkIP: "Test string",
                        nicType: "Test string",
                        queueCount: 42,
                        stackType: "Test string",
                        subnetwork: "Test string",
                    }
                ],
                scheduling: {
                    automaticRestart: true,
                    instanceTerminationAction: "Test string",
                    locationHint: "Test string",
                    minNodeCpus: 42,
                    nodeAffinities: [
                        {
                            key: "Test string",
                            operator: "Test string",
                            values: [
                                "Test string"
                            ],
                        }
                    ],
                    onHostMaintenance: "Test string",
                    preemptible: true,
                    provisioningModel: "Test string",
                },
                serviceAccounts: [
                    {
                        email: "Test string",
                        scopes: [
                            "Test string"
                        ],
                    }
                ],
                tags: {
                    fingerprint: "Test string",
                    items: [
                        "Test string"
                    ],
                },
            },
            status: "Test string",
            storageLocations: [
                "Test string"
            ],
            totalStorageBytes: "Test string",
        });
        /** Retrieves a list of machine images that are contained within the specified project. */
        await gapi.client.compute.machineImages.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.machineImages.setIamPolicy({
            project: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.machineImages.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of machine types. */
        await gapi.client.compute.machineTypes.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Returns the specified machine type. */
        await gapi.client.compute.machineTypes.get({
            machineType: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of machine types available to the specified project. */
        await gapi.client.compute.machineTypes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Retrieves the list of all NetworkAttachment resources, regional and global, available to the specified project. */
        await gapi.client.compute.networkAttachments.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified NetworkAttachment in the given scope */
        await gapi.client.compute.networkAttachments.delete({
            networkAttachment: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified NetworkAttachment resource in the given scope. */
        await gapi.client.compute.networkAttachments.get({
            networkAttachment: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.networkAttachments.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Creates a NetworkAttachment in the specified project in the given scope using the parameters that are included in the request. */
        await gapi.client.compute.networkAttachments.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            connectionEndpoints: [
                {
                    ipAddress: "Test string",
                    projectIdOrNum: "Test string",
                    secondaryIpCidrRanges: [
                        "Test string"
                    ],
                    status: "Test string",
                    subnetwork: "Test string",
                }
            ],
            connectionPreference: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            network: "Test string",
            producerAcceptLists: [
                "Test string"
            ],
            producerRejectLists: [
                "Test string"
            ],
            region: "Test string",
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            subnetworks: [
                "Test string"
            ],
        });
        /** Lists the NetworkAttachments for a project in the given scope. */
        await gapi.client.compute.networkAttachments.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.networkAttachments.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.networkAttachments.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves the list of all NetworkEdgeSecurityService resources available to the specified project. */
        await gapi.client.compute.networkEdgeSecurityServices.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified service. */
        await gapi.client.compute.networkEdgeSecurityServices.delete({
            networkEdgeSecurityService: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Gets a specified NetworkEdgeSecurityService. */
        await gapi.client.compute.networkEdgeSecurityServices.get({
            networkEdgeSecurityService: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates a new service in the specified project using the data included in the request. */
        await gapi.client.compute.networkEdgeSecurityServices.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            validateOnly: true,
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            selfLink: "Test string",
            selfLinkWithId: "Test string",
        });
        /** Patches the specified policy with the data included in the request. */
        await gapi.client.compute.networkEdgeSecurityServices.patch({
            networkEdgeSecurityService: "Test string",
            paths: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            updateMask: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            selfLink: "Test string",
            selfLinkWithId: "Test string",
        });
        /** Retrieves the list of network endpoint groups and sorts them by zone. */
        await gapi.client.compute.networkEndpointGroups.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Attach a list of network endpoints to the specified network endpoint group. */
        await gapi.client.compute.networkEndpointGroups.attachNetworkEndpoints({
            networkEndpointGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            networkEndpoints: [
                {
                    annotations: {
                        A: "Test string"
                    },
                    fqdn: "Test string",
                    instance: "Test string",
                    ipAddress: "Test string",
                    port: 42,
                }
            ],
        });
        /**
         * Deletes the specified network endpoint group. The network endpoints in the NEG and the VM instances they belong to are not terminated when the NEG is deleted. Note that the NEG cannot
         * be deleted if there are backend services referencing it.
         */
        await gapi.client.compute.networkEndpointGroups.delete({
            networkEndpointGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Detach a list of network endpoints from the specified network endpoint group. */
        await gapi.client.compute.networkEndpointGroups.detachNetworkEndpoints({
            networkEndpointGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            networkEndpoints: [
                {
                    annotations: {
                        A: "Test string"
                    },
                    fqdn: "Test string",
                    instance: "Test string",
                    ipAddress: "Test string",
                    port: 42,
                }
            ],
        });
        /** Returns the specified network endpoint group. */
        await gapi.client.compute.networkEndpointGroups.get({
            networkEndpointGroup: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Creates a network endpoint group in the specified project using the parameters that are included in the request. */
        await gapi.client.compute.networkEndpointGroups.insert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            annotations: {
                A: "Test string"
            },
            appEngine: {
                service: "Test string",
                urlMask: "Test string",
                version: "Test string",
            },
            cloudFunction: {
                function: "Test string",
                urlMask: "Test string",
            },
            cloudRun: {
                service: "Test string",
                tag: "Test string",
                urlMask: "Test string",
            },
            creationTimestamp: "Test string",
            defaultPort: 42,
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            network: "Test string",
            networkEndpointType: "Test string",
            pscData: {
                consumerPscAddress: "Test string",
                pscConnectionId: "Test string",
                pscConnectionStatus: "Test string",
            },
            pscTargetService: "Test string",
            region: "Test string",
            selfLink: "Test string",
            size: 42,
            subnetwork: "Test string",
            zone: "Test string",
        });
        /** Retrieves the list of network endpoint groups that are located in the specified project and zone. */
        await gapi.client.compute.networkEndpointGroups.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Lists the network endpoints in the specified network endpoint group. */
        await gapi.client.compute.networkEndpointGroups.listNetworkEndpoints({
            filter: "Test string",
            maxResults: 42,
            networkEndpointGroup: "Test string",
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        }, {
            healthStatus: "Test string",
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.networkEndpointGroups.testIamPermissions({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Inserts an association for the specified firewall policy. */
        await gapi.client.compute.networkFirewallPolicies.addAssociation({
            firewallPolicy: "Test string",
            project: "Test string",
            replaceExistingAssociation: true,
            requestId: "Test string",
        }, {
            attachmentTarget: "Test string",
            displayName: "Test string",
            firewallPolicyId: "Test string",
            name: "Test string",
            shortName: "Test string",
        });
        /** Inserts a rule into a firewall policy. */
        await gapi.client.compute.networkFirewallPolicies.addRule({
            firewallPolicy: "Test string",
            maxPriority: 42,
            minPriority: 42,
            project: "Test string",
            requestId: "Test string",
        }, {
            action: "Test string",
            description: "Test string",
            direction: "Test string",
            disabled: true,
            enableLogging: true,
            kind: "Test string",
            match: {
                destAddressGroups: [
                    "Test string"
                ],
                destFqdns: [
                    "Test string"
                ],
                destIpRanges: [
                    "Test string"
                ],
                destRegionCodes: [
                    "Test string"
                ],
                destThreatIntelligences: [
                    "Test string"
                ],
                layer4Configs: [
                    {
                        ipProtocol: "Test string",
                        ports: [
                            "Test string"
                        ],
                    }
                ],
                srcAddressGroups: [
                    "Test string"
                ],
                srcFqdns: [
                    "Test string"
                ],
                srcIpRanges: [
                    "Test string"
                ],
                srcRegionCodes: [
                    "Test string"
                ],
                srcSecureTags: [
                    {
                        name: "Test string",
                        state: "Test string",
                    }
                ],
                srcThreatIntelligences: [
                    "Test string"
                ],
            },
            priority: 42,
            ruleName: "Test string",
            ruleTupleCount: 42,
            targetResources: [
                "Test string"
            ],
            targetSecureTags: [
                {
                    name: "Test string",
                    state: "Test string",
                }
            ],
            targetServiceAccounts: [
                "Test string"
            ],
        });
        /** Copies rules to the specified firewall policy. */
        await gapi.client.compute.networkFirewallPolicies.cloneRules({
            firewallPolicy: "Test string",
            project: "Test string",
            requestId: "Test string",
            sourceFirewallPolicy: "Test string",
        });
        /** Deletes the specified policy. */
        await gapi.client.compute.networkFirewallPolicies.delete({
            firewallPolicy: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified network firewall policy. */
        await gapi.client.compute.networkFirewallPolicies.get({
            firewallPolicy: "Test string",
            project: "Test string",
        });
        /** Gets an association with the specified name. */
        await gapi.client.compute.networkFirewallPolicies.getAssociation({
            firewallPolicy: "Test string",
            name: "Test string",
            project: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.networkFirewallPolicies.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
        });
        /** Gets a rule of the specified priority. */
        await gapi.client.compute.networkFirewallPolicies.getRule({
            firewallPolicy: "Test string",
            priority: 42,
            project: "Test string",
        });
        /** Creates a new policy in the specified project using the data included in the request. */
        await gapi.client.compute.networkFirewallPolicies.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            associations: [
                {
                    attachmentTarget: "Test string",
                    displayName: "Test string",
                    firewallPolicyId: "Test string",
                    name: "Test string",
                    shortName: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            displayName: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            parent: "Test string",
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    direction: "Test string",
                    disabled: true,
                    enableLogging: true,
                    kind: "Test string",
                    match: {
                        destAddressGroups: [
                            "Test string"
                        ],
                        destFqdns: [
                            "Test string"
                        ],
                        destIpRanges: [
                            "Test string"
                        ],
                        destRegionCodes: [
                            "Test string"
                        ],
                        destThreatIntelligences: [
                            "Test string"
                        ],
                        layer4Configs: [
                            {
                                ipProtocol: "Test string",
                                ports: [
                                    "Test string"
                                ],
                            }
                        ],
                        srcAddressGroups: [
                            "Test string"
                        ],
                        srcFqdns: [
                            "Test string"
                        ],
                        srcIpRanges: [
                            "Test string"
                        ],
                        srcRegionCodes: [
                            "Test string"
                        ],
                        srcSecureTags: [
                            {
                                name: "Test string",
                                state: "Test string",
                            }
                        ],
                        srcThreatIntelligences: [
                            "Test string"
                        ],
                    },
                    priority: 42,
                    ruleName: "Test string",
                    ruleTupleCount: 42,
                    targetResources: [
                        "Test string"
                    ],
                    targetSecureTags: [
                        {
                            name: "Test string",
                            state: "Test string",
                        }
                    ],
                    targetServiceAccounts: [
                        "Test string"
                    ],
                }
            ],
            ruleTupleCount: 42,
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            shortName: "Test string",
        });
        /** Lists all the policies that have been configured for the specified project. */
        await gapi.client.compute.networkFirewallPolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified policy with the data included in the request. */
        await gapi.client.compute.networkFirewallPolicies.patch({
            firewallPolicy: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            associations: [
                {
                    attachmentTarget: "Test string",
                    displayName: "Test string",
                    firewallPolicyId: "Test string",
                    name: "Test string",
                    shortName: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            displayName: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            parent: "Test string",
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    direction: "Test string",
                    disabled: true,
                    enableLogging: true,
                    kind: "Test string",
                    match: {
                        destAddressGroups: [
                            "Test string"
                        ],
                        destFqdns: [
                            "Test string"
                        ],
                        destIpRanges: [
                            "Test string"
                        ],
                        destRegionCodes: [
                            "Test string"
                        ],
                        destThreatIntelligences: [
                            "Test string"
                        ],
                        layer4Configs: [
                            {
                                ipProtocol: "Test string",
                                ports: [
                                    "Test string"
                                ],
                            }
                        ],
                        srcAddressGroups: [
                            "Test string"
                        ],
                        srcFqdns: [
                            "Test string"
                        ],
                        srcIpRanges: [
                            "Test string"
                        ],
                        srcRegionCodes: [
                            "Test string"
                        ],
                        srcSecureTags: [
                            {
                                name: "Test string",
                                state: "Test string",
                            }
                        ],
                        srcThreatIntelligences: [
                            "Test string"
                        ],
                    },
                    priority: 42,
                    ruleName: "Test string",
                    ruleTupleCount: 42,
                    targetResources: [
                        "Test string"
                    ],
                    targetSecureTags: [
                        {
                            name: "Test string",
                            state: "Test string",
                        }
                    ],
                    targetServiceAccounts: [
                        "Test string"
                    ],
                }
            ],
            ruleTupleCount: 42,
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            shortName: "Test string",
        });
        /** Patches a rule of the specified priority. */
        await gapi.client.compute.networkFirewallPolicies.patchRule({
            firewallPolicy: "Test string",
            priority: 42,
            project: "Test string",
            requestId: "Test string",
        }, {
            action: "Test string",
            description: "Test string",
            direction: "Test string",
            disabled: true,
            enableLogging: true,
            kind: "Test string",
            match: {
                destAddressGroups: [
                    "Test string"
                ],
                destFqdns: [
                    "Test string"
                ],
                destIpRanges: [
                    "Test string"
                ],
                destRegionCodes: [
                    "Test string"
                ],
                destThreatIntelligences: [
                    "Test string"
                ],
                layer4Configs: [
                    {
                        ipProtocol: "Test string",
                        ports: [
                            "Test string"
                        ],
                    }
                ],
                srcAddressGroups: [
                    "Test string"
                ],
                srcFqdns: [
                    "Test string"
                ],
                srcIpRanges: [
                    "Test string"
                ],
                srcRegionCodes: [
                    "Test string"
                ],
                srcSecureTags: [
                    {
                        name: "Test string",
                        state: "Test string",
                    }
                ],
                srcThreatIntelligences: [
                    "Test string"
                ],
            },
            priority: 42,
            ruleName: "Test string",
            ruleTupleCount: 42,
            targetResources: [
                "Test string"
            ],
            targetSecureTags: [
                {
                    name: "Test string",
                    state: "Test string",
                }
            ],
            targetServiceAccounts: [
                "Test string"
            ],
        });
        /** Removes an association for the specified firewall policy. */
        await gapi.client.compute.networkFirewallPolicies.removeAssociation({
            firewallPolicy: "Test string",
            name: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Deletes a rule of the specified priority. */
        await gapi.client.compute.networkFirewallPolicies.removeRule({
            firewallPolicy: "Test string",
            priority: 42,
            project: "Test string",
            requestId: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.networkFirewallPolicies.setIamPolicy({
            project: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.networkFirewallPolicies.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Adds a peering to the specified network. */
        await gapi.client.compute.networks.addPeering({
            network: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            autoCreateRoutes: true,
            name: "Test string",
            networkPeering: {
                autoCreateRoutes: true,
                exchangeSubnetRoutes: true,
                exportCustomRoutes: true,
                exportSubnetRoutesWithPublicIp: true,
                importCustomRoutes: true,
                importSubnetRoutesWithPublicIp: true,
                name: "Test string",
                network: "Test string",
                peerMtu: 42,
                stackType: "Test string",
                state: "Test string",
                stateDetails: "Test string",
            },
            peerNetwork: "Test string",
        });
        /** Deletes the specified network. */
        await gapi.client.compute.networks.delete({
            network: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified network. */
        await gapi.client.compute.networks.get({
            network: "Test string",
            project: "Test string",
        });
        /** Returns the effective firewalls on a given network. */
        await gapi.client.compute.networks.getEffectiveFirewalls({
            network: "Test string",
            project: "Test string",
        });
        /** Creates a network in the specified project using the data included in the request. */
        await gapi.client.compute.networks.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            autoCreateSubnetworks: true,
            creationTimestamp: "Test string",
            description: "Test string",
            enableUlaInternalIpv6: true,
            firewallPolicy: "Test string",
            gatewayIPv4: "Test string",
            id: "Test string",
            internalIpv6Range: "Test string",
            IPv4Range: "Test string",
            kind: "Test string",
            mtu: 42,
            name: "Test string",
            networkFirewallPolicyEnforcementOrder: "Test string",
            peerings: [
                {
                    autoCreateRoutes: true,
                    exchangeSubnetRoutes: true,
                    exportCustomRoutes: true,
                    exportSubnetRoutesWithPublicIp: true,
                    importCustomRoutes: true,
                    importSubnetRoutesWithPublicIp: true,
                    name: "Test string",
                    network: "Test string",
                    peerMtu: 42,
                    stackType: "Test string",
                    state: "Test string",
                    stateDetails: "Test string",
                }
            ],
            routingConfig: {
                routingMode: "Test string",
            },
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            subnetworks: [
                "Test string"
            ],
        });
        /** Retrieves the list of networks available to the specified project. */
        await gapi.client.compute.networks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists the peering routes exchanged over peering connection. */
        await gapi.client.compute.networks.listPeeringRoutes({
            direction: "Test string",
            filter: "Test string",
            maxResults: 42,
            network: "Test string",
            orderBy: "Test string",
            pageToken: "Test string",
            peeringName: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified network with the data included in the request. Only the following fields can be modified: routingConfig.routingMode. */
        await gapi.client.compute.networks.patch({
            network: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            autoCreateSubnetworks: true,
            creationTimestamp: "Test string",
            description: "Test string",
            enableUlaInternalIpv6: true,
            firewallPolicy: "Test string",
            gatewayIPv4: "Test string",
            id: "Test string",
            internalIpv6Range: "Test string",
            IPv4Range: "Test string",
            kind: "Test string",
            mtu: 42,
            name: "Test string",
            networkFirewallPolicyEnforcementOrder: "Test string",
            peerings: [
                {
                    autoCreateRoutes: true,
                    exchangeSubnetRoutes: true,
                    exportCustomRoutes: true,
                    exportSubnetRoutesWithPublicIp: true,
                    importCustomRoutes: true,
                    importSubnetRoutesWithPublicIp: true,
                    name: "Test string",
                    network: "Test string",
                    peerMtu: 42,
                    stackType: "Test string",
                    state: "Test string",
                    stateDetails: "Test string",
                }
            ],
            routingConfig: {
                routingMode: "Test string",
            },
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            subnetworks: [
                "Test string"
            ],
        });
        /** Removes a peering from the specified network. */
        await gapi.client.compute.networks.removePeering({
            network: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            name: "Test string",
        });
        /** Switches the network mode from auto subnet mode to custom subnet mode. */
        await gapi.client.compute.networks.switchToCustomMode({
            network: "Test string",
            project: "Test string",
            requestId: "Test string",
        });
        /**
         * Updates the specified network peering with the data included in the request. You can only modify the NetworkPeering.export_custom_routes field and the
         * NetworkPeering.import_custom_routes field.
         */
        await gapi.client.compute.networks.updatePeering({
            network: "Test string",
            project: "Test string",
            requestId: "Test string",
        }, {
            networkPeering: {
                autoCreateRoutes: true,
                exchangeSubnetRoutes: true,
                exportCustomRoutes: true,
                exportSubnetRoutesWithPublicIp: true,
                importCustomRoutes: true,
                importSubnetRoutesWithPublicIp: true,
                name: "Test string",
                network: "Test string",
                peerMtu: 42,
                stackType: "Test string",
                state: "Test string",
                stateDetails: "Test string",
            },
        });
        /** Adds specified number of nodes to the node group. */
        await gapi.client.compute.nodeGroups.addNodes({
            nodeGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            additionalNodeCount: 42,
        });
        /** Retrieves an aggregated list of node groups. Note: use nodeGroups.listNodes for more details about each group. */
        await gapi.client.compute.nodeGroups.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified NodeGroup resource. */
        await gapi.client.compute.nodeGroups.delete({
            nodeGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        });
        /** Deletes specified nodes from the node group. */
        await gapi.client.compute.nodeGroups.deleteNodes({
            nodeGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            nodes: [
                "Test string"
            ],
        });
        /** Returns the specified NodeGroup. Get a list of available NodeGroups by making a list() request. Note: the "nodes" field should not be used. Use nodeGroups.listNodes instead. */
        await gapi.client.compute.nodeGroups.get({
            nodeGroup: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.nodeGroups.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        });
        /** Creates a NodeGroup resource in the specified project using the data included in the request. */
        await gapi.client.compute.nodeGroups.insert({
            initialNodeCount: 42,
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            autoscalingPolicy: {
                maxNodes: 42,
                minNodes: 42,
                mode: "Test string",
            },
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            locationHint: "Test string",
            maintenancePolicy: "Test string",
            maintenanceWindow: {
                maintenanceDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                startTime: "Test string",
            },
            name: "Test string",
            nodeTemplate: "Test string",
            selfLink: "Test string",
            shareSettings: {
                projectMap: {
                    A: {
                        projectId: "Test string",
                    }
                },
                shareType: "Test string",
            },
            size: 42,
            status: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of node groups available to the specified project. Note: use nodeGroups.listNodes for more details about each group. */
        await gapi.client.compute.nodeGroups.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Lists nodes in the node group. */
        await gapi.client.compute.nodeGroups.listNodes({
            filter: "Test string",
            maxResults: 42,
            nodeGroup: "Test string",
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Updates the specified node group. */
        await gapi.client.compute.nodeGroups.patch({
            nodeGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            autoscalingPolicy: {
                maxNodes: 42,
                minNodes: 42,
                mode: "Test string",
            },
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            locationHint: "Test string",
            maintenancePolicy: "Test string",
            maintenanceWindow: {
                maintenanceDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                startTime: "Test string",
            },
            name: "Test string",
            nodeTemplate: "Test string",
            selfLink: "Test string",
            shareSettings: {
                projectMap: {
                    A: {
                        projectId: "Test string",
                    }
                },
                shareType: "Test string",
            },
            size: 42,
            status: "Test string",
            zone: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.nodeGroups.setIamPolicy({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Updates the node template of the node group. */
        await gapi.client.compute.nodeGroups.setNodeTemplate({
            nodeGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            nodeTemplate: "Test string",
        });
        /** Simulates maintenance event on specified nodes from the node group. */
        await gapi.client.compute.nodeGroups.simulateMaintenanceEvent({
            nodeGroup: "Test string",
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            nodes: [
                "Test string"
            ],
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.nodeGroups.testIamPermissions({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of node templates. */
        await gapi.client.compute.nodeTemplates.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified NodeTemplate resource. */
        await gapi.client.compute.nodeTemplates.delete({
            nodeTemplate: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified node template. */
        await gapi.client.compute.nodeTemplates.get({
            nodeTemplate: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.nodeTemplates.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Creates a NodeTemplate resource in the specified project using the data included in the request. */
        await gapi.client.compute.nodeTemplates.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            accelerators: [
                {
                    acceleratorCount: 42,
                    acceleratorType: "Test string",
                }
            ],
            cpuOvercommitType: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            disks: [
                {
                    diskCount: 42,
                    diskSizeGb: 42,
                    diskType: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            nodeAffinityLabels: {
                A: "Test string"
            },
            nodeType: "Test string",
            nodeTypeFlexibility: {
                cpus: "Test string",
                localSsd: "Test string",
                memory: "Test string",
            },
            region: "Test string",
            selfLink: "Test string",
            serverBinding: {
                type: "Test string",
            },
            status: "Test string",
            statusMessage: "Test string",
        });
        /** Retrieves a list of node templates available to the specified project. */
        await gapi.client.compute.nodeTemplates.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.nodeTemplates.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.nodeTemplates.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of node types. */
        await gapi.client.compute.nodeTypes.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Returns the specified node type. */
        await gapi.client.compute.nodeTypes.get({
            nodeType: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of node types available to the specified project. */
        await gapi.client.compute.nodeTypes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Retrieves an aggregated list of packetMirrorings. */
        await gapi.client.compute.packetMirrorings.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified PacketMirroring resource. */
        await gapi.client.compute.packetMirrorings.delete({
            packetMirroring: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified PacketMirroring resource. */
        await gapi.client.compute.packetMirrorings.get({
            packetMirroring: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates a PacketMirroring resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.packetMirrorings.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            collectorIlb: {
                canonicalUrl: "Test string",
                url: "Test string",
            },
            creationTimestamp: "Test string",
            description: "Test string",
            enable: "Test string",
            filter: {
                cidrRanges: [
                    "Test string"
                ],
                direction: "Test string",
                IPProtocols: [
                    "Test string"
                ],
            },
            id: "Test string",
            kind: "Test string",
            mirroredResources: {
                instances: [
                    {
                        canonicalUrl: "Test string",
                        url: "Test string",
                    }
                ],
                subnetworks: [
                    {
                        canonicalUrl: "Test string",
                        url: "Test string",
                    }
                ],
                tags: [
                    "Test string"
                ],
            },
            name: "Test string",
            network: {
                canonicalUrl: "Test string",
                url: "Test string",
            },
            priority: 42,
            region: "Test string",
            selfLink: "Test string",
        });
        /** Retrieves a list of PacketMirroring resources available to the specified project and region. */
        await gapi.client.compute.packetMirrorings.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified PacketMirroring resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.packetMirrorings.patch({
            packetMirroring: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            collectorIlb: {
                canonicalUrl: "Test string",
                url: "Test string",
            },
            creationTimestamp: "Test string",
            description: "Test string",
            enable: "Test string",
            filter: {
                cidrRanges: [
                    "Test string"
                ],
                direction: "Test string",
                IPProtocols: [
                    "Test string"
                ],
            },
            id: "Test string",
            kind: "Test string",
            mirroredResources: {
                instances: [
                    {
                        canonicalUrl: "Test string",
                        url: "Test string",
                    }
                ],
                subnetworks: [
                    {
                        canonicalUrl: "Test string",
                        url: "Test string",
                    }
                ],
                tags: [
                    "Test string"
                ],
            },
            name: "Test string",
            network: {
                canonicalUrl: "Test string",
                url: "Test string",
            },
            priority: 42,
            region: "Test string",
            selfLink: "Test string",
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.packetMirrorings.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Disable this project as a shared VPC host project. */
        await gapi.client.compute.projects.disableXpnHost({
            project: "Test string",
            requestId: "Test string",
        });
        /** Disable a service resource (also known as service project) associated with this host project. */
        await gapi.client.compute.projects.disableXpnResource({
            project: "Test string",
            requestId: "Test string",
        }, {
            xpnResource: {
                id: "Test string",
                type: "Test string",
            },
        });
        /** Enable this project as a shared VPC host project. */
        await gapi.client.compute.projects.enableXpnHost({
            project: "Test string",
            requestId: "Test string",
        });
        /** Enable service resource (a.k.a service project) for a host project, so that subnets in the host project can be used by instances in the service project. */
        await gapi.client.compute.projects.enableXpnResource({
            project: "Test string",
            requestId: "Test string",
        }, {
            xpnResource: {
                id: "Test string",
                type: "Test string",
            },
        });
        /**
         * Returns the specified Project resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is
         * especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need.
         * For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
         */
        await gapi.client.compute.projects.get({
            project: "Test string",
        });
        /** Gets the shared VPC host project that this project links to. May be empty if no link exists. */
        await gapi.client.compute.projects.getXpnHost({
            project: "Test string",
        });
        /** Gets service resources (a.k.a service project) associated with this host project. */
        await gapi.client.compute.projects.getXpnResources({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists all shared VPC host projects visible to the user in an organization. */
        await gapi.client.compute.projects.listXpnHosts({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        }, {
            organization: "Test string",
        });
        /** Moves a persistent disk from one zone to another. */
        await gapi.client.compute.projects.moveDisk({
            project: "Test string",
            requestId: "Test string",
        }, {
            destinationZone: "Test string",
            targetDisk: "Test string",
        });
        /**
         * Moves an instance and its attached persistent disks from one zone to another. *Note*: Moving VMs or disks by using this method might cause unexpected behavior. For more information, see
         * the [known issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior).
         */
        await gapi.client.compute.projects.moveInstance({
            project: "Test string",
            requestId: "Test string",
        }, {
            destinationZone: "Test string",
            targetInstance: "Test string",
        });
        /** Sets metadata common to all instances within the specified project using the data included in the request. */
        await gapi.client.compute.projects.setCommonInstanceMetadata({
            project: "Test string",
            requestId: "Test string",
        }, {
            fingerprint: "Test string",
            items: [
                {
                    key: "Test string",
                    value: "Test string",
                }
            ],
            kind: "Test string",
        });
        /** Sets the default network tier of the project. The default network tier is used when an address/forwardingRule/instance is created without specifying the network tier field. */
        await gapi.client.compute.projects.setDefaultNetworkTier({
            project: "Test string",
            requestId: "Test string",
        }, {
            networkTier: "Test string",
        });
        /**
         * Enables the usage export feature and sets the usage export bucket where reports are stored. If you provide an empty request body using this method, the usage export feature will be
         * disabled.
         */
        await gapi.client.compute.projects.setUsageExportBucket({
            project: "Test string",
            requestId: "Test string",
        }, {
            bucketName: "Test string",
            reportNamePrefix: "Test string",
        });
        /** Deletes the specified PublicAdvertisedPrefix */
        await gapi.client.compute.publicAdvertisedPrefixes.delete({
            project: "Test string",
            publicAdvertisedPrefix: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified PublicAdvertisedPrefix resource. */
        await gapi.client.compute.publicAdvertisedPrefixes.get({
            project: "Test string",
            publicAdvertisedPrefix: "Test string",
        });
        /** Creates a PublicAdvertisedPrefix in the specified project using the parameters that are included in the request. */
        await gapi.client.compute.publicAdvertisedPrefixes.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            dnsVerificationIp: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            ipCidrRange: "Test string",
            kind: "Test string",
            name: "Test string",
            publicDelegatedPrefixs: [
                {
                    ipRange: "Test string",
                    name: "Test string",
                    project: "Test string",
                    region: "Test string",
                    status: "Test string",
                }
            ],
            selfLink: "Test string",
            sharedSecret: "Test string",
            status: "Test string",
        });
        /** Lists the PublicAdvertisedPrefixes for a project. */
        await gapi.client.compute.publicAdvertisedPrefixes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.publicAdvertisedPrefixes.patch({
            project: "Test string",
            publicAdvertisedPrefix: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            dnsVerificationIp: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            ipCidrRange: "Test string",
            kind: "Test string",
            name: "Test string",
            publicDelegatedPrefixs: [
                {
                    ipRange: "Test string",
                    name: "Test string",
                    project: "Test string",
                    region: "Test string",
                    status: "Test string",
                }
            ],
            selfLink: "Test string",
            sharedSecret: "Test string",
            status: "Test string",
        });
        /** Lists all PublicDelegatedPrefix resources owned by the specific project across all scopes. */
        await gapi.client.compute.publicDelegatedPrefixes.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified PublicDelegatedPrefix in the given region. */
        await gapi.client.compute.publicDelegatedPrefixes.delete({
            project: "Test string",
            publicDelegatedPrefix: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified PublicDelegatedPrefix resource in the given region. */
        await gapi.client.compute.publicDelegatedPrefixes.get({
            project: "Test string",
            publicDelegatedPrefix: "Test string",
            region: "Test string",
        });
        /** Creates a PublicDelegatedPrefix in the specified project in the given region using the parameters that are included in the request. */
        await gapi.client.compute.publicDelegatedPrefixes.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            ipCidrRange: "Test string",
            isLiveMigration: true,
            kind: "Test string",
            name: "Test string",
            parentPrefix: "Test string",
            publicDelegatedSubPrefixs: [
                {
                    delegateeProject: "Test string",
                    description: "Test string",
                    ipCidrRange: "Test string",
                    isAddress: true,
                    name: "Test string",
                    region: "Test string",
                    status: "Test string",
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            status: "Test string",
        });
        /** Lists the PublicDelegatedPrefixes for a project in the given region. */
        await gapi.client.compute.publicDelegatedPrefixes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified PublicDelegatedPrefix resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.publicDelegatedPrefixes.patch({
            project: "Test string",
            publicDelegatedPrefix: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            ipCidrRange: "Test string",
            isLiveMigration: true,
            kind: "Test string",
            name: "Test string",
            parentPrefix: "Test string",
            publicDelegatedSubPrefixs: [
                {
                    delegateeProject: "Test string",
                    description: "Test string",
                    ipCidrRange: "Test string",
                    isAddress: true,
                    name: "Test string",
                    region: "Test string",
                    status: "Test string",
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            status: "Test string",
        });
        /** Deletes the specified autoscaler. */
        await gapi.client.compute.regionAutoscalers.delete({
            autoscaler: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified autoscaler. */
        await gapi.client.compute.regionAutoscalers.get({
            autoscaler: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates an autoscaler in the specified project using the data included in the request. */
        await gapi.client.compute.regionAutoscalers.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            autoscalingPolicy: {
                coolDownPeriodSec: 42,
                cpuUtilization: {
                    predictiveMethod: "Test string",
                    utilizationTarget: 42,
                },
                customMetricUtilizations: [
                    {
                        filter: "Test string",
                        metric: "Test string",
                        singleInstanceAssignment: 42,
                        utilizationTarget: 42,
                        utilizationTargetType: "Test string",
                    }
                ],
                loadBalancingUtilization: {
                    utilizationTarget: 42,
                },
                maxNumReplicas: 42,
                minNumReplicas: 42,
                mode: "Test string",
                scaleInControl: {
                    maxScaledInReplicas: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                    timeWindowSec: 42,
                },
                scalingSchedules: {
                    A: {
                        description: "Test string",
                        disabled: true,
                        durationSec: 42,
                        minRequiredReplicas: 42,
                        schedule: "Test string",
                        timeZone: "Test string",
                    }
                },
            },
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            recommendedSize: 42,
            region: "Test string",
            scalingScheduleStatus: {
                A: {
                    lastStartTime: "Test string",
                    nextStartTime: "Test string",
                    state: "Test string",
                }
            },
            selfLink: "Test string",
            status: "Test string",
            statusDetails: [
                {
                    message: "Test string",
                    type: "Test string",
                }
            ],
            target: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of autoscalers contained within the specified region. */
        await gapi.client.compute.regionAutoscalers.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Updates an autoscaler in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. */
        await gapi.client.compute.regionAutoscalers.patch({
            autoscaler: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            autoscalingPolicy: {
                coolDownPeriodSec: 42,
                cpuUtilization: {
                    predictiveMethod: "Test string",
                    utilizationTarget: 42,
                },
                customMetricUtilizations: [
                    {
                        filter: "Test string",
                        metric: "Test string",
                        singleInstanceAssignment: 42,
                        utilizationTarget: 42,
                        utilizationTargetType: "Test string",
                    }
                ],
                loadBalancingUtilization: {
                    utilizationTarget: 42,
                },
                maxNumReplicas: 42,
                minNumReplicas: 42,
                mode: "Test string",
                scaleInControl: {
                    maxScaledInReplicas: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                    timeWindowSec: 42,
                },
                scalingSchedules: {
                    A: {
                        description: "Test string",
                        disabled: true,
                        durationSec: 42,
                        minRequiredReplicas: 42,
                        schedule: "Test string",
                        timeZone: "Test string",
                    }
                },
            },
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            recommendedSize: 42,
            region: "Test string",
            scalingScheduleStatus: {
                A: {
                    lastStartTime: "Test string",
                    nextStartTime: "Test string",
                    state: "Test string",
                }
            },
            selfLink: "Test string",
            status: "Test string",
            statusDetails: [
                {
                    message: "Test string",
                    type: "Test string",
                }
            ],
            target: "Test string",
            zone: "Test string",
        });
        /** Updates an autoscaler in the specified project using the data included in the request. */
        await gapi.client.compute.regionAutoscalers.update({
            autoscaler: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            autoscalingPolicy: {
                coolDownPeriodSec: 42,
                cpuUtilization: {
                    predictiveMethod: "Test string",
                    utilizationTarget: 42,
                },
                customMetricUtilizations: [
                    {
                        filter: "Test string",
                        metric: "Test string",
                        singleInstanceAssignment: 42,
                        utilizationTarget: 42,
                        utilizationTargetType: "Test string",
                    }
                ],
                loadBalancingUtilization: {
                    utilizationTarget: 42,
                },
                maxNumReplicas: 42,
                minNumReplicas: 42,
                mode: "Test string",
                scaleInControl: {
                    maxScaledInReplicas: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                    timeWindowSec: 42,
                },
                scalingSchedules: {
                    A: {
                        description: "Test string",
                        disabled: true,
                        durationSec: 42,
                        minRequiredReplicas: 42,
                        schedule: "Test string",
                        timeZone: "Test string",
                    }
                },
            },
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            recommendedSize: 42,
            region: "Test string",
            scalingScheduleStatus: {
                A: {
                    lastStartTime: "Test string",
                    nextStartTime: "Test string",
                    state: "Test string",
                }
            },
            selfLink: "Test string",
            status: "Test string",
            statusDetails: [
                {
                    message: "Test string",
                    type: "Test string",
                }
            ],
            target: "Test string",
            zone: "Test string",
        });
        /** Deletes the specified regional BackendService resource. */
        await gapi.client.compute.regionBackendServices.delete({
            backendService: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified regional BackendService resource. */
        await gapi.client.compute.regionBackendServices.get({
            backendService: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Gets the most recent health check results for this regional BackendService. */
        await gapi.client.compute.regionBackendServices.getHealth({
            backendService: "Test string",
            project: "Test string",
            region: "Test string",
        }, {
            group: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.regionBackendServices.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Creates a regional BackendService resource in the specified project using the data included in the request. For more information, see Backend services overview. */
        await gapi.client.compute.regionBackendServices.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            affinityCookieTtlSec: 42,
            backends: [
                {
                    balancingMode: "Test string",
                    capacityScaler: 42,
                    description: "Test string",
                    failover: true,
                    group: "Test string",
                    maxConnections: 42,
                    maxConnectionsPerEndpoint: 42,
                    maxConnectionsPerInstance: 42,
                    maxRate: 42,
                    maxRatePerEndpoint: 42,
                    maxRatePerInstance: 42,
                    maxUtilization: 42,
                }
            ],
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHost: true,
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    includeNamedCookies: [
                        "Test string"
                    ],
                    includeProtocol: true,
                    includeQueryString: true,
                    queryStringBlacklist: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            circuitBreakers: {
                maxConnections: 42,
                maxPendingRequests: 42,
                maxRequests: 42,
                maxRequestsPerConnection: 42,
                maxRetries: 42,
            },
            compressionMode: "Test string",
            connectionDraining: {
                drainingTimeoutSec: 42,
            },
            connectionTrackingPolicy: {
                connectionPersistenceOnUnhealthyBackends: "Test string",
                enableStrongAffinity: true,
                idleTimeoutSec: 42,
                trackingMode: "Test string",
            },
            consistentHash: {
                httpCookie: {
                    name: "Test string",
                    path: "Test string",
                    ttl: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                },
                httpHeaderName: "Test string",
                minimumRingSize: "Test string",
            },
            creationTimestamp: "Test string",
            customRequestHeaders: [
                "Test string"
            ],
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCDN: true,
            failoverPolicy: {
                disableConnectionDrainOnFailover: true,
                dropTrafficIfUnhealthy: true,
                failoverRatio: 42,
            },
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            iap: {
                enabled: true,
                oauth2ClientId: "Test string",
                oauth2ClientSecret: "Test string",
                oauth2ClientSecretSha256: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            loadBalancingScheme: "Test string",
            localityLbPolicies: [
                {
                    customPolicy: {
                        data: "Test string",
                        name: "Test string",
                    },
                    policy: {
                        name: "Test string",
                    },
                }
            ],
            localityLbPolicy: "Test string",
            logConfig: {
                enable: true,
                optionalFields: [
                    "Test string"
                ],
                optionalMode: "Test string",
                sampleRate: 42,
            },
            maxStreamDuration: {
                nanos: 42,
                seconds: "Test string",
            },
            metadatas: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            outlierDetection: {
                baseEjectionTime: {
                    nanos: 42,
                    seconds: "Test string",
                },
                consecutiveErrors: 42,
                consecutiveGatewayFailure: 42,
                enforcingConsecutiveErrors: 42,
                enforcingConsecutiveGatewayFailure: 42,
                enforcingSuccessRate: 42,
                interval: {
                    nanos: 42,
                    seconds: "Test string",
                },
                maxEjectionPercent: 42,
                successRateMinimumHosts: 42,
                successRateRequestVolume: 42,
                successRateStdevFactor: 42,
            },
            port: 42,
            portName: "Test string",
            protocol: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            securitySettings: {
                clientTlsPolicy: "Test string",
                subjectAltNames: [
                    "Test string"
                ],
            },
            selfLink: "Test string",
            serviceBindings: [
                "Test string"
            ],
            sessionAffinity: "Test string",
            subsetting: {
                policy: "Test string",
            },
            timeoutSec: 42,
        });
        /** Retrieves the list of regional BackendService resources available to the specified project in the given region. */
        await gapi.client.compute.regionBackendServices.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates the specified regional BackendService resource with the data included in the request. For more information, see Understanding backend services This method supports PATCH
         * semantics and uses the JSON merge patch format and processing rules.
         */
        await gapi.client.compute.regionBackendServices.patch({
            backendService: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            affinityCookieTtlSec: 42,
            backends: [
                {
                    balancingMode: "Test string",
                    capacityScaler: 42,
                    description: "Test string",
                    failover: true,
                    group: "Test string",
                    maxConnections: 42,
                    maxConnectionsPerEndpoint: 42,
                    maxConnectionsPerInstance: 42,
                    maxRate: 42,
                    maxRatePerEndpoint: 42,
                    maxRatePerInstance: 42,
                    maxUtilization: 42,
                }
            ],
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHost: true,
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    includeNamedCookies: [
                        "Test string"
                    ],
                    includeProtocol: true,
                    includeQueryString: true,
                    queryStringBlacklist: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            circuitBreakers: {
                maxConnections: 42,
                maxPendingRequests: 42,
                maxRequests: 42,
                maxRequestsPerConnection: 42,
                maxRetries: 42,
            },
            compressionMode: "Test string",
            connectionDraining: {
                drainingTimeoutSec: 42,
            },
            connectionTrackingPolicy: {
                connectionPersistenceOnUnhealthyBackends: "Test string",
                enableStrongAffinity: true,
                idleTimeoutSec: 42,
                trackingMode: "Test string",
            },
            consistentHash: {
                httpCookie: {
                    name: "Test string",
                    path: "Test string",
                    ttl: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                },
                httpHeaderName: "Test string",
                minimumRingSize: "Test string",
            },
            creationTimestamp: "Test string",
            customRequestHeaders: [
                "Test string"
            ],
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCDN: true,
            failoverPolicy: {
                disableConnectionDrainOnFailover: true,
                dropTrafficIfUnhealthy: true,
                failoverRatio: 42,
            },
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            iap: {
                enabled: true,
                oauth2ClientId: "Test string",
                oauth2ClientSecret: "Test string",
                oauth2ClientSecretSha256: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            loadBalancingScheme: "Test string",
            localityLbPolicies: [
                {
                    customPolicy: {
                        data: "Test string",
                        name: "Test string",
                    },
                    policy: {
                        name: "Test string",
                    },
                }
            ],
            localityLbPolicy: "Test string",
            logConfig: {
                enable: true,
                optionalFields: [
                    "Test string"
                ],
                optionalMode: "Test string",
                sampleRate: 42,
            },
            maxStreamDuration: {
                nanos: 42,
                seconds: "Test string",
            },
            metadatas: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            outlierDetection: {
                baseEjectionTime: {
                    nanos: 42,
                    seconds: "Test string",
                },
                consecutiveErrors: 42,
                consecutiveGatewayFailure: 42,
                enforcingConsecutiveErrors: 42,
                enforcingConsecutiveGatewayFailure: 42,
                enforcingSuccessRate: 42,
                interval: {
                    nanos: 42,
                    seconds: "Test string",
                },
                maxEjectionPercent: 42,
                successRateMinimumHosts: 42,
                successRateRequestVolume: 42,
                successRateStdevFactor: 42,
            },
            port: 42,
            portName: "Test string",
            protocol: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            securitySettings: {
                clientTlsPolicy: "Test string",
                subjectAltNames: [
                    "Test string"
                ],
            },
            selfLink: "Test string",
            serviceBindings: [
                "Test string"
            ],
            sessionAffinity: "Test string",
            subsetting: {
                policy: "Test string",
            },
            timeoutSec: 42,
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.regionBackendServices.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Updates the specified regional BackendService resource with the data included in the request. For more information, see Backend services overview . */
        await gapi.client.compute.regionBackendServices.update({
            backendService: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            affinityCookieTtlSec: 42,
            backends: [
                {
                    balancingMode: "Test string",
                    capacityScaler: 42,
                    description: "Test string",
                    failover: true,
                    group: "Test string",
                    maxConnections: 42,
                    maxConnectionsPerEndpoint: 42,
                    maxConnectionsPerInstance: 42,
                    maxRate: 42,
                    maxRatePerEndpoint: 42,
                    maxRatePerInstance: 42,
                    maxUtilization: 42,
                }
            ],
            cdnPolicy: {
                bypassCacheOnRequestHeaders: [
                    {
                        headerName: "Test string",
                    }
                ],
                cacheKeyPolicy: {
                    includeHost: true,
                    includeHttpHeaders: [
                        "Test string"
                    ],
                    includeNamedCookies: [
                        "Test string"
                    ],
                    includeProtocol: true,
                    includeQueryString: true,
                    queryStringBlacklist: [
                        "Test string"
                    ],
                    queryStringWhitelist: [
                        "Test string"
                    ],
                },
                cacheMode: "Test string",
                clientTtl: 42,
                defaultTtl: 42,
                maxTtl: 42,
                negativeCaching: true,
                negativeCachingPolicy: [
                    {
                        code: 42,
                        ttl: 42,
                    }
                ],
                requestCoalescing: true,
                serveWhileStale: 42,
                signedUrlCacheMaxAgeSec: "Test string",
                signedUrlKeyNames: [
                    "Test string"
                ],
            },
            circuitBreakers: {
                maxConnections: 42,
                maxPendingRequests: 42,
                maxRequests: 42,
                maxRequestsPerConnection: 42,
                maxRetries: 42,
            },
            compressionMode: "Test string",
            connectionDraining: {
                drainingTimeoutSec: 42,
            },
            connectionTrackingPolicy: {
                connectionPersistenceOnUnhealthyBackends: "Test string",
                enableStrongAffinity: true,
                idleTimeoutSec: 42,
                trackingMode: "Test string",
            },
            consistentHash: {
                httpCookie: {
                    name: "Test string",
                    path: "Test string",
                    ttl: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                },
                httpHeaderName: "Test string",
                minimumRingSize: "Test string",
            },
            creationTimestamp: "Test string",
            customRequestHeaders: [
                "Test string"
            ],
            customResponseHeaders: [
                "Test string"
            ],
            description: "Test string",
            edgeSecurityPolicy: "Test string",
            enableCDN: true,
            failoverPolicy: {
                disableConnectionDrainOnFailover: true,
                dropTrafficIfUnhealthy: true,
                failoverRatio: 42,
            },
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            iap: {
                enabled: true,
                oauth2ClientId: "Test string",
                oauth2ClientSecret: "Test string",
                oauth2ClientSecretSha256: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            loadBalancingScheme: "Test string",
            localityLbPolicies: [
                {
                    customPolicy: {
                        data: "Test string",
                        name: "Test string",
                    },
                    policy: {
                        name: "Test string",
                    },
                }
            ],
            localityLbPolicy: "Test string",
            logConfig: {
                enable: true,
                optionalFields: [
                    "Test string"
                ],
                optionalMode: "Test string",
                sampleRate: 42,
            },
            maxStreamDuration: {
                nanos: 42,
                seconds: "Test string",
            },
            metadatas: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            outlierDetection: {
                baseEjectionTime: {
                    nanos: 42,
                    seconds: "Test string",
                },
                consecutiveErrors: 42,
                consecutiveGatewayFailure: 42,
                enforcingConsecutiveErrors: 42,
                enforcingConsecutiveGatewayFailure: 42,
                enforcingSuccessRate: 42,
                interval: {
                    nanos: 42,
                    seconds: "Test string",
                },
                maxEjectionPercent: 42,
                successRateMinimumHosts: 42,
                successRateRequestVolume: 42,
                successRateStdevFactor: 42,
            },
            port: 42,
            portName: "Test string",
            protocol: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
            securitySettings: {
                clientTlsPolicy: "Test string",
                subjectAltNames: [
                    "Test string"
                ],
            },
            selfLink: "Test string",
            serviceBindings: [
                "Test string"
            ],
            sessionAffinity: "Test string",
            subsetting: {
                policy: "Test string",
            },
            timeoutSec: 42,
        });
        /** Retrieves an aggregated list of commitments by region. */
        await gapi.client.compute.regionCommitments.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Returns the specified commitment resource. */
        await gapi.client.compute.regionCommitments.get({
            commitment: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates a commitment in the specified project using the data included in the request. */
        await gapi.client.compute.regionCommitments.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            autoRenew: true,
            category: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            endTimestamp: "Test string",
            id: "Test string",
            kind: "Test string",
            licenseResource: {
                amount: "Test string",
                coresPerLicense: "Test string",
                license: "Test string",
            },
            mergeSourceCommitments: [
                "Test string"
            ],
            name: "Test string",
            plan: "Test string",
            region: "Test string",
            reservations: [
                {
                    commitment: "Test string",
                    creationTimestamp: "Test string",
                    description: "Test string",
                    id: "Test string",
                    kind: "Test string",
                    name: "Test string",
                    resourcePolicies: {
                        A: "Test string"
                    },
                    resourceStatus: {
                        specificSkuAllocation: {
                            sourceInstanceTemplateId: "Test string",
                        },
                    },
                    satisfiesPzs: true,
                    selfLink: "Test string",
                    shareSettings: {
                        projectMap: {
                            A: {
                                projectId: "Test string",
                            }
                        },
                        shareType: "Test string",
                    },
                    specificReservation: {
                        assuredCount: "Test string",
                        count: "Test string",
                        instanceProperties: {
                            guestAccelerators: [
                                {
                                    acceleratorCount: 42,
                                    acceleratorType: "Test string",
                                }
                            ],
                            localSsds: [
                                {
                                    diskSizeGb: "Test string",
                                    interface: "Test string",
                                }
                            ],
                            locationHint: "Test string",
                            machineType: "Test string",
                            minCpuPlatform: "Test string",
                        },
                        inUseCount: "Test string",
                        sourceInstanceTemplate: "Test string",
                    },
                    specificReservationRequired: true,
                    status: "Test string",
                    zone: "Test string",
                }
            ],
            resources: [
                {
                    acceleratorType: "Test string",
                    amount: "Test string",
                    type: "Test string",
                }
            ],
            selfLink: "Test string",
            splitSourceCommitment: "Test string",
            startTimestamp: "Test string",
            status: "Test string",
            statusMessage: "Test string",
            type: "Test string",
        });
        /** Retrieves a list of commitments contained within the specified region. */
        await gapi.client.compute.regionCommitments.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates the specified commitment with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be
         * modified: auto_renew.
         */
        await gapi.client.compute.regionCommitments.update({
            commitment: "Test string",
            paths: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            updateMask: "Test string",
        }, {
            autoRenew: true,
            category: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            endTimestamp: "Test string",
            id: "Test string",
            kind: "Test string",
            licenseResource: {
                amount: "Test string",
                coresPerLicense: "Test string",
                license: "Test string",
            },
            mergeSourceCommitments: [
                "Test string"
            ],
            name: "Test string",
            plan: "Test string",
            region: "Test string",
            reservations: [
                {
                    commitment: "Test string",
                    creationTimestamp: "Test string",
                    description: "Test string",
                    id: "Test string",
                    kind: "Test string",
                    name: "Test string",
                    resourcePolicies: {
                        A: "Test string"
                    },
                    resourceStatus: {
                        specificSkuAllocation: {
                            sourceInstanceTemplateId: "Test string",
                        },
                    },
                    satisfiesPzs: true,
                    selfLink: "Test string",
                    shareSettings: {
                        projectMap: {
                            A: {
                                projectId: "Test string",
                            }
                        },
                        shareType: "Test string",
                    },
                    specificReservation: {
                        assuredCount: "Test string",
                        count: "Test string",
                        instanceProperties: {
                            guestAccelerators: [
                                {
                                    acceleratorCount: 42,
                                    acceleratorType: "Test string",
                                }
                            ],
                            localSsds: [
                                {
                                    diskSizeGb: "Test string",
                                    interface: "Test string",
                                }
                            ],
                            locationHint: "Test string",
                            machineType: "Test string",
                            minCpuPlatform: "Test string",
                        },
                        inUseCount: "Test string",
                        sourceInstanceTemplate: "Test string",
                    },
                    specificReservationRequired: true,
                    status: "Test string",
                    zone: "Test string",
                }
            ],
            resources: [
                {
                    acceleratorType: "Test string",
                    amount: "Test string",
                    type: "Test string",
                }
            ],
            selfLink: "Test string",
            splitSourceCommitment: "Test string",
            startTimestamp: "Test string",
            status: "Test string",
            statusMessage: "Test string",
            type: "Test string",
        });
        /** Adds existing resource policies to a regional disk. You can only add one policy which will be applied to this disk for scheduling snapshot creation. */
        await gapi.client.compute.regionDisks.addResourcePolicies({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            resourcePolicies: [
                "Test string"
            ],
        });
        /** Bulk create a set of disks. */
        await gapi.client.compute.regionDisks.bulkInsert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            sourceConsistencyGroupPolicy: "Test string",
        });
        /**
         * Creates a snapshot of a specified persistent disk. For regular snapshot creation, consider using snapshots.insert instead, as that method supports more features, such as creating
         * snapshots in a project different from the source disk project.
         */
        await gapi.client.compute.regionDisks.createSnapshot({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            architecture: "Test string",
            autoCreated: true,
            chainName: "Test string",
            creationSizeBytes: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            diskSizeGb: "Test string",
            downloadBytes: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            locationHint: "Test string",
            name: "Test string",
            satisfiesPzs: true,
            selfLink: "Test string",
            snapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            snapshotType: "Test string",
            sourceDisk: "Test string",
            sourceDiskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceDiskId: "Test string",
            sourceSnapshotSchedulePolicy: "Test string",
            sourceSnapshotSchedulePolicyId: "Test string",
            status: "Test string",
            storageBytes: "Test string",
            storageBytesStatus: "Test string",
            storageLocations: [
                "Test string"
            ],
        });
        /**
         * Deletes the specified regional persistent disk. Deleting a regional disk removes all the replicas of its data permanently and is irreversible. However, deleting a disk does not delete
         * any snapshots previously made from the disk. You must separately delete snapshots.
         */
        await gapi.client.compute.regionDisks.delete({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns a specified regional persistent disk. */
        await gapi.client.compute.regionDisks.get({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.regionDisks.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Creates a persistent regional disk in the specified project using the data included in the request. */
        await gapi.client.compute.regionDisks.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            sourceImage: "Test string",
        }, {
            architecture: "Test string",
            asyncPrimaryDisk: {
                consistencyGroupPolicy: "Test string",
                consistencyGroupPolicyId: "Test string",
                disk: "Test string",
                diskId: "Test string",
            },
            asyncSecondaryDisks: {
                A: {
                    asyncReplicationDisk: {
                        consistencyGroupPolicy: "Test string",
                        consistencyGroupPolicyId: "Test string",
                        disk: "Test string",
                        diskId: "Test string",
                    },
                }
            },
            creationTimestamp: "Test string",
            description: "Test string",
            diskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            guestOsFeatures: [
                {
                    type: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            lastAttachTimestamp: "Test string",
            lastDetachTimestamp: "Test string",
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            locationHint: "Test string",
            name: "Test string",
            options: "Test string",
            params: {
                resourceManagerTags: {
                    A: "Test string"
                },
            },
            physicalBlockSizeBytes: "Test string",
            provisionedIops: "Test string",
            provisionedThroughput: "Test string",
            region: "Test string",
            replicaZones: [
                "Test string"
            ],
            resourcePolicies: [
                "Test string"
            ],
            resourceStatus: {
                asyncPrimaryDisk: {
                    state: "Test string",
                },
                asyncSecondaryDisks: {
                    A: {
                        state: "Test string",
                    }
                },
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            sizeGb: "Test string",
            sourceConsistencyGroupPolicy: "Test string",
            sourceConsistencyGroupPolicyId: "Test string",
            sourceDisk: "Test string",
            sourceDiskId: "Test string",
            sourceImage: "Test string",
            sourceImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceImageId: "Test string",
            sourceSnapshot: "Test string",
            sourceSnapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceSnapshotId: "Test string",
            sourceStorageObject: "Test string",
            status: "Test string",
            type: "Test string",
            users: [
                "Test string"
            ],
            zone: "Test string",
        });
        /** Retrieves the list of persistent disks contained within the specified region. */
        await gapi.client.compute.regionDisks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Removes resource policies from a regional disk. */
        await gapi.client.compute.regionDisks.removeResourcePolicies({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            resourcePolicies: [
                "Test string"
            ],
        });
        /** Resizes the specified regional persistent disk. */
        await gapi.client.compute.regionDisks.resize({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            sizeGb: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.regionDisks.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Sets the labels on the target regional disk. */
        await gapi.client.compute.regionDisks.setLabels({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Starts asynchronous replication. Must be invoked on the primary disk. */
        await gapi.client.compute.regionDisks.startAsyncReplication({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            asyncSecondaryDisk: "Test string",
        });
        /** Stops asynchronous replication. Can be invoked either on the primary or on the secondary disk. */
        await gapi.client.compute.regionDisks.stopAsyncReplication({
            disk: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Stops asynchronous replication for a consistency group of disks. Can be invoked either in the primary or secondary scope. */
        await gapi.client.compute.regionDisks.stopGroupAsyncReplication({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            resourcePolicy: "Test string",
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.regionDisks.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /**
         * Update the specified disk with the data included in the request. Update is performed only on selected fields included as part of update-mask. Only the following fields can be modified:
         * user_license.
         */
        await gapi.client.compute.regionDisks.update({
            disk: "Test string",
            paths: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            updateMask: "Test string",
        }, {
            architecture: "Test string",
            asyncPrimaryDisk: {
                consistencyGroupPolicy: "Test string",
                consistencyGroupPolicyId: "Test string",
                disk: "Test string",
                diskId: "Test string",
            },
            asyncSecondaryDisks: {
                A: {
                    asyncReplicationDisk: {
                        consistencyGroupPolicy: "Test string",
                        consistencyGroupPolicyId: "Test string",
                        disk: "Test string",
                        diskId: "Test string",
                    },
                }
            },
            creationTimestamp: "Test string",
            description: "Test string",
            diskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            guestOsFeatures: [
                {
                    type: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            lastAttachTimestamp: "Test string",
            lastDetachTimestamp: "Test string",
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            locationHint: "Test string",
            name: "Test string",
            options: "Test string",
            params: {
                resourceManagerTags: {
                    A: "Test string"
                },
            },
            physicalBlockSizeBytes: "Test string",
            provisionedIops: "Test string",
            provisionedThroughput: "Test string",
            region: "Test string",
            replicaZones: [
                "Test string"
            ],
            resourcePolicies: [
                "Test string"
            ],
            resourceStatus: {
                asyncPrimaryDisk: {
                    state: "Test string",
                },
                asyncSecondaryDisks: {
                    A: {
                        state: "Test string",
                    }
                },
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            sizeGb: "Test string",
            sourceConsistencyGroupPolicy: "Test string",
            sourceConsistencyGroupPolicyId: "Test string",
            sourceDisk: "Test string",
            sourceDiskId: "Test string",
            sourceImage: "Test string",
            sourceImageEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceImageId: "Test string",
            sourceSnapshot: "Test string",
            sourceSnapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceSnapshotId: "Test string",
            sourceStorageObject: "Test string",
            status: "Test string",
            type: "Test string",
            users: [
                "Test string"
            ],
            zone: "Test string",
        });
        /** Returns the specified regional disk type. */
        await gapi.client.compute.regionDiskTypes.get({
            diskType: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Retrieves a list of regional disk types available to the specified project. */
        await gapi.client.compute.regionDiskTypes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified HealthCheck resource. */
        await gapi.client.compute.regionHealthChecks.delete({
            healthCheck: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified HealthCheck resource. */
        await gapi.client.compute.regionHealthChecks.get({
            healthCheck: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates a HealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.regionHealthChecks.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            grpcHealthCheck: {
                grpcServiceName: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
            },
            healthyThreshold: 42,
            http2HealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpsHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
            },
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
            sslHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            tcpHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            timeoutSec: 42,
            type: "Test string",
            unhealthyThreshold: 42,
        });
        /** Retrieves the list of HealthCheck resources available to the specified project. */
        await gapi.client.compute.regionHealthChecks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates a HealthCheck resource in the specified project using the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing
         * rules.
         */
        await gapi.client.compute.regionHealthChecks.patch({
            healthCheck: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            grpcHealthCheck: {
                grpcServiceName: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
            },
            healthyThreshold: 42,
            http2HealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpsHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
            },
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
            sslHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            tcpHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            timeoutSec: 42,
            type: "Test string",
            unhealthyThreshold: 42,
        });
        /** Updates a HealthCheck resource in the specified project using the data included in the request. */
        await gapi.client.compute.regionHealthChecks.update({
            healthCheck: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            checkIntervalSec: 42,
            creationTimestamp: "Test string",
            description: "Test string",
            grpcHealthCheck: {
                grpcServiceName: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
            },
            healthyThreshold: 42,
            http2HealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            httpsHealthCheck: {
                host: "Test string",
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                requestPath: "Test string",
                response: "Test string",
            },
            id: "Test string",
            kind: "Test string",
            logConfig: {
                enable: true,
            },
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
            sslHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            tcpHealthCheck: {
                port: 42,
                portName: "Test string",
                portSpecification: "Test string",
                proxyHeader: "Test string",
                request: "Test string",
                response: "Test string",
            },
            timeoutSec: 42,
            type: "Test string",
            unhealthyThreshold: 42,
        });
        /** Deletes the specified regional HealthCheckService. */
        await gapi.client.compute.regionHealthCheckServices.delete({
            healthCheckService: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified regional HealthCheckService resource. */
        await gapi.client.compute.regionHealthCheckServices.get({
            healthCheckService: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates a regional HealthCheckService resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.regionHealthCheckServices.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            healthStatusAggregationPolicy: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            networkEndpointGroups: [
                "Test string"
            ],
            notificationEndpoints: [
                "Test string"
            ],
            region: "Test string",
            selfLink: "Test string",
        });
        /** Lists all the HealthCheckService resources that have been configured for the specified project in the given region. */
        await gapi.client.compute.regionHealthCheckServices.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates the specified regional HealthCheckService resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and
         * processing rules.
         */
        await gapi.client.compute.regionHealthCheckServices.patch({
            healthCheckService: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            healthChecks: [
                "Test string"
            ],
            healthStatusAggregationPolicy: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            networkEndpointGroups: [
                "Test string"
            ],
            notificationEndpoints: [
                "Test string"
            ],
            region: "Test string",
            selfLink: "Test string",
        });
        /**
         * Flags the specified instances to be immediately removed from the managed instance group. Abandoning an instance does not delete the instance, but it does remove the instance from any
         * target pools that are applied by the managed instance group. This method reduces the targetSize of the managed instance group by the number of instances that you abandon. This operation
         * is marked as DONE when the action is scheduled even if the instances have not yet been removed from the group. You must separately verify the status of the abandoning action with the
         * listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has
         * elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
         */
        await gapi.client.compute.regionInstanceGroupManagers.abandonInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            instances: [
                "Test string"
            ],
        });
        /** Apply updates to selected instances the managed instance group. */
        await gapi.client.compute.regionInstanceGroupManagers.applyUpdatesToInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
        }, {
            allInstances: true,
            instances: [
                "Test string"
            ],
            minimalAction: "Test string",
            mostDisruptiveAllowedAction: "Test string",
        });
        /**
         * Creates instances with per-instance configurations in this regional managed instance group. Instances are created using the current instance template. The create instances operation is
         * marked DONE if the createInstances request is successful. The underlying actions take additional time. You must separately verify the status of the creating or actions with the
         * listmanagedinstances method.
         */
        await gapi.client.compute.regionInstanceGroupManagers.createInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            instances: [
                {
                    fingerprint: "Test string",
                    name: "Test string",
                    preservedState: {
                        disks: {
                            A: {
                                autoDelete: "Test string",
                                mode: "Test string",
                                source: "Test string",
                            }
                        },
                        metadata: {
                            A: "Test string"
                        },
                    },
                    status: "Test string",
                }
            ],
        });
        /** Deletes the specified managed instance group and all of the instances in that group. */
        await gapi.client.compute.regionInstanceGroupManagers.delete({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /**
         * Flags the specified instances in the managed instance group to be immediately deleted. The instances are also removed from any target pools of which they were a member. This method
         * reduces the targetSize of the managed instance group by the number of instances that you delete. The deleteInstances operation is marked DONE if the deleteInstances request is
         * successful. The underlying actions take additional time. You must separately verify the status of the deleting action with the listmanagedinstances method. If the group is part of a
         * backend service that has enabled connection draining, it can take up to 60 seconds after the connection draining duration has elapsed before the VM instance is removed or deleted. You
         * can specify a maximum of 1000 instances with this method per request.
         */
        await gapi.client.compute.regionInstanceGroupManagers.deleteInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            instances: [
                "Test string"
            ],
            skipInstancesOnValidationError: true,
        });
        /** Deletes selected per-instance configurations for the managed instance group. */
        await gapi.client.compute.regionInstanceGroupManagers.deletePerInstanceConfigs({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
        }, {
            names: [
                "Test string"
            ],
        });
        /** Returns all of the details about the specified managed instance group. */
        await gapi.client.compute.regionInstanceGroupManagers.get({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /**
         * Creates a managed instance group using the information that you specify in the request. After the group is created, instances in the group are created using the specified instance
         * template. This operation is marked as DONE when the group is created even if the instances in the group have not yet been created. You must separately verify the status of the
         * individual instances with the listmanagedinstances method. A regional managed instance group can contain up to 2000 instances.
         */
        await gapi.client.compute.regionInstanceGroupManagers.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            autoHealingPolicies: [
                {
                    healthCheck: "Test string",
                    initialDelaySec: 42,
                }
            ],
            baseInstanceName: "Test string",
            creationTimestamp: "Test string",
            currentActions: {
                abandoning: 42,
                creating: 42,
                creatingWithoutRetries: 42,
                deleting: 42,
                none: 42,
                recreating: 42,
                refreshing: 42,
                restarting: 42,
                resuming: 42,
                starting: 42,
                stopping: 42,
                suspending: 42,
                verifying: 42,
            },
            description: "Test string",
            distributionPolicy: {
                targetShape: "Test string",
                zones: [
                    {
                        zone: "Test string",
                    }
                ],
            },
            fingerprint: "Test string",
            id: "Test string",
            instanceGroup: "Test string",
            instanceTemplate: "Test string",
            kind: "Test string",
            listManagedInstancesResults: "Test string",
            name: "Test string",
            namedPorts: [
                {
                    name: "Test string",
                    port: 42,
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            statefulPolicy: {
                preservedState: {
                    disks: {
                        A: {
                            autoDelete: "Test string",
                        }
                    },
                },
            },
            status: {
                autoscaler: "Test string",
                isStable: true,
                stateful: {
                    hasStatefulConfig: true,
                    perInstanceConfigs: {
                        allEffective: true,
                    },
                },
                versionTarget: {
                    isReached: true,
                },
            },
            targetPools: [
                "Test string"
            ],
            targetSize: 42,
            updatePolicy: {
                instanceRedistributionType: "Test string",
                maxSurge: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                maxUnavailable: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                minimalAction: "Test string",
                mostDisruptiveAllowedAction: "Test string",
                replacementMethod: "Test string",
                type: "Test string",
            },
            versions: [
                {
                    instanceTemplate: "Test string",
                    name: "Test string",
                    targetSize: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                }
            ],
            zone: "Test string",
        });
        /** Retrieves the list of managed instance groups that are contained within the specified region. */
        await gapi.client.compute.regionInstanceGroupManagers.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists all errors thrown by actions on instances for a given regional managed instance group. The filter and orderBy query parameters are not supported. */
        await gapi.client.compute.regionInstanceGroupManagers.listErrors({
            filter: "Test string",
            instanceGroupManager: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Lists the instances in the managed instance group and instances that are scheduled to be created. The list includes any current actions that the group has scheduled for its instances.
         * The orderBy query parameter is not supported. The `pageToken` query parameter is supported only in the alpha and beta API and only if the group's `listManagedInstancesResults` field is
         * set to `PAGINATED`.
         */
        await gapi.client.compute.regionInstanceGroupManagers.listManagedInstances({
            filter: "Test string",
            instanceGroupManager: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists all of the per-instance configurations defined for the managed instance group. The orderBy query parameter is not supported. */
        await gapi.client.compute.regionInstanceGroupManagers.listPerInstanceConfigs({
            filter: "Test string",
            instanceGroupManager: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Updates a managed instance group using the information that you specify in the request. This operation is marked as DONE when the group is patched even if the instances in the group are
         * still in the process of being patched. You must separately verify the status of the individual instances with the listmanagedinstances method. This method supports PATCH semantics and
         * uses the JSON merge patch format and processing rules. If you update your group to specify a new template or instance configuration, it's possible that your intended specification for
         * each VM in the group is different from the current state of that VM. To learn how to apply an updated configuration to the VMs in a MIG, see Updating instances in a MIG.
         */
        await gapi.client.compute.regionInstanceGroupManagers.patch({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            autoHealingPolicies: [
                {
                    healthCheck: "Test string",
                    initialDelaySec: 42,
                }
            ],
            baseInstanceName: "Test string",
            creationTimestamp: "Test string",
            currentActions: {
                abandoning: 42,
                creating: 42,
                creatingWithoutRetries: 42,
                deleting: 42,
                none: 42,
                recreating: 42,
                refreshing: 42,
                restarting: 42,
                resuming: 42,
                starting: 42,
                stopping: 42,
                suspending: 42,
                verifying: 42,
            },
            description: "Test string",
            distributionPolicy: {
                targetShape: "Test string",
                zones: [
                    {
                        zone: "Test string",
                    }
                ],
            },
            fingerprint: "Test string",
            id: "Test string",
            instanceGroup: "Test string",
            instanceTemplate: "Test string",
            kind: "Test string",
            listManagedInstancesResults: "Test string",
            name: "Test string",
            namedPorts: [
                {
                    name: "Test string",
                    port: 42,
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            statefulPolicy: {
                preservedState: {
                    disks: {
                        A: {
                            autoDelete: "Test string",
                        }
                    },
                },
            },
            status: {
                autoscaler: "Test string",
                isStable: true,
                stateful: {
                    hasStatefulConfig: true,
                    perInstanceConfigs: {
                        allEffective: true,
                    },
                },
                versionTarget: {
                    isReached: true,
                },
            },
            targetPools: [
                "Test string"
            ],
            targetSize: 42,
            updatePolicy: {
                instanceRedistributionType: "Test string",
                maxSurge: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                maxUnavailable: {
                    calculated: 42,
                    fixed: 42,
                    percent: 42,
                },
                minimalAction: "Test string",
                mostDisruptiveAllowedAction: "Test string",
                replacementMethod: "Test string",
                type: "Test string",
            },
            versions: [
                {
                    instanceTemplate: "Test string",
                    name: "Test string",
                    targetSize: {
                        calculated: 42,
                        fixed: 42,
                        percent: 42,
                    },
                }
            ],
            zone: "Test string",
        });
        /** Inserts or patches per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. */
        await gapi.client.compute.regionInstanceGroupManagers.patchPerInstanceConfigs({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            perInstanceConfigs: [
                {
                    fingerprint: "Test string",
                    name: "Test string",
                    preservedState: {
                        disks: {
                            A: {
                                autoDelete: "Test string",
                                mode: "Test string",
                                source: "Test string",
                            }
                        },
                        metadata: {
                            A: "Test string"
                        },
                    },
                    status: "Test string",
                }
            ],
        });
        /**
         * Flags the specified VM instances in the managed instance group to be immediately recreated. Each instance is recreated using the group's current configuration. This operation is marked
         * as DONE when the flag is set even if the instances have not yet been recreated. You must separately verify the status of each instance by checking its currentAction field; for more
         * information, see Checking the status of managed instances. If the group is part of a backend service that has enabled connection draining, it can take up to 60 seconds after the
         * connection draining duration has elapsed before the VM instance is removed or deleted. You can specify a maximum of 1000 instances with this method per request.
         */
        await gapi.client.compute.regionInstanceGroupManagers.recreateInstances({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            instances: [
                "Test string"
            ],
        });
        /**
         * Changes the intended size of the managed instance group. If you increase the size, the group creates new instances using the current instance template. If you decrease the size, the
         * group deletes one or more instances. The resize operation is marked DONE if the resize request is successful. The underlying actions take additional time. You must separately verify the
         * status of the creating or deleting actions with the listmanagedinstances method. If the group is part of a backend service that has enabled connection draining, it can take up to 60
         * seconds after the connection draining duration has elapsed before the VM instance is removed or deleted.
         */
        await gapi.client.compute.regionInstanceGroupManagers.resize({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            size: 42,
        });
        /** Sets the instance template to use when creating new instances or recreating instances in this group. Existing instances are not affected. */
        await gapi.client.compute.regionInstanceGroupManagers.setInstanceTemplate({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            instanceTemplate: "Test string",
        });
        /** Modifies the target pools to which all new instances in this group are assigned. Existing instances in the group are not affected. */
        await gapi.client.compute.regionInstanceGroupManagers.setTargetPools({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            fingerprint: "Test string",
            targetPools: [
                "Test string"
            ],
        });
        /** Inserts or updates per-instance configurations for the managed instance group. perInstanceConfig.name serves as a key used to distinguish whether to perform insert or patch. */
        await gapi.client.compute.regionInstanceGroupManagers.updatePerInstanceConfigs({
            instanceGroupManager: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            perInstanceConfigs: [
                {
                    fingerprint: "Test string",
                    name: "Test string",
                    preservedState: {
                        disks: {
                            A: {
                                autoDelete: "Test string",
                                mode: "Test string",
                                source: "Test string",
                            }
                        },
                        metadata: {
                            A: "Test string"
                        },
                    },
                    status: "Test string",
                }
            ],
        });
        /** Returns the specified instance group resource. */
        await gapi.client.compute.regionInstanceGroups.get({
            instanceGroup: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Retrieves the list of instance group resources contained within the specified region. */
        await gapi.client.compute.regionInstanceGroups.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Lists the instances in the specified instance group and displays information about the named ports. Depending on the specified options, this method can list all instances or only the
         * instances that are running. The orderBy query parameter is not supported.
         */
        await gapi.client.compute.regionInstanceGroups.listInstances({
            filter: "Test string",
            instanceGroup: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        }, {
            instanceState: "Test string",
            portName: "Test string",
        });
        /** Sets the named ports for the specified regional instance group. */
        await gapi.client.compute.regionInstanceGroups.setNamedPorts({
            instanceGroup: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            fingerprint: "Test string",
            namedPorts: [
                {
                    name: "Test string",
                    port: 42,
                }
            ],
        });
        /** Creates multiple instances in a given region. Count specifies the number of instances to create. */
        await gapi.client.compute.regionInstances.bulkInsert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            count: "Test string",
            instanceProperties: {
                advancedMachineFeatures: {
                    enableNestedVirtualization: true,
                    enableUefiNetworking: true,
                    threadsPerCore: 42,
                    visibleCoreCount: 42,
                },
                canIpForward: true,
                confidentialInstanceConfig: {
                    enableConfidentialCompute: true,
                },
                description: "Test string",
                disks: [
                    {
                        architecture: "Test string",
                        autoDelete: true,
                        boot: true,
                        deviceName: "Test string",
                        diskEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        diskSizeGb: "Test string",
                        forceAttach: true,
                        guestOsFeatures: [
                            {
                                type: "Test string",
                            }
                        ],
                        index: 42,
                        initializeParams: {
                            architecture: "Test string",
                            description: "Test string",
                            diskName: "Test string",
                            diskSizeGb: "Test string",
                            diskType: "Test string",
                            labels: {
                                A: "Test string"
                            },
                            licenses: [
                                "Test string"
                            ],
                            onUpdateAction: "Test string",
                            provisionedIops: "Test string",
                            provisionedThroughput: "Test string",
                            replicaZones: [
                                "Test string"
                            ],
                            resourceManagerTags: {
                                A: "Test string"
                            },
                            resourcePolicies: [
                                "Test string"
                            ],
                            sourceImage: "Test string",
                            sourceImageEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                            sourceSnapshot: "Test string",
                            sourceSnapshotEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                        },
                        interface: "Test string",
                        kind: "Test string",
                        licenses: [
                            "Test string"
                        ],
                        mode: "Test string",
                        savedState: "Test string",
                        shieldedInstanceInitialState: {
                            dbs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            dbxs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            keks: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            pk: {
                                content: "Test string",
                                fileType: "Test string",
                            },
                        },
                        source: "Test string",
                        type: "Test string",
                    }
                ],
                guestAccelerators: [
                    {
                        acceleratorCount: 42,
                        acceleratorType: "Test string",
                    }
                ],
                keyRevocationActionType: "Test string",
                labels: {
                    A: "Test string"
                },
                machineType: "Test string",
                metadata: {
                    fingerprint: "Test string",
                    items: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    kind: "Test string",
                },
                minCpuPlatform: "Test string",
                networkInterfaces: [
                    {
                        accessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        aliasIpRanges: [
                            {
                                ipCidrRange: "Test string",
                                subnetworkRangeName: "Test string",
                            }
                        ],
                        fingerprint: "Test string",
                        internalIpv6PrefixLength: 42,
                        ipv6AccessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        ipv6AccessType: "Test string",
                        ipv6Address: "Test string",
                        kind: "Test string",
                        name: "Test string",
                        network: "Test string",
                        networkAttachment: "Test string",
                        networkIP: "Test string",
                        nicType: "Test string",
                        queueCount: 42,
                        stackType: "Test string",
                        subnetwork: "Test string",
                    }
                ],
                networkPerformanceConfig: {
                    totalEgressBandwidthTier: "Test string",
                },
                privateIpv6GoogleAccess: "Test string",
                reservationAffinity: {
                    consumeReservationType: "Test string",
                    key: "Test string",
                    values: [
                        "Test string"
                    ],
                },
                resourceManagerTags: {
                    A: "Test string"
                },
                resourcePolicies: [
                    "Test string"
                ],
                scheduling: {
                    automaticRestart: true,
                    instanceTerminationAction: "Test string",
                    locationHint: "Test string",
                    minNodeCpus: 42,
                    nodeAffinities: [
                        {
                            key: "Test string",
                            operator: "Test string",
                            values: [
                                "Test string"
                            ],
                        }
                    ],
                    onHostMaintenance: "Test string",
                    preemptible: true,
                    provisioningModel: "Test string",
                },
                serviceAccounts: [
                    {
                        email: "Test string",
                        scopes: [
                            "Test string"
                        ],
                    }
                ],
                shieldedInstanceConfig: {
                    enableIntegrityMonitoring: true,
                    enableSecureBoot: true,
                    enableVtpm: true,
                },
                tags: {
                    fingerprint: "Test string",
                    items: [
                        "Test string"
                    ],
                },
            },
            locationPolicy: {
                locations: {
                    A: {
                        constraints: {
                            maxCount: 42,
                        },
                        preference: "Test string",
                    }
                },
                targetShape: "Test string",
            },
            minCount: "Test string",
            namePattern: "Test string",
            perInstanceProperties: {
                A: {
                    name: "Test string",
                }
            },
            sourceInstanceTemplate: "Test string",
        });
        /** Deletes the specified instance template. Deleting an instance template is permanent and cannot be undone. */
        await gapi.client.compute.regionInstanceTemplates.delete({
            instanceTemplate: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified instance template. */
        await gapi.client.compute.regionInstanceTemplates.get({
            instanceTemplate: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates an instance template in the specified project and region using the global instance template whose URL is included in the request. */
        await gapi.client.compute.regionInstanceTemplates.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            properties: {
                advancedMachineFeatures: {
                    enableNestedVirtualization: true,
                    enableUefiNetworking: true,
                    threadsPerCore: 42,
                    visibleCoreCount: 42,
                },
                canIpForward: true,
                confidentialInstanceConfig: {
                    enableConfidentialCompute: true,
                },
                description: "Test string",
                disks: [
                    {
                        architecture: "Test string",
                        autoDelete: true,
                        boot: true,
                        deviceName: "Test string",
                        diskEncryptionKey: {
                            kmsKeyName: "Test string",
                            kmsKeyServiceAccount: "Test string",
                            rawKey: "Test string",
                            rsaEncryptedKey: "Test string",
                            sha256: "Test string",
                        },
                        diskSizeGb: "Test string",
                        forceAttach: true,
                        guestOsFeatures: [
                            {
                                type: "Test string",
                            }
                        ],
                        index: 42,
                        initializeParams: {
                            architecture: "Test string",
                            description: "Test string",
                            diskName: "Test string",
                            diskSizeGb: "Test string",
                            diskType: "Test string",
                            labels: {
                                A: "Test string"
                            },
                            licenses: [
                                "Test string"
                            ],
                            onUpdateAction: "Test string",
                            provisionedIops: "Test string",
                            provisionedThroughput: "Test string",
                            replicaZones: [
                                "Test string"
                            ],
                            resourceManagerTags: {
                                A: "Test string"
                            },
                            resourcePolicies: [
                                "Test string"
                            ],
                            sourceImage: "Test string",
                            sourceImageEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                            sourceSnapshot: "Test string",
                            sourceSnapshotEncryptionKey: {
                                kmsKeyName: "Test string",
                                kmsKeyServiceAccount: "Test string",
                                rawKey: "Test string",
                                rsaEncryptedKey: "Test string",
                                sha256: "Test string",
                            },
                        },
                        interface: "Test string",
                        kind: "Test string",
                        licenses: [
                            "Test string"
                        ],
                        mode: "Test string",
                        savedState: "Test string",
                        shieldedInstanceInitialState: {
                            dbs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            dbxs: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            keks: [
                                {
                                    content: "Test string",
                                    fileType: "Test string",
                                }
                            ],
                            pk: {
                                content: "Test string",
                                fileType: "Test string",
                            },
                        },
                        source: "Test string",
                        type: "Test string",
                    }
                ],
                guestAccelerators: [
                    {
                        acceleratorCount: 42,
                        acceleratorType: "Test string",
                    }
                ],
                keyRevocationActionType: "Test string",
                labels: {
                    A: "Test string"
                },
                machineType: "Test string",
                metadata: {
                    fingerprint: "Test string",
                    items: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    kind: "Test string",
                },
                minCpuPlatform: "Test string",
                networkInterfaces: [
                    {
                        accessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        aliasIpRanges: [
                            {
                                ipCidrRange: "Test string",
                                subnetworkRangeName: "Test string",
                            }
                        ],
                        fingerprint: "Test string",
                        internalIpv6PrefixLength: 42,
                        ipv6AccessConfigs: [
                            {
                                externalIpv6: "Test string",
                                externalIpv6PrefixLength: 42,
                                kind: "Test string",
                                name: "Test string",
                                natIP: "Test string",
                                networkTier: "Test string",
                                publicPtrDomainName: "Test string",
                                setPublicPtr: true,
                                type: "Test string",
                            }
                        ],
                        ipv6AccessType: "Test string",
                        ipv6Address: "Test string",
                        kind: "Test string",
                        name: "Test string",
                        network: "Test string",
                        networkAttachment: "Test string",
                        networkIP: "Test string",
                        nicType: "Test string",
                        queueCount: 42,
                        stackType: "Test string",
                        subnetwork: "Test string",
                    }
                ],
                networkPerformanceConfig: {
                    totalEgressBandwidthTier: "Test string",
                },
                privateIpv6GoogleAccess: "Test string",
                reservationAffinity: {
                    consumeReservationType: "Test string",
                    key: "Test string",
                    values: [
                        "Test string"
                    ],
                },
                resourceManagerTags: {
                    A: "Test string"
                },
                resourcePolicies: [
                    "Test string"
                ],
                scheduling: {
                    automaticRestart: true,
                    instanceTerminationAction: "Test string",
                    locationHint: "Test string",
                    minNodeCpus: 42,
                    nodeAffinities: [
                        {
                            key: "Test string",
                            operator: "Test string",
                            values: [
                                "Test string"
                            ],
                        }
                    ],
                    onHostMaintenance: "Test string",
                    preemptible: true,
                    provisioningModel: "Test string",
                },
                serviceAccounts: [
                    {
                        email: "Test string",
                        scopes: [
                            "Test string"
                        ],
                    }
                ],
                shieldedInstanceConfig: {
                    enableIntegrityMonitoring: true,
                    enableSecureBoot: true,
                    enableVtpm: true,
                },
                tags: {
                    fingerprint: "Test string",
                    items: [
                        "Test string"
                    ],
                },
            },
            region: "Test string",
            selfLink: "Test string",
            sourceInstance: "Test string",
            sourceInstanceParams: {
                diskConfigs: [
                    {
                        autoDelete: true,
                        customImage: "Test string",
                        deviceName: "Test string",
                        instantiateFrom: "Test string",
                    }
                ],
            },
        });
        /** Retrieves a list of instance templates that are contained within the specified project and region. */
        await gapi.client.compute.regionInstanceTemplates.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified network endpoint group. Note that the NEG cannot be deleted if it is configured as a backend of a backend service. */
        await gapi.client.compute.regionNetworkEndpointGroups.delete({
            networkEndpointGroup: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified network endpoint group. */
        await gapi.client.compute.regionNetworkEndpointGroups.get({
            networkEndpointGroup: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Creates a network endpoint group in the specified project using the parameters that are included in the request. */
        await gapi.client.compute.regionNetworkEndpointGroups.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            annotations: {
                A: "Test string"
            },
            appEngine: {
                service: "Test string",
                urlMask: "Test string",
                version: "Test string",
            },
            cloudFunction: {
                function: "Test string",
                urlMask: "Test string",
            },
            cloudRun: {
                service: "Test string",
                tag: "Test string",
                urlMask: "Test string",
            },
            creationTimestamp: "Test string",
            defaultPort: 42,
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            network: "Test string",
            networkEndpointType: "Test string",
            pscData: {
                consumerPscAddress: "Test string",
                pscConnectionId: "Test string",
                pscConnectionStatus: "Test string",
            },
            pscTargetService: "Test string",
            region: "Test string",
            selfLink: "Test string",
            size: 42,
            subnetwork: "Test string",
            zone: "Test string",
        });
        /** Retrieves the list of regional network endpoint groups available to the specified project in the given region. */
        await gapi.client.compute.regionNetworkEndpointGroups.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Inserts an association for the specified network firewall policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.addAssociation({
            firewallPolicy: "Test string",
            project: "Test string",
            region: "Test string",
            replaceExistingAssociation: true,
            requestId: "Test string",
        }, {
            attachmentTarget: "Test string",
            displayName: "Test string",
            firewallPolicyId: "Test string",
            name: "Test string",
            shortName: "Test string",
        });
        /** Inserts a rule into a network firewall policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.addRule({
            firewallPolicy: "Test string",
            maxPriority: 42,
            minPriority: 42,
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            action: "Test string",
            description: "Test string",
            direction: "Test string",
            disabled: true,
            enableLogging: true,
            kind: "Test string",
            match: {
                destAddressGroups: [
                    "Test string"
                ],
                destFqdns: [
                    "Test string"
                ],
                destIpRanges: [
                    "Test string"
                ],
                destRegionCodes: [
                    "Test string"
                ],
                destThreatIntelligences: [
                    "Test string"
                ],
                layer4Configs: [
                    {
                        ipProtocol: "Test string",
                        ports: [
                            "Test string"
                        ],
                    }
                ],
                srcAddressGroups: [
                    "Test string"
                ],
                srcFqdns: [
                    "Test string"
                ],
                srcIpRanges: [
                    "Test string"
                ],
                srcRegionCodes: [
                    "Test string"
                ],
                srcSecureTags: [
                    {
                        name: "Test string",
                        state: "Test string",
                    }
                ],
                srcThreatIntelligences: [
                    "Test string"
                ],
            },
            priority: 42,
            ruleName: "Test string",
            ruleTupleCount: 42,
            targetResources: [
                "Test string"
            ],
            targetSecureTags: [
                {
                    name: "Test string",
                    state: "Test string",
                }
            ],
            targetServiceAccounts: [
                "Test string"
            ],
        });
        /** Copies rules to the specified network firewall policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.cloneRules({
            firewallPolicy: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            sourceFirewallPolicy: "Test string",
        });
        /** Deletes the specified network firewall policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.delete({
            firewallPolicy: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified network firewall policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.get({
            firewallPolicy: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Gets an association with the specified name. */
        await gapi.client.compute.regionNetworkFirewallPolicies.getAssociation({
            firewallPolicy: "Test string",
            name: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Returns the effective firewalls on a given network. */
        await gapi.client.compute.regionNetworkFirewallPolicies.getEffectiveFirewalls({
            network: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.regionNetworkFirewallPolicies.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Gets a rule of the specified priority. */
        await gapi.client.compute.regionNetworkFirewallPolicies.getRule({
            firewallPolicy: "Test string",
            priority: 42,
            project: "Test string",
            region: "Test string",
        });
        /** Creates a new network firewall policy in the specified project and region. */
        await gapi.client.compute.regionNetworkFirewallPolicies.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            associations: [
                {
                    attachmentTarget: "Test string",
                    displayName: "Test string",
                    firewallPolicyId: "Test string",
                    name: "Test string",
                    shortName: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            displayName: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            parent: "Test string",
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    direction: "Test string",
                    disabled: true,
                    enableLogging: true,
                    kind: "Test string",
                    match: {
                        destAddressGroups: [
                            "Test string"
                        ],
                        destFqdns: [
                            "Test string"
                        ],
                        destIpRanges: [
                            "Test string"
                        ],
                        destRegionCodes: [
                            "Test string"
                        ],
                        destThreatIntelligences: [
                            "Test string"
                        ],
                        layer4Configs: [
                            {
                                ipProtocol: "Test string",
                                ports: [
                                    "Test string"
                                ],
                            }
                        ],
                        srcAddressGroups: [
                            "Test string"
                        ],
                        srcFqdns: [
                            "Test string"
                        ],
                        srcIpRanges: [
                            "Test string"
                        ],
                        srcRegionCodes: [
                            "Test string"
                        ],
                        srcSecureTags: [
                            {
                                name: "Test string",
                                state: "Test string",
                            }
                        ],
                        srcThreatIntelligences: [
                            "Test string"
                        ],
                    },
                    priority: 42,
                    ruleName: "Test string",
                    ruleTupleCount: 42,
                    targetResources: [
                        "Test string"
                    ],
                    targetSecureTags: [
                        {
                            name: "Test string",
                            state: "Test string",
                        }
                    ],
                    targetServiceAccounts: [
                        "Test string"
                    ],
                }
            ],
            ruleTupleCount: 42,
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            shortName: "Test string",
        });
        /** Lists all the network firewall policies that have been configured for the specified project in the given region. */
        await gapi.client.compute.regionNetworkFirewallPolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified network firewall policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.patch({
            firewallPolicy: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            associations: [
                {
                    attachmentTarget: "Test string",
                    displayName: "Test string",
                    firewallPolicyId: "Test string",
                    name: "Test string",
                    shortName: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            displayName: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            parent: "Test string",
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    direction: "Test string",
                    disabled: true,
                    enableLogging: true,
                    kind: "Test string",
                    match: {
                        destAddressGroups: [
                            "Test string"
                        ],
                        destFqdns: [
                            "Test string"
                        ],
                        destIpRanges: [
                            "Test string"
                        ],
                        destRegionCodes: [
                            "Test string"
                        ],
                        destThreatIntelligences: [
                            "Test string"
                        ],
                        layer4Configs: [
                            {
                                ipProtocol: "Test string",
                                ports: [
                                    "Test string"
                                ],
                            }
                        ],
                        srcAddressGroups: [
                            "Test string"
                        ],
                        srcFqdns: [
                            "Test string"
                        ],
                        srcIpRanges: [
                            "Test string"
                        ],
                        srcRegionCodes: [
                            "Test string"
                        ],
                        srcSecureTags: [
                            {
                                name: "Test string",
                                state: "Test string",
                            }
                        ],
                        srcThreatIntelligences: [
                            "Test string"
                        ],
                    },
                    priority: 42,
                    ruleName: "Test string",
                    ruleTupleCount: 42,
                    targetResources: [
                        "Test string"
                    ],
                    targetSecureTags: [
                        {
                            name: "Test string",
                            state: "Test string",
                        }
                    ],
                    targetServiceAccounts: [
                        "Test string"
                    ],
                }
            ],
            ruleTupleCount: 42,
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            shortName: "Test string",
        });
        /** Patches a rule of the specified priority. */
        await gapi.client.compute.regionNetworkFirewallPolicies.patchRule({
            firewallPolicy: "Test string",
            priority: 42,
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            action: "Test string",
            description: "Test string",
            direction: "Test string",
            disabled: true,
            enableLogging: true,
            kind: "Test string",
            match: {
                destAddressGroups: [
                    "Test string"
                ],
                destFqdns: [
                    "Test string"
                ],
                destIpRanges: [
                    "Test string"
                ],
                destRegionCodes: [
                    "Test string"
                ],
                destThreatIntelligences: [
                    "Test string"
                ],
                layer4Configs: [
                    {
                        ipProtocol: "Test string",
                        ports: [
                            "Test string"
                        ],
                    }
                ],
                srcAddressGroups: [
                    "Test string"
                ],
                srcFqdns: [
                    "Test string"
                ],
                srcIpRanges: [
                    "Test string"
                ],
                srcRegionCodes: [
                    "Test string"
                ],
                srcSecureTags: [
                    {
                        name: "Test string",
                        state: "Test string",
                    }
                ],
                srcThreatIntelligences: [
                    "Test string"
                ],
            },
            priority: 42,
            ruleName: "Test string",
            ruleTupleCount: 42,
            targetResources: [
                "Test string"
            ],
            targetSecureTags: [
                {
                    name: "Test string",
                    state: "Test string",
                }
            ],
            targetServiceAccounts: [
                "Test string"
            ],
        });
        /** Removes an association for the specified network firewall policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.removeAssociation({
            firewallPolicy: "Test string",
            name: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Deletes a rule of the specified priority. */
        await gapi.client.compute.regionNetworkFirewallPolicies.removeRule({
            firewallPolicy: "Test string",
            priority: 42,
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.regionNetworkFirewallPolicies.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.regionNetworkFirewallPolicies.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Deletes the specified NotificationEndpoint in the given region */
        await gapi.client.compute.regionNotificationEndpoints.delete({
            notificationEndpoint: "Test string",
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        });
        /** Returns the specified NotificationEndpoint resource in the given region. */
        await gapi.client.compute.regionNotificationEndpoints.get({
            notificationEndpoint: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Create a NotificationEndpoint in the specified project in the given region using the parameters that are included in the request. */
        await gapi.client.compute.regionNotificationEndpoints.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            grpcSettings: {
                authority: "Test string",
                endpoint: "Test string",
                payloadName: "Test string",
                resendInterval: {
                    nanos: 42,
                    seconds: "Test string",
                },
                retryDurationSec: 42,
            },
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
        });
        /** Lists the NotificationEndpoints for a project in the given region. */
        await gapi.client.compute.regionNotificationEndpoints.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified region-specific Operations resource. */
        await gapi.client.compute.regionOperations.delete({
            operation: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Retrieves the specified region-specific Operations resource. */
        await gapi.client.compute.regionOperations.get({
            operation: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /** Retrieves a list of Operation resources contained within the specified region. */
        await gapi.client.compute.regionOperations.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method differs
         * from the `GET` method in that it waits for no more than the default deadline (2 minutes) and then returns the current state of the operation, which might be `DONE` or still in progress.
         * This method is called on a best-effort basis. Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might
         * return after zero seconds. - If the default deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation
         * is not `DONE`.
         */
        await gapi.client.compute.regionOperations.wait({
            operation: "Test string",
            project: "Test string",
            region: "Test string",
        });
        /**
         * Returns the specified Region resource. To decrease latency for this method, you can optionally omit any unneeded information from the response by using a field mask. This practice is
         * especially recommended for unused quota information (the `quotas` field). To exclude one or more fields, set your request's `fields` query parameter to only include the fields you need.
         * For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
         */
        await gapi.client.compute.regions.get({
            project: "Test string",
            region: "Test string",
        });
        /**
         * Retrieves the list of region resources available to the specified project. To decrease latency for this method, you can optionally omit any unneeded information from the response by
         * using a field mask. This practice is especially recommended for unused quota information (the `items.quotas` field). To exclude one or more fields, set your request's `fields` query
         * parameter to only include the fields you need. For example, to only include the `id` and `selfLink` fields, add the query parameter `?fields=id,selfLink` to your request.
         */
        await gapi.client.compute.regions.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified policy. */
        await gapi.client.compute.regionSecurityPolicies.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            securityPolicy: "Test string",
        });
        /** List all of the ordered rules present in a single specified policy. */
        await gapi.client.compute.regionSecurityPolicies.get({
            project: "Test string",
            region: "Test string",
            securityPolicy: "Test string",
        });
        /** Creates a new policy in the specified project using the data included in the request. */
        await gapi.client.compute.regionSecurityPolicies.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            validateOnly: true,
        }, {
            adaptiveProtectionConfig: {
                layer7DdosDefenseConfig: {
                    enable: true,
                    ruleVisibility: "Test string",
                },
            },
            advancedOptionsConfig: {
                jsonCustomConfig: {
                    contentTypes: [
                        "Test string"
                    ],
                },
                jsonParsing: "Test string",
                logLevel: "Test string",
            },
            creationTimestamp: "Test string",
            ddosProtectionConfig: {
                ddosProtection: "Test string",
            },
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            recaptchaOptionsConfig: {
                redirectSiteKey: "Test string",
            },
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdds: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                            }
                        ],
                    },
                    kind: "Test string",
                    match: {
                        config: {
                            srcIpRanges: [
                                "Test string"
                            ],
                        },
                        expr: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        versionedExpr: "Test string",
                    },
                    preconfiguredWafConfig: {
                        exclusions: [
                            {
                                requestCookiesToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestHeadersToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestQueryParamsToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestUrisToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                targetRuleIds: [
                                    "Test string"
                                ],
                                targetRuleSet: "Test string",
                            }
                        ],
                    },
                    preview: true,
                    priority: 42,
                    rateLimitOptions: {
                        banDurationSec: 42,
                        banThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                        conformAction: "Test string",
                        enforceOnKey: "Test string",
                        enforceOnKeyConfigs: [
                            {
                                enforceOnKeyName: "Test string",
                                enforceOnKeyType: "Test string",
                            }
                        ],
                        enforceOnKeyName: "Test string",
                        exceedAction: "Test string",
                        exceedRedirectOptions: {
                            target: "Test string",
                            type: "Test string",
                        },
                        rateLimitThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                    },
                    redirectOptions: {
                        target: "Test string",
                        type: "Test string",
                    },
                }
            ],
            selfLink: "Test string",
            type: "Test string",
        });
        /** List all the policies that have been configured for the specified project and region. */
        await gapi.client.compute.regionSecurityPolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Patches the specified policy with the data included in the request. To clear fields in the rule, leave the fields empty and specify them in the updateMask. This cannot be used to be
         * update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead.
         */
        await gapi.client.compute.regionSecurityPolicies.patch({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            securityPolicy: "Test string",
        }, {
            adaptiveProtectionConfig: {
                layer7DdosDefenseConfig: {
                    enable: true,
                    ruleVisibility: "Test string",
                },
            },
            advancedOptionsConfig: {
                jsonCustomConfig: {
                    contentTypes: [
                        "Test string"
                    ],
                },
                jsonParsing: "Test string",
                logLevel: "Test string",
            },
            creationTimestamp: "Test string",
            ddosProtectionConfig: {
                ddosProtection: "Test string",
            },
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            recaptchaOptionsConfig: {
                redirectSiteKey: "Test string",
            },
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdds: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                            }
                        ],
                    },
                    kind: "Test string",
                    match: {
                        config: {
                            srcIpRanges: [
                                "Test string"
                            ],
                        },
                        expr: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        versionedExpr: "Test string",
                    },
                    preconfiguredWafConfig: {
                        exclusions: [
                            {
                                requestCookiesToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestHeadersToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestQueryParamsToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestUrisToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                targetRuleIds: [
                                    "Test string"
                                ],
                                targetRuleSet: "Test string",
                            }
                        ],
                    },
                    preview: true,
                    priority: 42,
                    rateLimitOptions: {
                        banDurationSec: 42,
                        banThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                        conformAction: "Test string",
                        enforceOnKey: "Test string",
                        enforceOnKeyConfigs: [
                            {
                                enforceOnKeyName: "Test string",
                                enforceOnKeyType: "Test string",
                            }
                        ],
                        enforceOnKeyName: "Test string",
                        exceedAction: "Test string",
                        exceedRedirectOptions: {
                            target: "Test string",
                            type: "Test string",
                        },
                        rateLimitThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                    },
                    redirectOptions: {
                        target: "Test string",
                        type: "Test string",
                    },
                }
            ],
            selfLink: "Test string",
            type: "Test string",
        });
        /** Deletes the specified SslCertificate resource in the region. */
        await gapi.client.compute.regionSslCertificates.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            sslCertificate: "Test string",
        });
        /** Returns the specified SslCertificate resource in the specified region. Get a list of available SSL certificates by making a list() request. */
        await gapi.client.compute.regionSslCertificates.get({
            project: "Test string",
            region: "Test string",
            sslCertificate: "Test string",
        });
        /** Creates a SslCertificate resource in the specified project and region using the data included in the request */
        await gapi.client.compute.regionSslCertificates.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            certificate: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            expireTime: "Test string",
            id: "Test string",
            kind: "Test string",
            managed: {
                domains: [
                    "Test string"
                ],
                domainStatus: {
                    A: "Test string"
                },
                status: "Test string",
            },
            name: "Test string",
            privateKey: "Test string",
            region: "Test string",
            selfLink: "Test string",
            selfManaged: {
                certificate: "Test string",
                privateKey: "Test string",
            },
            subjectAlternativeNames: [
                "Test string"
            ],
            type: "Test string",
        });
        /** Retrieves the list of SslCertificate resources available to the specified project in the specified region. */
        await gapi.client.compute.regionSslCertificates.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources. */
        await gapi.client.compute.regionSslPolicies.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            sslPolicy: "Test string",
        });
        /** Lists all of the ordered rules present in a single specified policy. */
        await gapi.client.compute.regionSslPolicies.get({
            project: "Test string",
            region: "Test string",
            sslPolicy: "Test string",
        });
        /** Creates a new policy in the specified project and region using the data included in the request. */
        await gapi.client.compute.regionSslPolicies.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            customFeatures: [
                "Test string"
            ],
            description: "Test string",
            enabledFeatures: [
                "Test string"
            ],
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            minTlsVersion: "Test string",
            name: "Test string",
            profile: "Test string",
            region: "Test string",
            selfLink: "Test string",
            warnings: [
                {
                    code: "Test string",
                    data: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    message: "Test string",
                }
            ],
        });
        /** Lists all the SSL policies that have been configured for the specified project and region. */
        await gapi.client.compute.regionSslPolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists all features that can be specified in the SSL policy when using custom profile. */
        await gapi.client.compute.regionSslPolicies.listAvailableFeatures({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified SSL policy with the data included in the request. */
        await gapi.client.compute.regionSslPolicies.patch({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            sslPolicy: "Test string",
        }, {
            creationTimestamp: "Test string",
            customFeatures: [
                "Test string"
            ],
            description: "Test string",
            enabledFeatures: [
                "Test string"
            ],
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            minTlsVersion: "Test string",
            name: "Test string",
            profile: "Test string",
            region: "Test string",
            selfLink: "Test string",
            warnings: [
                {
                    code: "Test string",
                    data: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    message: "Test string",
                }
            ],
        });
        /** Deletes the specified TargetHttpProxy resource. */
        await gapi.client.compute.regionTargetHttpProxies.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetHttpProxy: "Test string",
        });
        /** Returns the specified TargetHttpProxy resource in the specified region. */
        await gapi.client.compute.regionTargetHttpProxies.get({
            project: "Test string",
            region: "Test string",
            targetHttpProxy: "Test string",
        });
        /** Creates a TargetHttpProxy resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.regionTargetHttpProxies.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            region: "Test string",
            selfLink: "Test string",
            urlMap: "Test string",
        });
        /** Retrieves the list of TargetHttpProxy resources available to the specified project in the specified region. */
        await gapi.client.compute.regionTargetHttpProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Changes the URL map for TargetHttpProxy. */
        await gapi.client.compute.regionTargetHttpProxies.setUrlMap({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetHttpProxy: "Test string",
        }, {
            urlMap: "Test string",
        });
        /** Deletes the specified TargetHttpsProxy resource. */
        await gapi.client.compute.regionTargetHttpsProxies.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        });
        /** Returns the specified TargetHttpsProxy resource in the specified region. */
        await gapi.client.compute.regionTargetHttpsProxies.get({
            project: "Test string",
            region: "Test string",
            targetHttpsProxy: "Test string",
        });
        /** Creates a TargetHttpsProxy resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.regionTargetHttpsProxies.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            authorizationPolicy: "Test string",
            certificateMap: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            quicOverride: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serverTlsPolicy: "Test string",
            sslCertificates: [
                "Test string"
            ],
            sslPolicy: "Test string",
            urlMap: "Test string",
        });
        /** Retrieves the list of TargetHttpsProxy resources available to the specified project in the specified region. */
        await gapi.client.compute.regionTargetHttpsProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Patches the specified regional TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing
         * rules.
         */
        await gapi.client.compute.regionTargetHttpsProxies.patch({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            authorizationPolicy: "Test string",
            certificateMap: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            quicOverride: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serverTlsPolicy: "Test string",
            sslCertificates: [
                "Test string"
            ],
            sslPolicy: "Test string",
            urlMap: "Test string",
        });
        /** Replaces SslCertificates for TargetHttpsProxy. */
        await gapi.client.compute.regionTargetHttpsProxies.setSslCertificates({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            sslCertificates: [
                "Test string"
            ],
        });
        /** Changes the URL map for TargetHttpsProxy. */
        await gapi.client.compute.regionTargetHttpsProxies.setUrlMap({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            urlMap: "Test string",
        });
        /** Deletes the specified TargetTcpProxy resource. */
        await gapi.client.compute.regionTargetTcpProxies.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetTcpProxy: "Test string",
        });
        /** Returns the specified TargetTcpProxy resource. */
        await gapi.client.compute.regionTargetTcpProxies.get({
            project: "Test string",
            region: "Test string",
            targetTcpProxy: "Test string",
        });
        /** Creates a TargetTcpProxy resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.regionTargetTcpProxies.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            proxyHeader: "Test string",
            region: "Test string",
            selfLink: "Test string",
            service: "Test string",
        });
        /** Retrieves a list of TargetTcpProxy resources available to the specified project in a given region. */
        await gapi.client.compute.regionTargetTcpProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified UrlMap resource. */
        await gapi.client.compute.regionUrlMaps.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            urlMap: "Test string",
        });
        /** Returns the specified UrlMap resource. */
        await gapi.client.compute.regionUrlMaps.get({
            project: "Test string",
            region: "Test string",
            urlMap: "Test string",
        });
        /** Creates a UrlMap resource in the specified project using the data included in the request. */
        await gapi.client.compute.regionUrlMaps.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            defaultRouteAction: {
                corsPolicy: {
                    allowCredentials: true,
                    allowHeaders: [
                        "Test string"
                    ],
                    allowMethods: [
                        "Test string"
                    ],
                    allowOriginRegexes: [
                        "Test string"
                    ],
                    allowOrigins: [
                        "Test string"
                    ],
                    disabled: true,
                    exposeHeaders: [
                        "Test string"
                    ],
                    maxAge: 42,
                },
                faultInjectionPolicy: {
                    abort: {
                        httpStatus: 42,
                        percentage: 42,
                    },
                    delay: {
                        fixedDelay: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        percentage: 42,
                    },
                },
                maxStreamDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                requestMirrorPolicy: {
                    backendService: "Test string",
                },
                retryPolicy: {
                    numRetries: 42,
                    perTryTimeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    retryConditions: [
                        "Test string"
                    ],
                },
                timeout: {
                    nanos: 42,
                    seconds: "Test string",
                },
                urlRewrite: {
                    hostRewrite: "Test string",
                    pathPrefixRewrite: "Test string",
                    pathTemplateRewrite: "Test string",
                },
                weightedBackendServices: [
                    {
                        backendService: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        weight: 42,
                    }
                ],
            },
            defaultService: "Test string",
            defaultUrlRedirect: {
                hostRedirect: "Test string",
                httpsRedirect: true,
                pathRedirect: "Test string",
                prefixRedirect: "Test string",
                redirectResponseCode: "Test string",
                stripQuery: true,
            },
            description: "Test string",
            fingerprint: "Test string",
            headerAction: {
                requestHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                requestHeadersToRemove: [
                    "Test string"
                ],
                responseHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                responseHeadersToRemove: [
                    "Test string"
                ],
            },
            hostRules: [
                {
                    description: "Test string",
                    hosts: [
                        "Test string"
                    ],
                    pathMatcher: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            pathMatchers: [
                {
                    defaultRouteAction: {
                        corsPolicy: {
                            allowCredentials: true,
                            allowHeaders: [
                                "Test string"
                            ],
                            allowMethods: [
                                "Test string"
                            ],
                            allowOriginRegexes: [
                                "Test string"
                            ],
                            allowOrigins: [
                                "Test string"
                            ],
                            disabled: true,
                            exposeHeaders: [
                                "Test string"
                            ],
                            maxAge: 42,
                        },
                        faultInjectionPolicy: {
                            abort: {
                                httpStatus: 42,
                                percentage: 42,
                            },
                            delay: {
                                fixedDelay: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                percentage: 42,
                            },
                        },
                        maxStreamDuration: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        requestMirrorPolicy: {
                            backendService: "Test string",
                        },
                        retryPolicy: {
                            numRetries: 42,
                            perTryTimeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            retryConditions: [
                                "Test string"
                            ],
                        },
                        timeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        urlRewrite: {
                            hostRewrite: "Test string",
                            pathPrefixRewrite: "Test string",
                            pathTemplateRewrite: "Test string",
                        },
                        weightedBackendServices: [
                            {
                                backendService: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                weight: 42,
                            }
                        ],
                    },
                    defaultService: "Test string",
                    defaultUrlRedirect: {
                        hostRedirect: "Test string",
                        httpsRedirect: true,
                        pathRedirect: "Test string",
                        prefixRedirect: "Test string",
                        redirectResponseCode: "Test string",
                        stripQuery: true,
                    },
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        requestHeadersToRemove: [
                            "Test string"
                        ],
                        responseHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        responseHeadersToRemove: [
                            "Test string"
                        ],
                    },
                    name: "Test string",
                    pathRules: [
                        {
                            paths: [
                                "Test string"
                            ],
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                    routeRules: [
                        {
                            description: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            matchRules: [
                                {
                                    fullPathMatch: "Test string",
                                    headerMatches: [
                                        {
                                            exactMatch: "Test string",
                                            headerName: "Test string",
                                            invertMatch: true,
                                            prefixMatch: "Test string",
                                            presentMatch: true,
                                            rangeMatch: {
                                                rangeEnd: "Test string",
                                                rangeStart: "Test string",
                                            },
                                            regexMatch: "Test string",
                                            suffixMatch: "Test string",
                                        }
                                    ],
                                    ignoreCase: true,
                                    metadataFilters: [
                                        {
                                            filterLabels: [
                                                {
                                                    name: "Test string",
                                                    value: "Test string",
                                                }
                                            ],
                                            filterMatchCriteria: "Test string",
                                        }
                                    ],
                                    pathTemplateMatch: "Test string",
                                    prefixMatch: "Test string",
                                    queryParameterMatches: [
                                        {
                                            exactMatch: "Test string",
                                            name: "Test string",
                                            presentMatch: true,
                                            regexMatch: "Test string",
                                        }
                                    ],
                                    regexMatch: "Test string",
                                }
                            ],
                            priority: 42,
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            tests: [
                {
                    description: "Test string",
                    expectedOutputUrl: "Test string",
                    expectedRedirectResponseCode: 42,
                    headers: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    host: "Test string",
                    path: "Test string",
                    service: "Test string",
                }
            ],
        });
        /** Retrieves the list of UrlMap resources available to the specified project in the specified region. */
        await gapi.client.compute.regionUrlMaps.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.regionUrlMaps.patch({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            urlMap: "Test string",
        }, {
            creationTimestamp: "Test string",
            defaultRouteAction: {
                corsPolicy: {
                    allowCredentials: true,
                    allowHeaders: [
                        "Test string"
                    ],
                    allowMethods: [
                        "Test string"
                    ],
                    allowOriginRegexes: [
                        "Test string"
                    ],
                    allowOrigins: [
                        "Test string"
                    ],
                    disabled: true,
                    exposeHeaders: [
                        "Test string"
                    ],
                    maxAge: 42,
                },
                faultInjectionPolicy: {
                    abort: {
                        httpStatus: 42,
                        percentage: 42,
                    },
                    delay: {
                        fixedDelay: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        percentage: 42,
                    },
                },
                maxStreamDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                requestMirrorPolicy: {
                    backendService: "Test string",
                },
                retryPolicy: {
                    numRetries: 42,
                    perTryTimeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    retryConditions: [
                        "Test string"
                    ],
                },
                timeout: {
                    nanos: 42,
                    seconds: "Test string",
                },
                urlRewrite: {
                    hostRewrite: "Test string",
                    pathPrefixRewrite: "Test string",
                    pathTemplateRewrite: "Test string",
                },
                weightedBackendServices: [
                    {
                        backendService: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        weight: 42,
                    }
                ],
            },
            defaultService: "Test string",
            defaultUrlRedirect: {
                hostRedirect: "Test string",
                httpsRedirect: true,
                pathRedirect: "Test string",
                prefixRedirect: "Test string",
                redirectResponseCode: "Test string",
                stripQuery: true,
            },
            description: "Test string",
            fingerprint: "Test string",
            headerAction: {
                requestHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                requestHeadersToRemove: [
                    "Test string"
                ],
                responseHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                responseHeadersToRemove: [
                    "Test string"
                ],
            },
            hostRules: [
                {
                    description: "Test string",
                    hosts: [
                        "Test string"
                    ],
                    pathMatcher: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            pathMatchers: [
                {
                    defaultRouteAction: {
                        corsPolicy: {
                            allowCredentials: true,
                            allowHeaders: [
                                "Test string"
                            ],
                            allowMethods: [
                                "Test string"
                            ],
                            allowOriginRegexes: [
                                "Test string"
                            ],
                            allowOrigins: [
                                "Test string"
                            ],
                            disabled: true,
                            exposeHeaders: [
                                "Test string"
                            ],
                            maxAge: 42,
                        },
                        faultInjectionPolicy: {
                            abort: {
                                httpStatus: 42,
                                percentage: 42,
                            },
                            delay: {
                                fixedDelay: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                percentage: 42,
                            },
                        },
                        maxStreamDuration: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        requestMirrorPolicy: {
                            backendService: "Test string",
                        },
                        retryPolicy: {
                            numRetries: 42,
                            perTryTimeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            retryConditions: [
                                "Test string"
                            ],
                        },
                        timeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        urlRewrite: {
                            hostRewrite: "Test string",
                            pathPrefixRewrite: "Test string",
                            pathTemplateRewrite: "Test string",
                        },
                        weightedBackendServices: [
                            {
                                backendService: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                weight: 42,
                            }
                        ],
                    },
                    defaultService: "Test string",
                    defaultUrlRedirect: {
                        hostRedirect: "Test string",
                        httpsRedirect: true,
                        pathRedirect: "Test string",
                        prefixRedirect: "Test string",
                        redirectResponseCode: "Test string",
                        stripQuery: true,
                    },
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        requestHeadersToRemove: [
                            "Test string"
                        ],
                        responseHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        responseHeadersToRemove: [
                            "Test string"
                        ],
                    },
                    name: "Test string",
                    pathRules: [
                        {
                            paths: [
                                "Test string"
                            ],
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                    routeRules: [
                        {
                            description: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            matchRules: [
                                {
                                    fullPathMatch: "Test string",
                                    headerMatches: [
                                        {
                                            exactMatch: "Test string",
                                            headerName: "Test string",
                                            invertMatch: true,
                                            prefixMatch: "Test string",
                                            presentMatch: true,
                                            rangeMatch: {
                                                rangeEnd: "Test string",
                                                rangeStart: "Test string",
                                            },
                                            regexMatch: "Test string",
                                            suffixMatch: "Test string",
                                        }
                                    ],
                                    ignoreCase: true,
                                    metadataFilters: [
                                        {
                                            filterLabels: [
                                                {
                                                    name: "Test string",
                                                    value: "Test string",
                                                }
                                            ],
                                            filterMatchCriteria: "Test string",
                                        }
                                    ],
                                    pathTemplateMatch: "Test string",
                                    prefixMatch: "Test string",
                                    queryParameterMatches: [
                                        {
                                            exactMatch: "Test string",
                                            name: "Test string",
                                            presentMatch: true,
                                            regexMatch: "Test string",
                                        }
                                    ],
                                    regexMatch: "Test string",
                                }
                            ],
                            priority: 42,
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            tests: [
                {
                    description: "Test string",
                    expectedOutputUrl: "Test string",
                    expectedRedirectResponseCode: 42,
                    headers: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    host: "Test string",
                    path: "Test string",
                    service: "Test string",
                }
            ],
        });
        /** Updates the specified UrlMap resource with the data included in the request. */
        await gapi.client.compute.regionUrlMaps.update({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            urlMap: "Test string",
        }, {
            creationTimestamp: "Test string",
            defaultRouteAction: {
                corsPolicy: {
                    allowCredentials: true,
                    allowHeaders: [
                        "Test string"
                    ],
                    allowMethods: [
                        "Test string"
                    ],
                    allowOriginRegexes: [
                        "Test string"
                    ],
                    allowOrigins: [
                        "Test string"
                    ],
                    disabled: true,
                    exposeHeaders: [
                        "Test string"
                    ],
                    maxAge: 42,
                },
                faultInjectionPolicy: {
                    abort: {
                        httpStatus: 42,
                        percentage: 42,
                    },
                    delay: {
                        fixedDelay: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        percentage: 42,
                    },
                },
                maxStreamDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                requestMirrorPolicy: {
                    backendService: "Test string",
                },
                retryPolicy: {
                    numRetries: 42,
                    perTryTimeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    retryConditions: [
                        "Test string"
                    ],
                },
                timeout: {
                    nanos: 42,
                    seconds: "Test string",
                },
                urlRewrite: {
                    hostRewrite: "Test string",
                    pathPrefixRewrite: "Test string",
                    pathTemplateRewrite: "Test string",
                },
                weightedBackendServices: [
                    {
                        backendService: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        weight: 42,
                    }
                ],
            },
            defaultService: "Test string",
            defaultUrlRedirect: {
                hostRedirect: "Test string",
                httpsRedirect: true,
                pathRedirect: "Test string",
                prefixRedirect: "Test string",
                redirectResponseCode: "Test string",
                stripQuery: true,
            },
            description: "Test string",
            fingerprint: "Test string",
            headerAction: {
                requestHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                requestHeadersToRemove: [
                    "Test string"
                ],
                responseHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                responseHeadersToRemove: [
                    "Test string"
                ],
            },
            hostRules: [
                {
                    description: "Test string",
                    hosts: [
                        "Test string"
                    ],
                    pathMatcher: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            pathMatchers: [
                {
                    defaultRouteAction: {
                        corsPolicy: {
                            allowCredentials: true,
                            allowHeaders: [
                                "Test string"
                            ],
                            allowMethods: [
                                "Test string"
                            ],
                            allowOriginRegexes: [
                                "Test string"
                            ],
                            allowOrigins: [
                                "Test string"
                            ],
                            disabled: true,
                            exposeHeaders: [
                                "Test string"
                            ],
                            maxAge: 42,
                        },
                        faultInjectionPolicy: {
                            abort: {
                                httpStatus: 42,
                                percentage: 42,
                            },
                            delay: {
                                fixedDelay: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                percentage: 42,
                            },
                        },
                        maxStreamDuration: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        requestMirrorPolicy: {
                            backendService: "Test string",
                        },
                        retryPolicy: {
                            numRetries: 42,
                            perTryTimeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            retryConditions: [
                                "Test string"
                            ],
                        },
                        timeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        urlRewrite: {
                            hostRewrite: "Test string",
                            pathPrefixRewrite: "Test string",
                            pathTemplateRewrite: "Test string",
                        },
                        weightedBackendServices: [
                            {
                                backendService: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                weight: 42,
                            }
                        ],
                    },
                    defaultService: "Test string",
                    defaultUrlRedirect: {
                        hostRedirect: "Test string",
                        httpsRedirect: true,
                        pathRedirect: "Test string",
                        prefixRedirect: "Test string",
                        redirectResponseCode: "Test string",
                        stripQuery: true,
                    },
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        requestHeadersToRemove: [
                            "Test string"
                        ],
                        responseHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        responseHeadersToRemove: [
                            "Test string"
                        ],
                    },
                    name: "Test string",
                    pathRules: [
                        {
                            paths: [
                                "Test string"
                            ],
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                    routeRules: [
                        {
                            description: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            matchRules: [
                                {
                                    fullPathMatch: "Test string",
                                    headerMatches: [
                                        {
                                            exactMatch: "Test string",
                                            headerName: "Test string",
                                            invertMatch: true,
                                            prefixMatch: "Test string",
                                            presentMatch: true,
                                            rangeMatch: {
                                                rangeEnd: "Test string",
                                                rangeStart: "Test string",
                                            },
                                            regexMatch: "Test string",
                                            suffixMatch: "Test string",
                                        }
                                    ],
                                    ignoreCase: true,
                                    metadataFilters: [
                                        {
                                            filterLabels: [
                                                {
                                                    name: "Test string",
                                                    value: "Test string",
                                                }
                                            ],
                                            filterMatchCriteria: "Test string",
                                        }
                                    ],
                                    pathTemplateMatch: "Test string",
                                    prefixMatch: "Test string",
                                    queryParameterMatches: [
                                        {
                                            exactMatch: "Test string",
                                            name: "Test string",
                                            presentMatch: true,
                                            regexMatch: "Test string",
                                        }
                                    ],
                                    regexMatch: "Test string",
                                }
                            ],
                            priority: 42,
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            tests: [
                {
                    description: "Test string",
                    expectedOutputUrl: "Test string",
                    expectedRedirectResponseCode: 42,
                    headers: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    host: "Test string",
                    path: "Test string",
                    service: "Test string",
                }
            ],
        });
        /** Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap. */
        await gapi.client.compute.regionUrlMaps.validate({
            project: "Test string",
            region: "Test string",
            urlMap: "Test string",
        }, {
            resource: {
                creationTimestamp: "Test string",
                defaultRouteAction: {
                    corsPolicy: {
                        allowCredentials: true,
                        allowHeaders: [
                            "Test string"
                        ],
                        allowMethods: [
                            "Test string"
                        ],
                        allowOriginRegexes: [
                            "Test string"
                        ],
                        allowOrigins: [
                            "Test string"
                        ],
                        disabled: true,
                        exposeHeaders: [
                            "Test string"
                        ],
                        maxAge: 42,
                    },
                    faultInjectionPolicy: {
                        abort: {
                            httpStatus: 42,
                            percentage: 42,
                        },
                        delay: {
                            fixedDelay: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            percentage: 42,
                        },
                    },
                    maxStreamDuration: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    requestMirrorPolicy: {
                        backendService: "Test string",
                    },
                    retryPolicy: {
                        numRetries: 42,
                        perTryTimeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        retryConditions: [
                            "Test string"
                        ],
                    },
                    timeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    urlRewrite: {
                        hostRewrite: "Test string",
                        pathPrefixRewrite: "Test string",
                        pathTemplateRewrite: "Test string",
                    },
                    weightedBackendServices: [
                        {
                            backendService: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            weight: 42,
                        }
                    ],
                },
                defaultService: "Test string",
                defaultUrlRedirect: {
                    hostRedirect: "Test string",
                    httpsRedirect: true,
                    pathRedirect: "Test string",
                    prefixRedirect: "Test string",
                    redirectResponseCode: "Test string",
                    stripQuery: true,
                },
                description: "Test string",
                fingerprint: "Test string",
                headerAction: {
                    requestHeadersToAdd: [
                        {
                            headerName: "Test string",
                            headerValue: "Test string",
                            replace: true,
                        }
                    ],
                    requestHeadersToRemove: [
                        "Test string"
                    ],
                    responseHeadersToAdd: [
                        {
                            headerName: "Test string",
                            headerValue: "Test string",
                            replace: true,
                        }
                    ],
                    responseHeadersToRemove: [
                        "Test string"
                    ],
                },
                hostRules: [
                    {
                        description: "Test string",
                        hosts: [
                            "Test string"
                        ],
                        pathMatcher: "Test string",
                    }
                ],
                id: "Test string",
                kind: "Test string",
                name: "Test string",
                pathMatchers: [
                    {
                        defaultRouteAction: {
                            corsPolicy: {
                                allowCredentials: true,
                                allowHeaders: [
                                    "Test string"
                                ],
                                allowMethods: [
                                    "Test string"
                                ],
                                allowOriginRegexes: [
                                    "Test string"
                                ],
                                allowOrigins: [
                                    "Test string"
                                ],
                                disabled: true,
                                exposeHeaders: [
                                    "Test string"
                                ],
                                maxAge: 42,
                            },
                            faultInjectionPolicy: {
                                abort: {
                                    httpStatus: 42,
                                    percentage: 42,
                                },
                                delay: {
                                    fixedDelay: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    percentage: 42,
                                },
                            },
                            maxStreamDuration: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            requestMirrorPolicy: {
                                backendService: "Test string",
                            },
                            retryPolicy: {
                                numRetries: 42,
                                perTryTimeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                retryConditions: [
                                    "Test string"
                                ],
                            },
                            timeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            urlRewrite: {
                                hostRewrite: "Test string",
                                pathPrefixRewrite: "Test string",
                                pathTemplateRewrite: "Test string",
                            },
                            weightedBackendServices: [
                                {
                                    backendService: "Test string",
                                    headerAction: {
                                        requestHeadersToAdd: [
                                            {
                                                headerName: "Test string",
                                                headerValue: "Test string",
                                                replace: true,
                                            }
                                        ],
                                        requestHeadersToRemove: [
                                            "Test string"
                                        ],
                                        responseHeadersToAdd: [
                                            {
                                                headerName: "Test string",
                                                headerValue: "Test string",
                                                replace: true,
                                            }
                                        ],
                                        responseHeadersToRemove: [
                                            "Test string"
                                        ],
                                    },
                                    weight: 42,
                                }
                            ],
                        },
                        defaultService: "Test string",
                        defaultUrlRedirect: {
                            hostRedirect: "Test string",
                            httpsRedirect: true,
                            pathRedirect: "Test string",
                            prefixRedirect: "Test string",
                            redirectResponseCode: "Test string",
                            stripQuery: true,
                        },
                        description: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        name: "Test string",
                        pathRules: [
                            {
                                paths: [
                                    "Test string"
                                ],
                                routeAction: {
                                    corsPolicy: {
                                        allowCredentials: true,
                                        allowHeaders: [
                                            "Test string"
                                        ],
                                        allowMethods: [
                                            "Test string"
                                        ],
                                        allowOriginRegexes: [
                                            "Test string"
                                        ],
                                        allowOrigins: [
                                            "Test string"
                                        ],
                                        disabled: true,
                                        exposeHeaders: [
                                            "Test string"
                                        ],
                                        maxAge: 42,
                                    },
                                    faultInjectionPolicy: {
                                        abort: {
                                            httpStatus: 42,
                                            percentage: 42,
                                        },
                                        delay: {
                                            fixedDelay: {
                                                nanos: 42,
                                                seconds: "Test string",
                                            },
                                            percentage: 42,
                                        },
                                    },
                                    maxStreamDuration: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    requestMirrorPolicy: {
                                        backendService: "Test string",
                                    },
                                    retryPolicy: {
                                        numRetries: 42,
                                        perTryTimeout: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        retryConditions: [
                                            "Test string"
                                        ],
                                    },
                                    timeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    urlRewrite: {
                                        hostRewrite: "Test string",
                                        pathPrefixRewrite: "Test string",
                                        pathTemplateRewrite: "Test string",
                                    },
                                    weightedBackendServices: [
                                        {
                                            backendService: "Test string",
                                            headerAction: {
                                                requestHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                requestHeadersToRemove: [
                                                    "Test string"
                                                ],
                                                responseHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                responseHeadersToRemove: [
                                                    "Test string"
                                                ],
                                            },
                                            weight: 42,
                                        }
                                    ],
                                },
                                service: "Test string",
                                urlRedirect: {
                                    hostRedirect: "Test string",
                                    httpsRedirect: true,
                                    pathRedirect: "Test string",
                                    prefixRedirect: "Test string",
                                    redirectResponseCode: "Test string",
                                    stripQuery: true,
                                },
                            }
                        ],
                        routeRules: [
                            {
                                description: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                matchRules: [
                                    {
                                        fullPathMatch: "Test string",
                                        headerMatches: [
                                            {
                                                exactMatch: "Test string",
                                                headerName: "Test string",
                                                invertMatch: true,
                                                prefixMatch: "Test string",
                                                presentMatch: true,
                                                rangeMatch: {
                                                    rangeEnd: "Test string",
                                                    rangeStart: "Test string",
                                                },
                                                regexMatch: "Test string",
                                                suffixMatch: "Test string",
                                            }
                                        ],
                                        ignoreCase: true,
                                        metadataFilters: [
                                            {
                                                filterLabels: [
                                                    {
                                                        name: "Test string",
                                                        value: "Test string",
                                                    }
                                                ],
                                                filterMatchCriteria: "Test string",
                                            }
                                        ],
                                        pathTemplateMatch: "Test string",
                                        prefixMatch: "Test string",
                                        queryParameterMatches: [
                                            {
                                                exactMatch: "Test string",
                                                name: "Test string",
                                                presentMatch: true,
                                                regexMatch: "Test string",
                                            }
                                        ],
                                        regexMatch: "Test string",
                                    }
                                ],
                                priority: 42,
                                routeAction: {
                                    corsPolicy: {
                                        allowCredentials: true,
                                        allowHeaders: [
                                            "Test string"
                                        ],
                                        allowMethods: [
                                            "Test string"
                                        ],
                                        allowOriginRegexes: [
                                            "Test string"
                                        ],
                                        allowOrigins: [
                                            "Test string"
                                        ],
                                        disabled: true,
                                        exposeHeaders: [
                                            "Test string"
                                        ],
                                        maxAge: 42,
                                    },
                                    faultInjectionPolicy: {
                                        abort: {
                                            httpStatus: 42,
                                            percentage: 42,
                                        },
                                        delay: {
                                            fixedDelay: {
                                                nanos: 42,
                                                seconds: "Test string",
                                            },
                                            percentage: 42,
                                        },
                                    },
                                    maxStreamDuration: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    requestMirrorPolicy: {
                                        backendService: "Test string",
                                    },
                                    retryPolicy: {
                                        numRetries: 42,
                                        perTryTimeout: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        retryConditions: [
                                            "Test string"
                                        ],
                                    },
                                    timeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    urlRewrite: {
                                        hostRewrite: "Test string",
                                        pathPrefixRewrite: "Test string",
                                        pathTemplateRewrite: "Test string",
                                    },
                                    weightedBackendServices: [
                                        {
                                            backendService: "Test string",
                                            headerAction: {
                                                requestHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                requestHeadersToRemove: [
                                                    "Test string"
                                                ],
                                                responseHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                responseHeadersToRemove: [
                                                    "Test string"
                                                ],
                                            },
                                            weight: 42,
                                        }
                                    ],
                                },
                                service: "Test string",
                                urlRedirect: {
                                    hostRedirect: "Test string",
                                    httpsRedirect: true,
                                    pathRedirect: "Test string",
                                    prefixRedirect: "Test string",
                                    redirectResponseCode: "Test string",
                                    stripQuery: true,
                                },
                            }
                        ],
                    }
                ],
                region: "Test string",
                selfLink: "Test string",
                tests: [
                    {
                        description: "Test string",
                        expectedOutputUrl: "Test string",
                        expectedRedirectResponseCode: 42,
                        headers: [
                            {
                                name: "Test string",
                                value: "Test string",
                            }
                        ],
                        host: "Test string",
                        path: "Test string",
                        service: "Test string",
                    }
                ],
            },
        });
        /** Retrieves an aggregated list of reservations. */
        await gapi.client.compute.reservations.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified reservation. */
        await gapi.client.compute.reservations.delete({
            project: "Test string",
            requestId: "Test string",
            reservation: "Test string",
            zone: "Test string",
        });
        /** Retrieves information about the specified reservation. */
        await gapi.client.compute.reservations.get({
            project: "Test string",
            reservation: "Test string",
            zone: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.reservations.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        });
        /** Creates a new reservation. For more information, read Reserving zonal resources. */
        await gapi.client.compute.reservations.insert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            commitment: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            resourcePolicies: {
                A: "Test string"
            },
            resourceStatus: {
                specificSkuAllocation: {
                    sourceInstanceTemplateId: "Test string",
                },
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            shareSettings: {
                projectMap: {
                    A: {
                        projectId: "Test string",
                    }
                },
                shareType: "Test string",
            },
            specificReservation: {
                assuredCount: "Test string",
                count: "Test string",
                instanceProperties: {
                    guestAccelerators: [
                        {
                            acceleratorCount: 42,
                            acceleratorType: "Test string",
                        }
                    ],
                    localSsds: [
                        {
                            diskSizeGb: "Test string",
                            interface: "Test string",
                        }
                    ],
                    locationHint: "Test string",
                    machineType: "Test string",
                    minCpuPlatform: "Test string",
                },
                inUseCount: "Test string",
                sourceInstanceTemplate: "Test string",
            },
            specificReservationRequired: true,
            status: "Test string",
            zone: "Test string",
        });
        /** A list of all the reservations that have been configured for the specified project in specified zone. */
        await gapi.client.compute.reservations.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Resizes the reservation (applicable to standalone reservations only). For more information, read Modifying reservations. */
        await gapi.client.compute.reservations.resize({
            project: "Test string",
            requestId: "Test string",
            reservation: "Test string",
            zone: "Test string",
        }, {
            specificSkuCount: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.reservations.setIamPolicy({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.reservations.testIamPermissions({
            project: "Test string",
            resource: "Test string",
            zone: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Update share settings of the reservation. */
        await gapi.client.compute.reservations.update({
            paths: "Test string",
            project: "Test string",
            requestId: "Test string",
            reservation: "Test string",
            updateMask: "Test string",
            zone: "Test string",
        }, {
            commitment: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            resourcePolicies: {
                A: "Test string"
            },
            resourceStatus: {
                specificSkuAllocation: {
                    sourceInstanceTemplateId: "Test string",
                },
            },
            satisfiesPzs: true,
            selfLink: "Test string",
            shareSettings: {
                projectMap: {
                    A: {
                        projectId: "Test string",
                    }
                },
                shareType: "Test string",
            },
            specificReservation: {
                assuredCount: "Test string",
                count: "Test string",
                instanceProperties: {
                    guestAccelerators: [
                        {
                            acceleratorCount: 42,
                            acceleratorType: "Test string",
                        }
                    ],
                    localSsds: [
                        {
                            diskSizeGb: "Test string",
                            interface: "Test string",
                        }
                    ],
                    locationHint: "Test string",
                    machineType: "Test string",
                    minCpuPlatform: "Test string",
                },
                inUseCount: "Test string",
                sourceInstanceTemplate: "Test string",
            },
            specificReservationRequired: true,
            status: "Test string",
            zone: "Test string",
        });
        /** Retrieves an aggregated list of resource policies. */
        await gapi.client.compute.resourcePolicies.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified resource policy. */
        await gapi.client.compute.resourcePolicies.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resourcePolicy: "Test string",
        });
        /** Retrieves all information of the specified resource policy. */
        await gapi.client.compute.resourcePolicies.get({
            project: "Test string",
            region: "Test string",
            resourcePolicy: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.resourcePolicies.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Creates a new resource policy. */
        await gapi.client.compute.resourcePolicies.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            diskConsistencyGroupPolicy: {
            },
            groupPlacementPolicy: {
                availabilityDomainCount: 42,
                collocation: "Test string",
                vmCount: 42,
            },
            id: "Test string",
            instanceSchedulePolicy: {
                expirationTime: "Test string",
                startTime: "Test string",
                timeZone: "Test string",
                vmStartSchedule: {
                    schedule: "Test string",
                },
                vmStopSchedule: {
                    schedule: "Test string",
                },
            },
            kind: "Test string",
            name: "Test string",
            region: "Test string",
            resourceStatus: {
                instanceSchedulePolicy: {
                    lastRunStartTime: "Test string",
                    nextRunStartTime: "Test string",
                },
            },
            selfLink: "Test string",
            snapshotSchedulePolicy: {
                retentionPolicy: {
                    maxRetentionDays: 42,
                    onSourceDiskDelete: "Test string",
                },
                schedule: {
                    dailySchedule: {
                        daysInCycle: 42,
                        duration: "Test string",
                        startTime: "Test string",
                    },
                    hourlySchedule: {
                        duration: "Test string",
                        hoursInCycle: 42,
                        startTime: "Test string",
                    },
                    weeklySchedule: {
                        dayOfWeeks: [
                            {
                                day: "Test string",
                                duration: "Test string",
                                startTime: "Test string",
                            }
                        ],
                    },
                },
                snapshotProperties: {
                    chainName: "Test string",
                    guestFlush: true,
                    labels: {
                        A: "Test string"
                    },
                    storageLocations: [
                        "Test string"
                    ],
                },
            },
            status: "Test string",
        });
        /** A list all the resource policies that have been configured for the specified project in specified region. */
        await gapi.client.compute.resourcePolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.resourcePolicies.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.resourcePolicies.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of routers. */
        await gapi.client.compute.routers.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified Router resource. */
        await gapi.client.compute.routers.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            router: "Test string",
        });
        /** Returns the specified Router resource. */
        await gapi.client.compute.routers.get({
            project: "Test string",
            region: "Test string",
            router: "Test string",
        });
        /** Retrieves runtime Nat mapping information of VM endpoints. */
        await gapi.client.compute.routers.getNatMappingInfo({
            filter: "Test string",
            maxResults: 42,
            natName: "Test string",
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
            router: "Test string",
        });
        /** Retrieves runtime information of the specified router. */
        await gapi.client.compute.routers.getRouterStatus({
            project: "Test string",
            region: "Test string",
            router: "Test string",
        });
        /** Creates a Router resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.routers.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            bgp: {
                advertisedGroups: [
                    "Test string"
                ],
                advertisedIpRanges: [
                    {
                        description: "Test string",
                        range: "Test string",
                    }
                ],
                advertiseMode: "Test string",
                asn: 42,
                keepaliveInterval: 42,
            },
            bgpPeers: [
                {
                    advertisedGroups: [
                        "Test string"
                    ],
                    advertisedIpRanges: [
                        {
                            description: "Test string",
                            range: "Test string",
                        }
                    ],
                    advertisedRoutePriority: 42,
                    advertiseMode: "Test string",
                    bfd: {
                        minReceiveInterval: 42,
                        minTransmitInterval: 42,
                        multiplier: 42,
                        sessionInitializationMode: "Test string",
                    },
                    customLearnedIpRanges: [
                        {
                            range: "Test string",
                        }
                    ],
                    customLearnedRoutePriority: 42,
                    enable: "Test string",
                    enableIpv6: true,
                    interfaceName: "Test string",
                    ipAddress: "Test string",
                    ipv6NexthopAddress: "Test string",
                    managementType: "Test string",
                    md5AuthenticationKeyName: "Test string",
                    name: "Test string",
                    peerAsn: 42,
                    peerIpAddress: "Test string",
                    peerIpv6NexthopAddress: "Test string",
                    routerApplianceInstance: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            encryptedInterconnectRouter: true,
            id: "Test string",
            interfaces: [
                {
                    ipRange: "Test string",
                    linkedInterconnectAttachment: "Test string",
                    linkedVpnTunnel: "Test string",
                    managementType: "Test string",
                    name: "Test string",
                    privateIpAddress: "Test string",
                    redundantInterface: "Test string",
                    subnetwork: "Test string",
                }
            ],
            kind: "Test string",
            md5AuthenticationKeys: [
                {
                    key: "Test string",
                    name: "Test string",
                }
            ],
            name: "Test string",
            nats: [
                {
                    drainNatIps: [
                        "Test string"
                    ],
                    enableDynamicPortAllocation: true,
                    enableEndpointIndependentMapping: true,
                    endpointTypes: [
                        "Test string"
                    ],
                    icmpIdleTimeoutSec: 42,
                    logConfig: {
                        enable: true,
                        filter: "Test string",
                    },
                    maxPortsPerVm: 42,
                    minPortsPerVm: 42,
                    name: "Test string",
                    natIpAllocateOption: "Test string",
                    natIps: [
                        "Test string"
                    ],
                    rules: [
                        {
                            action: {
                                sourceNatActiveIps: [
                                    "Test string"
                                ],
                                sourceNatDrainIps: [
                                    "Test string"
                                ],
                            },
                            description: "Test string",
                            match: "Test string",
                            ruleNumber: 42,
                        }
                    ],
                    sourceSubnetworkIpRangesToNat: "Test string",
                    subnetworks: [
                        {
                            name: "Test string",
                            secondaryIpRangeNames: [
                                "Test string"
                            ],
                            sourceIpRangesToNat: [
                                "Test string"
                            ],
                        }
                    ],
                    tcpEstablishedIdleTimeoutSec: 42,
                    tcpTimeWaitTimeoutSec: 42,
                    tcpTransitoryIdleTimeoutSec: 42,
                    udpIdleTimeoutSec: 42,
                }
            ],
            network: "Test string",
            region: "Test string",
            selfLink: "Test string",
        });
        /** Retrieves a list of Router resources available to the specified project. */
        await gapi.client.compute.routers.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified Router resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.routers.patch({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            router: "Test string",
        }, {
            bgp: {
                advertisedGroups: [
                    "Test string"
                ],
                advertisedIpRanges: [
                    {
                        description: "Test string",
                        range: "Test string",
                    }
                ],
                advertiseMode: "Test string",
                asn: 42,
                keepaliveInterval: 42,
            },
            bgpPeers: [
                {
                    advertisedGroups: [
                        "Test string"
                    ],
                    advertisedIpRanges: [
                        {
                            description: "Test string",
                            range: "Test string",
                        }
                    ],
                    advertisedRoutePriority: 42,
                    advertiseMode: "Test string",
                    bfd: {
                        minReceiveInterval: 42,
                        minTransmitInterval: 42,
                        multiplier: 42,
                        sessionInitializationMode: "Test string",
                    },
                    customLearnedIpRanges: [
                        {
                            range: "Test string",
                        }
                    ],
                    customLearnedRoutePriority: 42,
                    enable: "Test string",
                    enableIpv6: true,
                    interfaceName: "Test string",
                    ipAddress: "Test string",
                    ipv6NexthopAddress: "Test string",
                    managementType: "Test string",
                    md5AuthenticationKeyName: "Test string",
                    name: "Test string",
                    peerAsn: 42,
                    peerIpAddress: "Test string",
                    peerIpv6NexthopAddress: "Test string",
                    routerApplianceInstance: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            encryptedInterconnectRouter: true,
            id: "Test string",
            interfaces: [
                {
                    ipRange: "Test string",
                    linkedInterconnectAttachment: "Test string",
                    linkedVpnTunnel: "Test string",
                    managementType: "Test string",
                    name: "Test string",
                    privateIpAddress: "Test string",
                    redundantInterface: "Test string",
                    subnetwork: "Test string",
                }
            ],
            kind: "Test string",
            md5AuthenticationKeys: [
                {
                    key: "Test string",
                    name: "Test string",
                }
            ],
            name: "Test string",
            nats: [
                {
                    drainNatIps: [
                        "Test string"
                    ],
                    enableDynamicPortAllocation: true,
                    enableEndpointIndependentMapping: true,
                    endpointTypes: [
                        "Test string"
                    ],
                    icmpIdleTimeoutSec: 42,
                    logConfig: {
                        enable: true,
                        filter: "Test string",
                    },
                    maxPortsPerVm: 42,
                    minPortsPerVm: 42,
                    name: "Test string",
                    natIpAllocateOption: "Test string",
                    natIps: [
                        "Test string"
                    ],
                    rules: [
                        {
                            action: {
                                sourceNatActiveIps: [
                                    "Test string"
                                ],
                                sourceNatDrainIps: [
                                    "Test string"
                                ],
                            },
                            description: "Test string",
                            match: "Test string",
                            ruleNumber: 42,
                        }
                    ],
                    sourceSubnetworkIpRangesToNat: "Test string",
                    subnetworks: [
                        {
                            name: "Test string",
                            secondaryIpRangeNames: [
                                "Test string"
                            ],
                            sourceIpRangesToNat: [
                                "Test string"
                            ],
                        }
                    ],
                    tcpEstablishedIdleTimeoutSec: 42,
                    tcpTimeWaitTimeoutSec: 42,
                    tcpTransitoryIdleTimeoutSec: 42,
                    udpIdleTimeoutSec: 42,
                }
            ],
            network: "Test string",
            region: "Test string",
            selfLink: "Test string",
        });
        /** Preview fields auto-generated during router create and update operations. Calling this method does NOT create or update the router. */
        await gapi.client.compute.routers.preview({
            project: "Test string",
            region: "Test string",
            router: "Test string",
        }, {
            bgp: {
                advertisedGroups: [
                    "Test string"
                ],
                advertisedIpRanges: [
                    {
                        description: "Test string",
                        range: "Test string",
                    }
                ],
                advertiseMode: "Test string",
                asn: 42,
                keepaliveInterval: 42,
            },
            bgpPeers: [
                {
                    advertisedGroups: [
                        "Test string"
                    ],
                    advertisedIpRanges: [
                        {
                            description: "Test string",
                            range: "Test string",
                        }
                    ],
                    advertisedRoutePriority: 42,
                    advertiseMode: "Test string",
                    bfd: {
                        minReceiveInterval: 42,
                        minTransmitInterval: 42,
                        multiplier: 42,
                        sessionInitializationMode: "Test string",
                    },
                    customLearnedIpRanges: [
                        {
                            range: "Test string",
                        }
                    ],
                    customLearnedRoutePriority: 42,
                    enable: "Test string",
                    enableIpv6: true,
                    interfaceName: "Test string",
                    ipAddress: "Test string",
                    ipv6NexthopAddress: "Test string",
                    managementType: "Test string",
                    md5AuthenticationKeyName: "Test string",
                    name: "Test string",
                    peerAsn: 42,
                    peerIpAddress: "Test string",
                    peerIpv6NexthopAddress: "Test string",
                    routerApplianceInstance: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            encryptedInterconnectRouter: true,
            id: "Test string",
            interfaces: [
                {
                    ipRange: "Test string",
                    linkedInterconnectAttachment: "Test string",
                    linkedVpnTunnel: "Test string",
                    managementType: "Test string",
                    name: "Test string",
                    privateIpAddress: "Test string",
                    redundantInterface: "Test string",
                    subnetwork: "Test string",
                }
            ],
            kind: "Test string",
            md5AuthenticationKeys: [
                {
                    key: "Test string",
                    name: "Test string",
                }
            ],
            name: "Test string",
            nats: [
                {
                    drainNatIps: [
                        "Test string"
                    ],
                    enableDynamicPortAllocation: true,
                    enableEndpointIndependentMapping: true,
                    endpointTypes: [
                        "Test string"
                    ],
                    icmpIdleTimeoutSec: 42,
                    logConfig: {
                        enable: true,
                        filter: "Test string",
                    },
                    maxPortsPerVm: 42,
                    minPortsPerVm: 42,
                    name: "Test string",
                    natIpAllocateOption: "Test string",
                    natIps: [
                        "Test string"
                    ],
                    rules: [
                        {
                            action: {
                                sourceNatActiveIps: [
                                    "Test string"
                                ],
                                sourceNatDrainIps: [
                                    "Test string"
                                ],
                            },
                            description: "Test string",
                            match: "Test string",
                            ruleNumber: 42,
                        }
                    ],
                    sourceSubnetworkIpRangesToNat: "Test string",
                    subnetworks: [
                        {
                            name: "Test string",
                            secondaryIpRangeNames: [
                                "Test string"
                            ],
                            sourceIpRangesToNat: [
                                "Test string"
                            ],
                        }
                    ],
                    tcpEstablishedIdleTimeoutSec: 42,
                    tcpTimeWaitTimeoutSec: 42,
                    tcpTransitoryIdleTimeoutSec: 42,
                    udpIdleTimeoutSec: 42,
                }
            ],
            network: "Test string",
            region: "Test string",
            selfLink: "Test string",
        });
        /**
         * Updates the specified Router resource with the data included in the request. This method conforms to PUT semantics, which requests that the state of the target resource be created or
         * replaced with the state defined by the representation enclosed in the request message payload.
         */
        await gapi.client.compute.routers.update({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            router: "Test string",
        }, {
            bgp: {
                advertisedGroups: [
                    "Test string"
                ],
                advertisedIpRanges: [
                    {
                        description: "Test string",
                        range: "Test string",
                    }
                ],
                advertiseMode: "Test string",
                asn: 42,
                keepaliveInterval: 42,
            },
            bgpPeers: [
                {
                    advertisedGroups: [
                        "Test string"
                    ],
                    advertisedIpRanges: [
                        {
                            description: "Test string",
                            range: "Test string",
                        }
                    ],
                    advertisedRoutePriority: 42,
                    advertiseMode: "Test string",
                    bfd: {
                        minReceiveInterval: 42,
                        minTransmitInterval: 42,
                        multiplier: 42,
                        sessionInitializationMode: "Test string",
                    },
                    customLearnedIpRanges: [
                        {
                            range: "Test string",
                        }
                    ],
                    customLearnedRoutePriority: 42,
                    enable: "Test string",
                    enableIpv6: true,
                    interfaceName: "Test string",
                    ipAddress: "Test string",
                    ipv6NexthopAddress: "Test string",
                    managementType: "Test string",
                    md5AuthenticationKeyName: "Test string",
                    name: "Test string",
                    peerAsn: 42,
                    peerIpAddress: "Test string",
                    peerIpv6NexthopAddress: "Test string",
                    routerApplianceInstance: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            encryptedInterconnectRouter: true,
            id: "Test string",
            interfaces: [
                {
                    ipRange: "Test string",
                    linkedInterconnectAttachment: "Test string",
                    linkedVpnTunnel: "Test string",
                    managementType: "Test string",
                    name: "Test string",
                    privateIpAddress: "Test string",
                    redundantInterface: "Test string",
                    subnetwork: "Test string",
                }
            ],
            kind: "Test string",
            md5AuthenticationKeys: [
                {
                    key: "Test string",
                    name: "Test string",
                }
            ],
            name: "Test string",
            nats: [
                {
                    drainNatIps: [
                        "Test string"
                    ],
                    enableDynamicPortAllocation: true,
                    enableEndpointIndependentMapping: true,
                    endpointTypes: [
                        "Test string"
                    ],
                    icmpIdleTimeoutSec: 42,
                    logConfig: {
                        enable: true,
                        filter: "Test string",
                    },
                    maxPortsPerVm: 42,
                    minPortsPerVm: 42,
                    name: "Test string",
                    natIpAllocateOption: "Test string",
                    natIps: [
                        "Test string"
                    ],
                    rules: [
                        {
                            action: {
                                sourceNatActiveIps: [
                                    "Test string"
                                ],
                                sourceNatDrainIps: [
                                    "Test string"
                                ],
                            },
                            description: "Test string",
                            match: "Test string",
                            ruleNumber: 42,
                        }
                    ],
                    sourceSubnetworkIpRangesToNat: "Test string",
                    subnetworks: [
                        {
                            name: "Test string",
                            secondaryIpRangeNames: [
                                "Test string"
                            ],
                            sourceIpRangesToNat: [
                                "Test string"
                            ],
                        }
                    ],
                    tcpEstablishedIdleTimeoutSec: 42,
                    tcpTimeWaitTimeoutSec: 42,
                    tcpTransitoryIdleTimeoutSec: 42,
                    udpIdleTimeoutSec: 42,
                }
            ],
            network: "Test string",
            region: "Test string",
            selfLink: "Test string",
        });
        /** Deletes the specified Route resource. */
        await gapi.client.compute.routes.delete({
            project: "Test string",
            requestId: "Test string",
            route: "Test string",
        });
        /** Returns the specified Route resource. */
        await gapi.client.compute.routes.get({
            project: "Test string",
            route: "Test string",
        });
        /** Creates a Route resource in the specified project using the data included in the request. */
        await gapi.client.compute.routes.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            asPaths: [
                {
                    asLists: [
                        42
                    ],
                    pathSegmentType: "Test string",
                }
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            destRange: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            network: "Test string",
            nextHopGateway: "Test string",
            nextHopIlb: "Test string",
            nextHopInstance: "Test string",
            nextHopIp: "Test string",
            nextHopNetwork: "Test string",
            nextHopPeering: "Test string",
            nextHopVpnTunnel: "Test string",
            priority: 42,
            routeStatus: "Test string",
            routeType: "Test string",
            selfLink: "Test string",
            tags: [
                "Test string"
            ],
            warnings: [
                {
                    code: "Test string",
                    data: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    message: "Test string",
                }
            ],
        });
        /** Retrieves the list of Route resources available to the specified project. */
        await gapi.client.compute.routes.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Inserts a rule into a security policy. */
        await gapi.client.compute.securityPolicies.addRule({
            project: "Test string",
            securityPolicy: "Test string",
            validateOnly: true,
        }, {
            action: "Test string",
            description: "Test string",
            headerAction: {
                requestHeadersToAdds: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                    }
                ],
            },
            kind: "Test string",
            match: {
                config: {
                    srcIpRanges: [
                        "Test string"
                    ],
                },
                expr: {
                    description: "Test string",
                    expression: "Test string",
                    location: "Test string",
                    title: "Test string",
                },
                versionedExpr: "Test string",
            },
            preconfiguredWafConfig: {
                exclusions: [
                    {
                        requestCookiesToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        requestHeadersToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        requestQueryParamsToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        requestUrisToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        targetRuleIds: [
                            "Test string"
                        ],
                        targetRuleSet: "Test string",
                    }
                ],
            },
            preview: true,
            priority: 42,
            rateLimitOptions: {
                banDurationSec: 42,
                banThreshold: {
                    count: 42,
                    intervalSec: 42,
                },
                conformAction: "Test string",
                enforceOnKey: "Test string",
                enforceOnKeyConfigs: [
                    {
                        enforceOnKeyName: "Test string",
                        enforceOnKeyType: "Test string",
                    }
                ],
                enforceOnKeyName: "Test string",
                exceedAction: "Test string",
                exceedRedirectOptions: {
                    target: "Test string",
                    type: "Test string",
                },
                rateLimitThreshold: {
                    count: 42,
                    intervalSec: 42,
                },
            },
            redirectOptions: {
                target: "Test string",
                type: "Test string",
            },
        });
        /** Retrieves the list of all SecurityPolicy resources, regional and global, available to the specified project. */
        await gapi.client.compute.securityPolicies.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified policy. */
        await gapi.client.compute.securityPolicies.delete({
            project: "Test string",
            requestId: "Test string",
            securityPolicy: "Test string",
        });
        /** List all of the ordered rules present in a single specified policy. */
        await gapi.client.compute.securityPolicies.get({
            project: "Test string",
            securityPolicy: "Test string",
        });
        /** Gets a rule at the specified priority. */
        await gapi.client.compute.securityPolicies.getRule({
            priority: 42,
            project: "Test string",
            securityPolicy: "Test string",
        });
        /** Creates a new policy in the specified project using the data included in the request. */
        await gapi.client.compute.securityPolicies.insert({
            project: "Test string",
            requestId: "Test string",
            validateOnly: true,
        }, {
            adaptiveProtectionConfig: {
                layer7DdosDefenseConfig: {
                    enable: true,
                    ruleVisibility: "Test string",
                },
            },
            advancedOptionsConfig: {
                jsonCustomConfig: {
                    contentTypes: [
                        "Test string"
                    ],
                },
                jsonParsing: "Test string",
                logLevel: "Test string",
            },
            creationTimestamp: "Test string",
            ddosProtectionConfig: {
                ddosProtection: "Test string",
            },
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            recaptchaOptionsConfig: {
                redirectSiteKey: "Test string",
            },
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdds: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                            }
                        ],
                    },
                    kind: "Test string",
                    match: {
                        config: {
                            srcIpRanges: [
                                "Test string"
                            ],
                        },
                        expr: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        versionedExpr: "Test string",
                    },
                    preconfiguredWafConfig: {
                        exclusions: [
                            {
                                requestCookiesToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestHeadersToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestQueryParamsToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestUrisToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                targetRuleIds: [
                                    "Test string"
                                ],
                                targetRuleSet: "Test string",
                            }
                        ],
                    },
                    preview: true,
                    priority: 42,
                    rateLimitOptions: {
                        banDurationSec: 42,
                        banThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                        conformAction: "Test string",
                        enforceOnKey: "Test string",
                        enforceOnKeyConfigs: [
                            {
                                enforceOnKeyName: "Test string",
                                enforceOnKeyType: "Test string",
                            }
                        ],
                        enforceOnKeyName: "Test string",
                        exceedAction: "Test string",
                        exceedRedirectOptions: {
                            target: "Test string",
                            type: "Test string",
                        },
                        rateLimitThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                    },
                    redirectOptions: {
                        target: "Test string",
                        type: "Test string",
                    },
                }
            ],
            selfLink: "Test string",
            type: "Test string",
        });
        /** List all the policies that have been configured for the specified project. */
        await gapi.client.compute.securityPolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Gets the current list of preconfigured Web Application Firewall (WAF) expressions. */
        await gapi.client.compute.securityPolicies.listPreconfiguredExpressionSets({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Patches the specified policy with the data included in the request. To clear fields in the rule, leave the fields empty and specify them in the updateMask. This cannot be used to be
         * update the rules in the policy. Please use the per rule methods like addRule, patchRule, and removeRule instead.
         */
        await gapi.client.compute.securityPolicies.patch({
            project: "Test string",
            requestId: "Test string",
            securityPolicy: "Test string",
        }, {
            adaptiveProtectionConfig: {
                layer7DdosDefenseConfig: {
                    enable: true,
                    ruleVisibility: "Test string",
                },
            },
            advancedOptionsConfig: {
                jsonCustomConfig: {
                    contentTypes: [
                        "Test string"
                    ],
                },
                jsonParsing: "Test string",
                logLevel: "Test string",
            },
            creationTimestamp: "Test string",
            ddosProtectionConfig: {
                ddosProtection: "Test string",
            },
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            recaptchaOptionsConfig: {
                redirectSiteKey: "Test string",
            },
            region: "Test string",
            rules: [
                {
                    action: "Test string",
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdds: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                            }
                        ],
                    },
                    kind: "Test string",
                    match: {
                        config: {
                            srcIpRanges: [
                                "Test string"
                            ],
                        },
                        expr: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        versionedExpr: "Test string",
                    },
                    preconfiguredWafConfig: {
                        exclusions: [
                            {
                                requestCookiesToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestHeadersToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestQueryParamsToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                requestUrisToExclude: [
                                    {
                                        op: "Test string",
                                        val: "Test string",
                                    }
                                ],
                                targetRuleIds: [
                                    "Test string"
                                ],
                                targetRuleSet: "Test string",
                            }
                        ],
                    },
                    preview: true,
                    priority: 42,
                    rateLimitOptions: {
                        banDurationSec: 42,
                        banThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                        conformAction: "Test string",
                        enforceOnKey: "Test string",
                        enforceOnKeyConfigs: [
                            {
                                enforceOnKeyName: "Test string",
                                enforceOnKeyType: "Test string",
                            }
                        ],
                        enforceOnKeyName: "Test string",
                        exceedAction: "Test string",
                        exceedRedirectOptions: {
                            target: "Test string",
                            type: "Test string",
                        },
                        rateLimitThreshold: {
                            count: 42,
                            intervalSec: 42,
                        },
                    },
                    redirectOptions: {
                        target: "Test string",
                        type: "Test string",
                    },
                }
            ],
            selfLink: "Test string",
            type: "Test string",
        });
        /** Patches a rule at the specified priority. */
        await gapi.client.compute.securityPolicies.patchRule({
            priority: 42,
            project: "Test string",
            securityPolicy: "Test string",
            validateOnly: true,
        }, {
            action: "Test string",
            description: "Test string",
            headerAction: {
                requestHeadersToAdds: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                    }
                ],
            },
            kind: "Test string",
            match: {
                config: {
                    srcIpRanges: [
                        "Test string"
                    ],
                },
                expr: {
                    description: "Test string",
                    expression: "Test string",
                    location: "Test string",
                    title: "Test string",
                },
                versionedExpr: "Test string",
            },
            preconfiguredWafConfig: {
                exclusions: [
                    {
                        requestCookiesToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        requestHeadersToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        requestQueryParamsToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        requestUrisToExclude: [
                            {
                                op: "Test string",
                                val: "Test string",
                            }
                        ],
                        targetRuleIds: [
                            "Test string"
                        ],
                        targetRuleSet: "Test string",
                    }
                ],
            },
            preview: true,
            priority: 42,
            rateLimitOptions: {
                banDurationSec: 42,
                banThreshold: {
                    count: 42,
                    intervalSec: 42,
                },
                conformAction: "Test string",
                enforceOnKey: "Test string",
                enforceOnKeyConfigs: [
                    {
                        enforceOnKeyName: "Test string",
                        enforceOnKeyType: "Test string",
                    }
                ],
                enforceOnKeyName: "Test string",
                exceedAction: "Test string",
                exceedRedirectOptions: {
                    target: "Test string",
                    type: "Test string",
                },
                rateLimitThreshold: {
                    count: 42,
                    intervalSec: 42,
                },
            },
            redirectOptions: {
                target: "Test string",
                type: "Test string",
            },
        });
        /** Deletes a rule at the specified priority. */
        await gapi.client.compute.securityPolicies.removeRule({
            priority: 42,
            project: "Test string",
            securityPolicy: "Test string",
        });
        /** Sets the labels on a security policy. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.securityPolicies.setLabels({
            project: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Retrieves the list of all ServiceAttachment resources, regional and global, available to the specified project. */
        await gapi.client.compute.serviceAttachments.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified ServiceAttachment in the given scope */
        await gapi.client.compute.serviceAttachments.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            serviceAttachment: "Test string",
        });
        /** Returns the specified ServiceAttachment resource in the given scope. */
        await gapi.client.compute.serviceAttachments.get({
            project: "Test string",
            region: "Test string",
            serviceAttachment: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.serviceAttachments.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Creates a ServiceAttachment in the specified project in the given scope using the parameters that are included in the request. */
        await gapi.client.compute.serviceAttachments.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            connectedEndpoints: [
                {
                    endpoint: "Test string",
                    pscConnectionId: "Test string",
                    status: "Test string",
                }
            ],
            connectionPreference: "Test string",
            consumerAcceptLists: [
                {
                    connectionLimit: 42,
                    networkUrl: "Test string",
                    projectIdOrNum: "Test string",
                }
            ],
            consumerRejectLists: [
                "Test string"
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            domainNames: [
                "Test string"
            ],
            enableProxyProtocol: true,
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            natSubnets: [
                "Test string"
            ],
            producerForwardingRule: "Test string",
            pscServiceAttachmentId: {
                high: "Test string",
                low: "Test string",
            },
            reconcileConnections: true,
            region: "Test string",
            selfLink: "Test string",
            targetService: "Test string",
        });
        /** Lists the ServiceAttachments for a project in the given scope. */
        await gapi.client.compute.serviceAttachments.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified ServiceAttachment resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.serviceAttachments.patch({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            serviceAttachment: "Test string",
        }, {
            connectedEndpoints: [
                {
                    endpoint: "Test string",
                    pscConnectionId: "Test string",
                    status: "Test string",
                }
            ],
            connectionPreference: "Test string",
            consumerAcceptLists: [
                {
                    connectionLimit: 42,
                    networkUrl: "Test string",
                    projectIdOrNum: "Test string",
                }
            ],
            consumerRejectLists: [
                "Test string"
            ],
            creationTimestamp: "Test string",
            description: "Test string",
            domainNames: [
                "Test string"
            ],
            enableProxyProtocol: true,
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            natSubnets: [
                "Test string"
            ],
            producerForwardingRule: "Test string",
            pscServiceAttachmentId: {
                high: "Test string",
                low: "Test string",
            },
            reconcileConnections: true,
            region: "Test string",
            selfLink: "Test string",
            targetService: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.serviceAttachments.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.serviceAttachments.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /**
         * Deletes the specified Snapshot resource. Keep in mind that deleting a single snapshot might not necessarily delete all the data on that snapshot. If any data on the snapshot that is
         * marked for deletion is needed for subsequent snapshots, the data will be moved to the next corresponding snapshot. For more information, see Deleting snapshots.
         */
        await gapi.client.compute.snapshots.delete({
            project: "Test string",
            requestId: "Test string",
            snapshot: "Test string",
        });
        /** Returns the specified Snapshot resource. */
        await gapi.client.compute.snapshots.get({
            project: "Test string",
            snapshot: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.snapshots.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            resource: "Test string",
        });
        /**
         * Creates a snapshot in the specified project using the data included in the request. For regular snapshot creation, consider using this method instead of disks.createSnapshot, as this
         * method supports more features, such as creating snapshots in a project different from the source disk project.
         */
        await gapi.client.compute.snapshots.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            architecture: "Test string",
            autoCreated: true,
            chainName: "Test string",
            creationSizeBytes: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            diskSizeGb: "Test string",
            downloadBytes: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            licenseCodes: [
                "Test string"
            ],
            licenses: [
                "Test string"
            ],
            locationHint: "Test string",
            name: "Test string",
            satisfiesPzs: true,
            selfLink: "Test string",
            snapshotEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            snapshotType: "Test string",
            sourceDisk: "Test string",
            sourceDiskEncryptionKey: {
                kmsKeyName: "Test string",
                kmsKeyServiceAccount: "Test string",
                rawKey: "Test string",
                rsaEncryptedKey: "Test string",
                sha256: "Test string",
            },
            sourceDiskId: "Test string",
            sourceSnapshotSchedulePolicy: "Test string",
            sourceSnapshotSchedulePolicyId: "Test string",
            status: "Test string",
            storageBytes: "Test string",
            storageBytesStatus: "Test string",
            storageLocations: [
                "Test string"
            ],
        });
        /** Retrieves the list of Snapshot resources contained within the specified project. */
        await gapi.client.compute.snapshots.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.snapshots.setIamPolicy({
            project: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Sets the labels on a snapshot. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.snapshots.setLabels({
            project: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.snapshots.testIamPermissions({
            project: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves the list of all SslCertificate resources, regional and global, available to the specified project. */
        await gapi.client.compute.sslCertificates.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified SslCertificate resource. */
        await gapi.client.compute.sslCertificates.delete({
            project: "Test string",
            requestId: "Test string",
            sslCertificate: "Test string",
        });
        /** Returns the specified SslCertificate resource. */
        await gapi.client.compute.sslCertificates.get({
            project: "Test string",
            sslCertificate: "Test string",
        });
        /** Creates a SslCertificate resource in the specified project using the data included in the request. */
        await gapi.client.compute.sslCertificates.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            certificate: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            expireTime: "Test string",
            id: "Test string",
            kind: "Test string",
            managed: {
                domains: [
                    "Test string"
                ],
                domainStatus: {
                    A: "Test string"
                },
                status: "Test string",
            },
            name: "Test string",
            privateKey: "Test string",
            region: "Test string",
            selfLink: "Test string",
            selfManaged: {
                certificate: "Test string",
                privateKey: "Test string",
            },
            subjectAlternativeNames: [
                "Test string"
            ],
            type: "Test string",
        });
        /** Retrieves the list of SslCertificate resources available to the specified project. */
        await gapi.client.compute.sslCertificates.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Retrieves the list of all SslPolicy resources, regional and global, available to the specified project. */
        await gapi.client.compute.sslPolicies.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified SSL policy. The SSL policy resource can be deleted only if it is not in use by any TargetHttpsProxy or TargetSslProxy resources. */
        await gapi.client.compute.sslPolicies.delete({
            project: "Test string",
            requestId: "Test string",
            sslPolicy: "Test string",
        });
        /** Lists all of the ordered rules present in a single specified policy. */
        await gapi.client.compute.sslPolicies.get({
            project: "Test string",
            sslPolicy: "Test string",
        });
        /** Returns the specified SSL policy resource. */
        await gapi.client.compute.sslPolicies.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            customFeatures: [
                "Test string"
            ],
            description: "Test string",
            enabledFeatures: [
                "Test string"
            ],
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            minTlsVersion: "Test string",
            name: "Test string",
            profile: "Test string",
            region: "Test string",
            selfLink: "Test string",
            warnings: [
                {
                    code: "Test string",
                    data: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    message: "Test string",
                }
            ],
        });
        /** Lists all the SSL policies that have been configured for the specified project. */
        await gapi.client.compute.sslPolicies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Lists all features that can be specified in the SSL policy when using custom profile. */
        await gapi.client.compute.sslPolicies.listAvailableFeatures({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified SSL policy with the data included in the request. */
        await gapi.client.compute.sslPolicies.patch({
            project: "Test string",
            requestId: "Test string",
            sslPolicy: "Test string",
        }, {
            creationTimestamp: "Test string",
            customFeatures: [
                "Test string"
            ],
            description: "Test string",
            enabledFeatures: [
                "Test string"
            ],
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            minTlsVersion: "Test string",
            name: "Test string",
            profile: "Test string",
            region: "Test string",
            selfLink: "Test string",
            warnings: [
                {
                    code: "Test string",
                    data: [
                        {
                            key: "Test string",
                            value: "Test string",
                        }
                    ],
                    message: "Test string",
                }
            ],
        });
        /** Retrieves an aggregated list of subnetworks. */
        await gapi.client.compute.subnetworks.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified subnetwork. */
        await gapi.client.compute.subnetworks.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            subnetwork: "Test string",
        });
        /** Expands the IP CIDR range of the subnetwork to a specified value. */
        await gapi.client.compute.subnetworks.expandIpCidrRange({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            subnetwork: "Test string",
        }, {
            ipCidrRange: "Test string",
        });
        /** Returns the specified subnetwork. */
        await gapi.client.compute.subnetworks.get({
            project: "Test string",
            region: "Test string",
            subnetwork: "Test string",
        });
        /** Gets the access control policy for a resource. May be empty if no such policy or resource exists. */
        await gapi.client.compute.subnetworks.getIamPolicy({
            optionsRequestedPolicyVersion: 42,
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        });
        /** Creates a subnetwork in the specified project using the data included in the request. */
        await gapi.client.compute.subnetworks.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            enableFlowLogs: true,
            externalIpv6Prefix: "Test string",
            fingerprint: "Test string",
            gatewayAddress: "Test string",
            id: "Test string",
            internalIpv6Prefix: "Test string",
            ipCidrRange: "Test string",
            ipv6AccessType: "Test string",
            ipv6CidrRange: "Test string",
            kind: "Test string",
            logConfig: {
                aggregationInterval: "Test string",
                enable: true,
                filterExpr: "Test string",
                flowSampling: 42,
                metadata: "Test string",
                metadataFields: [
                    "Test string"
                ],
            },
            name: "Test string",
            network: "Test string",
            privateIpGoogleAccess: true,
            privateIpv6GoogleAccess: "Test string",
            purpose: "Test string",
            region: "Test string",
            role: "Test string",
            secondaryIpRanges: [
                {
                    ipCidrRange: "Test string",
                    rangeName: "Test string",
                }
            ],
            selfLink: "Test string",
            stackType: "Test string",
            state: "Test string",
        });
        /** Retrieves a list of subnetworks available to the specified project. */
        await gapi.client.compute.subnetworks.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Retrieves an aggregated list of all usable subnetworks in the project. */
        await gapi.client.compute.subnetworks.listUsable({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /**
         * Patches the specified subnetwork with the data included in the request. Only certain fields can be updated with a patch request as indicated in the field descriptions. You must specify
         * the current fingerprint of the subnetwork resource being patched.
         */
        await gapi.client.compute.subnetworks.patch({
            drainTimeoutSeconds: 42,
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            subnetwork: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            enableFlowLogs: true,
            externalIpv6Prefix: "Test string",
            fingerprint: "Test string",
            gatewayAddress: "Test string",
            id: "Test string",
            internalIpv6Prefix: "Test string",
            ipCidrRange: "Test string",
            ipv6AccessType: "Test string",
            ipv6CidrRange: "Test string",
            kind: "Test string",
            logConfig: {
                aggregationInterval: "Test string",
                enable: true,
                filterExpr: "Test string",
                flowSampling: 42,
                metadata: "Test string",
                metadataFields: [
                    "Test string"
                ],
            },
            name: "Test string",
            network: "Test string",
            privateIpGoogleAccess: true,
            privateIpv6GoogleAccess: "Test string",
            purpose: "Test string",
            region: "Test string",
            role: "Test string",
            secondaryIpRanges: [
                {
                    ipCidrRange: "Test string",
                    rangeName: "Test string",
                }
            ],
            selfLink: "Test string",
            stackType: "Test string",
            state: "Test string",
        });
        /** Sets the access control policy on the specified resource. Replaces any existing policy. */
        await gapi.client.compute.subnetworks.setIamPolicy({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            bindings: [
                {
                    bindingId: "Test string",
                    condition: {
                        description: "Test string",
                        expression: "Test string",
                        location: "Test string",
                        title: "Test string",
                    },
                    members: [
                        "Test string"
                    ],
                    role: "Test string",
                }
            ],
            etag: "Test string",
            policy: {
                auditConfigs: [
                    {
                        auditLogConfigs: [
                            {
                                exemptedMembers: [
                                    "Test string"
                                ],
                                ignoreChildExemptions: true,
                                logType: "Test string",
                            }
                        ],
                        exemptedMembers: [
                            "Test string"
                        ],
                        service: "Test string",
                    }
                ],
                bindings: [
                    {
                        bindingId: "Test string",
                        condition: {
                            description: "Test string",
                            expression: "Test string",
                            location: "Test string",
                            title: "Test string",
                        },
                        members: [
                            "Test string"
                        ],
                        role: "Test string",
                    }
                ],
                etag: "Test string",
                rules: [
                    {
                        action: "Test string",
                        conditions: [
                            {
                                iam: "Test string",
                                op: "Test string",
                                svc: "Test string",
                                sys: "Test string",
                                values: [
                                    "Test string"
                                ],
                            }
                        ],
                        description: "Test string",
                        ins: [
                            "Test string"
                        ],
                        logConfigs: [
                            {
                                cloudAudit: {
                                    authorizationLoggingOptions: {
                                        permissionType: "Test string",
                                    },
                                    logName: "Test string",
                                },
                                counter: {
                                    customFields: [
                                        {
                                            name: "Test string",
                                            value: "Test string",
                                        }
                                    ],
                                    field: "Test string",
                                    metric: "Test string",
                                },
                                dataAccess: {
                                    logMode: "Test string",
                                },
                            }
                        ],
                        notIns: [
                            "Test string"
                        ],
                        permissions: [
                            "Test string"
                        ],
                    }
                ],
                version: 42,
            },
        });
        /** Set whether VMs in this subnet can access Google services without assigning external IP addresses through Private Google Access. */
        await gapi.client.compute.subnetworks.setPrivateIpGoogleAccess({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            subnetwork: "Test string",
        }, {
            privateIpGoogleAccess: true,
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.subnetworks.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Deletes the specified TargetGrpcProxy in the given scope */
        await gapi.client.compute.targetGrpcProxies.delete({
            project: "Test string",
            requestId: "Test string",
            targetGrpcProxy: "Test string",
        });
        /** Returns the specified TargetGrpcProxy resource in the given scope. */
        await gapi.client.compute.targetGrpcProxies.get({
            project: "Test string",
            targetGrpcProxy: "Test string",
        });
        /** Creates a TargetGrpcProxy in the specified project in the given scope using the parameters that are included in the request. */
        await gapi.client.compute.targetGrpcProxies.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            urlMap: "Test string",
            validateForProxyless: true,
        });
        /** Lists the TargetGrpcProxies for a project in the given scope. */
        await gapi.client.compute.targetGrpcProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified TargetGrpcProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.targetGrpcProxies.patch({
            project: "Test string",
            requestId: "Test string",
            targetGrpcProxy: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            selfLink: "Test string",
            selfLinkWithId: "Test string",
            urlMap: "Test string",
            validateForProxyless: true,
        });
        /** Retrieves the list of all TargetHttpProxy resources, regional and global, available to the specified project. */
        await gapi.client.compute.targetHttpProxies.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified TargetHttpProxy resource. */
        await gapi.client.compute.targetHttpProxies.delete({
            project: "Test string",
            requestId: "Test string",
            targetHttpProxy: "Test string",
        });
        /** Returns the specified TargetHttpProxy resource. */
        await gapi.client.compute.targetHttpProxies.get({
            project: "Test string",
            targetHttpProxy: "Test string",
        });
        /** Creates a TargetHttpProxy resource in the specified project using the data included in the request. */
        await gapi.client.compute.targetHttpProxies.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            region: "Test string",
            selfLink: "Test string",
            urlMap: "Test string",
        });
        /** Retrieves the list of TargetHttpProxy resources available to the specified project. */
        await gapi.client.compute.targetHttpProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified TargetHttpProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.targetHttpProxies.patch({
            project: "Test string",
            requestId: "Test string",
            targetHttpProxy: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            region: "Test string",
            selfLink: "Test string",
            urlMap: "Test string",
        });
        /** Changes the URL map for TargetHttpProxy. */
        await gapi.client.compute.targetHttpProxies.setUrlMap({
            project: "Test string",
            requestId: "Test string",
            targetHttpProxy: "Test string",
        }, {
            urlMap: "Test string",
        });
        /** Retrieves the list of all TargetHttpsProxy resources, regional and global, available to the specified project. */
        await gapi.client.compute.targetHttpsProxies.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified TargetHttpsProxy resource. */
        await gapi.client.compute.targetHttpsProxies.delete({
            project: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        });
        /** Returns the specified TargetHttpsProxy resource. */
        await gapi.client.compute.targetHttpsProxies.get({
            project: "Test string",
            targetHttpsProxy: "Test string",
        });
        /** Creates a TargetHttpsProxy resource in the specified project using the data included in the request. */
        await gapi.client.compute.targetHttpsProxies.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            authorizationPolicy: "Test string",
            certificateMap: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            quicOverride: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serverTlsPolicy: "Test string",
            sslCertificates: [
                "Test string"
            ],
            sslPolicy: "Test string",
            urlMap: "Test string",
        });
        /** Retrieves the list of TargetHttpsProxy resources available to the specified project. */
        await gapi.client.compute.targetHttpsProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified TargetHttpsProxy resource with the data included in the request. This method supports PATCH semantics and uses JSON merge patch format and processing rules. */
        await gapi.client.compute.targetHttpsProxies.patch({
            project: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            authorizationPolicy: "Test string",
            certificateMap: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            fingerprint: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            quicOverride: "Test string",
            region: "Test string",
            selfLink: "Test string",
            serverTlsPolicy: "Test string",
            sslCertificates: [
                "Test string"
            ],
            sslPolicy: "Test string",
            urlMap: "Test string",
        });
        /** Changes the Certificate Map for TargetHttpsProxy. */
        await gapi.client.compute.targetHttpsProxies.setCertificateMap({
            project: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            certificateMap: "Test string",
        });
        /** Sets the QUIC override policy for TargetHttpsProxy. */
        await gapi.client.compute.targetHttpsProxies.setQuicOverride({
            project: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            quicOverride: "Test string",
        });
        /** Replaces SslCertificates for TargetHttpsProxy. */
        await gapi.client.compute.targetHttpsProxies.setSslCertificates({
            project: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            sslCertificates: [
                "Test string"
            ],
        });
        /**
         * Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the HTTPS proxy load balancer.
         * They do not affect the connection between the load balancer and the backends.
         */
        await gapi.client.compute.targetHttpsProxies.setSslPolicy({
            project: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            sslPolicy: "Test string",
        });
        /** Changes the URL map for TargetHttpsProxy. */
        await gapi.client.compute.targetHttpsProxies.setUrlMap({
            project: "Test string",
            requestId: "Test string",
            targetHttpsProxy: "Test string",
        }, {
            urlMap: "Test string",
        });
        /** Retrieves an aggregated list of target instances. */
        await gapi.client.compute.targetInstances.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified TargetInstance resource. */
        await gapi.client.compute.targetInstances.delete({
            project: "Test string",
            requestId: "Test string",
            targetInstance: "Test string",
            zone: "Test string",
        });
        /** Returns the specified TargetInstance resource. */
        await gapi.client.compute.targetInstances.get({
            project: "Test string",
            targetInstance: "Test string",
            zone: "Test string",
        });
        /** Creates a TargetInstance resource in the specified project and zone using the data included in the request. */
        await gapi.client.compute.targetInstances.insert({
            project: "Test string",
            requestId: "Test string",
            zone: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            instance: "Test string",
            kind: "Test string",
            name: "Test string",
            natPolicy: "Test string",
            network: "Test string",
            selfLink: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of TargetInstance resources available to the specified project and zone. */
        await gapi.client.compute.targetInstances.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /** Adds health check URLs to a target pool. */
        await gapi.client.compute.targetPools.addHealthCheck({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetPool: "Test string",
        }, {
            healthChecks: [
                {
                    healthCheck: "Test string",
                }
            ],
        });
        /** Adds an instance to a target pool. */
        await gapi.client.compute.targetPools.addInstance({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetPool: "Test string",
        }, {
            instances: [
                {
                    instance: "Test string",
                }
            ],
        });
        /** Retrieves an aggregated list of target pools. */
        await gapi.client.compute.targetPools.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified target pool. */
        await gapi.client.compute.targetPools.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetPool: "Test string",
        });
        /** Returns the specified target pool. */
        await gapi.client.compute.targetPools.get({
            project: "Test string",
            region: "Test string",
            targetPool: "Test string",
        });
        /** Gets the most recent health check results for each IP for the instance that is referenced by the given target pool. */
        await gapi.client.compute.targetPools.getHealth({
            project: "Test string",
            region: "Test string",
            targetPool: "Test string",
        }, {
            instance: "Test string",
        });
        /** Creates a target pool in the specified project and region using the data included in the request. */
        await gapi.client.compute.targetPools.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            backupPool: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            failoverRatio: 42,
            healthChecks: [
                "Test string"
            ],
            id: "Test string",
            instances: [
                "Test string"
            ],
            kind: "Test string",
            name: "Test string",
            region: "Test string",
            selfLink: "Test string",
            sessionAffinity: "Test string",
        });
        /** Retrieves a list of target pools available to the specified project and region. */
        await gapi.client.compute.targetPools.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Removes health check URL from a target pool. */
        await gapi.client.compute.targetPools.removeHealthCheck({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetPool: "Test string",
        }, {
            healthChecks: [
                {
                    healthCheck: "Test string",
                }
            ],
        });
        /** Removes instance URL from a target pool. */
        await gapi.client.compute.targetPools.removeInstance({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetPool: "Test string",
        }, {
            instances: [
                {
                    instance: "Test string",
                }
            ],
        });
        /** Changes a backup target pool's configurations. */
        await gapi.client.compute.targetPools.setBackup({
            failoverRatio: 42,
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetPool: "Test string",
        }, {
            target: "Test string",
        });
        /** Deletes the specified TargetSslProxy resource. */
        await gapi.client.compute.targetSslProxies.delete({
            project: "Test string",
            requestId: "Test string",
            targetSslProxy: "Test string",
        });
        /** Returns the specified TargetSslProxy resource. */
        await gapi.client.compute.targetSslProxies.get({
            project: "Test string",
            targetSslProxy: "Test string",
        });
        /** Creates a TargetSslProxy resource in the specified project using the data included in the request. */
        await gapi.client.compute.targetSslProxies.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            certificateMap: "Test string",
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyHeader: "Test string",
            selfLink: "Test string",
            service: "Test string",
            sslCertificates: [
                "Test string"
            ],
            sslPolicy: "Test string",
        });
        /** Retrieves the list of TargetSslProxy resources available to the specified project. */
        await gapi.client.compute.targetSslProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Changes the BackendService for TargetSslProxy. */
        await gapi.client.compute.targetSslProxies.setBackendService({
            project: "Test string",
            requestId: "Test string",
            targetSslProxy: "Test string",
        }, {
            service: "Test string",
        });
        /** Changes the Certificate Map for TargetSslProxy. */
        await gapi.client.compute.targetSslProxies.setCertificateMap({
            project: "Test string",
            requestId: "Test string",
            targetSslProxy: "Test string",
        }, {
            certificateMap: "Test string",
        });
        /** Changes the ProxyHeaderType for TargetSslProxy. */
        await gapi.client.compute.targetSslProxies.setProxyHeader({
            project: "Test string",
            requestId: "Test string",
            targetSslProxy: "Test string",
        }, {
            proxyHeader: "Test string",
        });
        /** Changes SslCertificates for TargetSslProxy. */
        await gapi.client.compute.targetSslProxies.setSslCertificates({
            project: "Test string",
            requestId: "Test string",
            targetSslProxy: "Test string",
        }, {
            sslCertificates: [
                "Test string"
            ],
        });
        /**
         * Sets the SSL policy for TargetSslProxy. The SSL policy specifies the server-side support for SSL features. This affects connections between clients and the SSL proxy load balancer. They
         * do not affect the connection between the load balancer and the backends.
         */
        await gapi.client.compute.targetSslProxies.setSslPolicy({
            project: "Test string",
            requestId: "Test string",
            targetSslProxy: "Test string",
        }, {
            sslPolicy: "Test string",
        });
        /** Retrieves the list of all TargetTcpProxy resources, regional and global, available to the specified project. */
        await gapi.client.compute.targetTcpProxies.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified TargetTcpProxy resource. */
        await gapi.client.compute.targetTcpProxies.delete({
            project: "Test string",
            requestId: "Test string",
            targetTcpProxy: "Test string",
        });
        /** Returns the specified TargetTcpProxy resource. */
        await gapi.client.compute.targetTcpProxies.get({
            project: "Test string",
            targetTcpProxy: "Test string",
        });
        /** Creates a TargetTcpProxy resource in the specified project using the data included in the request. */
        await gapi.client.compute.targetTcpProxies.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            proxyBind: true,
            proxyHeader: "Test string",
            region: "Test string",
            selfLink: "Test string",
            service: "Test string",
        });
        /** Retrieves the list of TargetTcpProxy resources available to the specified project. */
        await gapi.client.compute.targetTcpProxies.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Changes the BackendService for TargetTcpProxy. */
        await gapi.client.compute.targetTcpProxies.setBackendService({
            project: "Test string",
            requestId: "Test string",
            targetTcpProxy: "Test string",
        }, {
            service: "Test string",
        });
        /** Changes the ProxyHeaderType for TargetTcpProxy. */
        await gapi.client.compute.targetTcpProxies.setProxyHeader({
            project: "Test string",
            requestId: "Test string",
            targetTcpProxy: "Test string",
        }, {
            proxyHeader: "Test string",
        });
        /** Retrieves an aggregated list of target VPN gateways. */
        await gapi.client.compute.targetVpnGateways.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified target VPN gateway. */
        await gapi.client.compute.targetVpnGateways.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            targetVpnGateway: "Test string",
        });
        /** Returns the specified target VPN gateway. */
        await gapi.client.compute.targetVpnGateways.get({
            project: "Test string",
            region: "Test string",
            targetVpnGateway: "Test string",
        });
        /** Creates a target VPN gateway in the specified project and region using the data included in the request. */
        await gapi.client.compute.targetVpnGateways.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            forwardingRules: [
                "Test string"
            ],
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            region: "Test string",
            selfLink: "Test string",
            status: "Test string",
            tunnels: [
                "Test string"
            ],
        });
        /** Retrieves a list of target VPN gateways available to the specified project and region. */
        await gapi.client.compute.targetVpnGateways.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the labels on a TargetVpnGateway. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.targetVpnGateways.setLabels({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Retrieves the list of all UrlMap resources, regional and global, available to the specified project. */
        await gapi.client.compute.urlMaps.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified UrlMap resource. */
        await gapi.client.compute.urlMaps.delete({
            project: "Test string",
            requestId: "Test string",
            urlMap: "Test string",
        });
        /** Returns the specified UrlMap resource. */
        await gapi.client.compute.urlMaps.get({
            project: "Test string",
            urlMap: "Test string",
        });
        /** Creates a UrlMap resource in the specified project using the data included in the request. */
        await gapi.client.compute.urlMaps.insert({
            project: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            defaultRouteAction: {
                corsPolicy: {
                    allowCredentials: true,
                    allowHeaders: [
                        "Test string"
                    ],
                    allowMethods: [
                        "Test string"
                    ],
                    allowOriginRegexes: [
                        "Test string"
                    ],
                    allowOrigins: [
                        "Test string"
                    ],
                    disabled: true,
                    exposeHeaders: [
                        "Test string"
                    ],
                    maxAge: 42,
                },
                faultInjectionPolicy: {
                    abort: {
                        httpStatus: 42,
                        percentage: 42,
                    },
                    delay: {
                        fixedDelay: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        percentage: 42,
                    },
                },
                maxStreamDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                requestMirrorPolicy: {
                    backendService: "Test string",
                },
                retryPolicy: {
                    numRetries: 42,
                    perTryTimeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    retryConditions: [
                        "Test string"
                    ],
                },
                timeout: {
                    nanos: 42,
                    seconds: "Test string",
                },
                urlRewrite: {
                    hostRewrite: "Test string",
                    pathPrefixRewrite: "Test string",
                    pathTemplateRewrite: "Test string",
                },
                weightedBackendServices: [
                    {
                        backendService: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        weight: 42,
                    }
                ],
            },
            defaultService: "Test string",
            defaultUrlRedirect: {
                hostRedirect: "Test string",
                httpsRedirect: true,
                pathRedirect: "Test string",
                prefixRedirect: "Test string",
                redirectResponseCode: "Test string",
                stripQuery: true,
            },
            description: "Test string",
            fingerprint: "Test string",
            headerAction: {
                requestHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                requestHeadersToRemove: [
                    "Test string"
                ],
                responseHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                responseHeadersToRemove: [
                    "Test string"
                ],
            },
            hostRules: [
                {
                    description: "Test string",
                    hosts: [
                        "Test string"
                    ],
                    pathMatcher: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            pathMatchers: [
                {
                    defaultRouteAction: {
                        corsPolicy: {
                            allowCredentials: true,
                            allowHeaders: [
                                "Test string"
                            ],
                            allowMethods: [
                                "Test string"
                            ],
                            allowOriginRegexes: [
                                "Test string"
                            ],
                            allowOrigins: [
                                "Test string"
                            ],
                            disabled: true,
                            exposeHeaders: [
                                "Test string"
                            ],
                            maxAge: 42,
                        },
                        faultInjectionPolicy: {
                            abort: {
                                httpStatus: 42,
                                percentage: 42,
                            },
                            delay: {
                                fixedDelay: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                percentage: 42,
                            },
                        },
                        maxStreamDuration: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        requestMirrorPolicy: {
                            backendService: "Test string",
                        },
                        retryPolicy: {
                            numRetries: 42,
                            perTryTimeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            retryConditions: [
                                "Test string"
                            ],
                        },
                        timeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        urlRewrite: {
                            hostRewrite: "Test string",
                            pathPrefixRewrite: "Test string",
                            pathTemplateRewrite: "Test string",
                        },
                        weightedBackendServices: [
                            {
                                backendService: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                weight: 42,
                            }
                        ],
                    },
                    defaultService: "Test string",
                    defaultUrlRedirect: {
                        hostRedirect: "Test string",
                        httpsRedirect: true,
                        pathRedirect: "Test string",
                        prefixRedirect: "Test string",
                        redirectResponseCode: "Test string",
                        stripQuery: true,
                    },
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        requestHeadersToRemove: [
                            "Test string"
                        ],
                        responseHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        responseHeadersToRemove: [
                            "Test string"
                        ],
                    },
                    name: "Test string",
                    pathRules: [
                        {
                            paths: [
                                "Test string"
                            ],
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                    routeRules: [
                        {
                            description: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            matchRules: [
                                {
                                    fullPathMatch: "Test string",
                                    headerMatches: [
                                        {
                                            exactMatch: "Test string",
                                            headerName: "Test string",
                                            invertMatch: true,
                                            prefixMatch: "Test string",
                                            presentMatch: true,
                                            rangeMatch: {
                                                rangeEnd: "Test string",
                                                rangeStart: "Test string",
                                            },
                                            regexMatch: "Test string",
                                            suffixMatch: "Test string",
                                        }
                                    ],
                                    ignoreCase: true,
                                    metadataFilters: [
                                        {
                                            filterLabels: [
                                                {
                                                    name: "Test string",
                                                    value: "Test string",
                                                }
                                            ],
                                            filterMatchCriteria: "Test string",
                                        }
                                    ],
                                    pathTemplateMatch: "Test string",
                                    prefixMatch: "Test string",
                                    queryParameterMatches: [
                                        {
                                            exactMatch: "Test string",
                                            name: "Test string",
                                            presentMatch: true,
                                            regexMatch: "Test string",
                                        }
                                    ],
                                    regexMatch: "Test string",
                                }
                            ],
                            priority: 42,
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            tests: [
                {
                    description: "Test string",
                    expectedOutputUrl: "Test string",
                    expectedRedirectResponseCode: 42,
                    headers: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    host: "Test string",
                    path: "Test string",
                    service: "Test string",
                }
            ],
        });
        /**
         * Initiates a cache invalidation operation, invalidating the specified path, scoped to the specified UrlMap. For more information, see [Invalidating cached
         * content](/cdn/docs/invalidating-cached-content).
         */
        await gapi.client.compute.urlMaps.invalidateCache({
            project: "Test string",
            requestId: "Test string",
            urlMap: "Test string",
        }, {
            host: "Test string",
            path: "Test string",
        });
        /** Retrieves the list of UrlMap resources available to the specified project. */
        await gapi.client.compute.urlMaps.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Patches the specified UrlMap resource with the data included in the request. This method supports PATCH semantics and uses the JSON merge patch format and processing rules. */
        await gapi.client.compute.urlMaps.patch({
            project: "Test string",
            requestId: "Test string",
            urlMap: "Test string",
        }, {
            creationTimestamp: "Test string",
            defaultRouteAction: {
                corsPolicy: {
                    allowCredentials: true,
                    allowHeaders: [
                        "Test string"
                    ],
                    allowMethods: [
                        "Test string"
                    ],
                    allowOriginRegexes: [
                        "Test string"
                    ],
                    allowOrigins: [
                        "Test string"
                    ],
                    disabled: true,
                    exposeHeaders: [
                        "Test string"
                    ],
                    maxAge: 42,
                },
                faultInjectionPolicy: {
                    abort: {
                        httpStatus: 42,
                        percentage: 42,
                    },
                    delay: {
                        fixedDelay: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        percentage: 42,
                    },
                },
                maxStreamDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                requestMirrorPolicy: {
                    backendService: "Test string",
                },
                retryPolicy: {
                    numRetries: 42,
                    perTryTimeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    retryConditions: [
                        "Test string"
                    ],
                },
                timeout: {
                    nanos: 42,
                    seconds: "Test string",
                },
                urlRewrite: {
                    hostRewrite: "Test string",
                    pathPrefixRewrite: "Test string",
                    pathTemplateRewrite: "Test string",
                },
                weightedBackendServices: [
                    {
                        backendService: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        weight: 42,
                    }
                ],
            },
            defaultService: "Test string",
            defaultUrlRedirect: {
                hostRedirect: "Test string",
                httpsRedirect: true,
                pathRedirect: "Test string",
                prefixRedirect: "Test string",
                redirectResponseCode: "Test string",
                stripQuery: true,
            },
            description: "Test string",
            fingerprint: "Test string",
            headerAction: {
                requestHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                requestHeadersToRemove: [
                    "Test string"
                ],
                responseHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                responseHeadersToRemove: [
                    "Test string"
                ],
            },
            hostRules: [
                {
                    description: "Test string",
                    hosts: [
                        "Test string"
                    ],
                    pathMatcher: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            pathMatchers: [
                {
                    defaultRouteAction: {
                        corsPolicy: {
                            allowCredentials: true,
                            allowHeaders: [
                                "Test string"
                            ],
                            allowMethods: [
                                "Test string"
                            ],
                            allowOriginRegexes: [
                                "Test string"
                            ],
                            allowOrigins: [
                                "Test string"
                            ],
                            disabled: true,
                            exposeHeaders: [
                                "Test string"
                            ],
                            maxAge: 42,
                        },
                        faultInjectionPolicy: {
                            abort: {
                                httpStatus: 42,
                                percentage: 42,
                            },
                            delay: {
                                fixedDelay: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                percentage: 42,
                            },
                        },
                        maxStreamDuration: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        requestMirrorPolicy: {
                            backendService: "Test string",
                        },
                        retryPolicy: {
                            numRetries: 42,
                            perTryTimeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            retryConditions: [
                                "Test string"
                            ],
                        },
                        timeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        urlRewrite: {
                            hostRewrite: "Test string",
                            pathPrefixRewrite: "Test string",
                            pathTemplateRewrite: "Test string",
                        },
                        weightedBackendServices: [
                            {
                                backendService: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                weight: 42,
                            }
                        ],
                    },
                    defaultService: "Test string",
                    defaultUrlRedirect: {
                        hostRedirect: "Test string",
                        httpsRedirect: true,
                        pathRedirect: "Test string",
                        prefixRedirect: "Test string",
                        redirectResponseCode: "Test string",
                        stripQuery: true,
                    },
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        requestHeadersToRemove: [
                            "Test string"
                        ],
                        responseHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        responseHeadersToRemove: [
                            "Test string"
                        ],
                    },
                    name: "Test string",
                    pathRules: [
                        {
                            paths: [
                                "Test string"
                            ],
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                    routeRules: [
                        {
                            description: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            matchRules: [
                                {
                                    fullPathMatch: "Test string",
                                    headerMatches: [
                                        {
                                            exactMatch: "Test string",
                                            headerName: "Test string",
                                            invertMatch: true,
                                            prefixMatch: "Test string",
                                            presentMatch: true,
                                            rangeMatch: {
                                                rangeEnd: "Test string",
                                                rangeStart: "Test string",
                                            },
                                            regexMatch: "Test string",
                                            suffixMatch: "Test string",
                                        }
                                    ],
                                    ignoreCase: true,
                                    metadataFilters: [
                                        {
                                            filterLabels: [
                                                {
                                                    name: "Test string",
                                                    value: "Test string",
                                                }
                                            ],
                                            filterMatchCriteria: "Test string",
                                        }
                                    ],
                                    pathTemplateMatch: "Test string",
                                    prefixMatch: "Test string",
                                    queryParameterMatches: [
                                        {
                                            exactMatch: "Test string",
                                            name: "Test string",
                                            presentMatch: true,
                                            regexMatch: "Test string",
                                        }
                                    ],
                                    regexMatch: "Test string",
                                }
                            ],
                            priority: 42,
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            tests: [
                {
                    description: "Test string",
                    expectedOutputUrl: "Test string",
                    expectedRedirectResponseCode: 42,
                    headers: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    host: "Test string",
                    path: "Test string",
                    service: "Test string",
                }
            ],
        });
        /** Updates the specified UrlMap resource with the data included in the request. */
        await gapi.client.compute.urlMaps.update({
            project: "Test string",
            requestId: "Test string",
            urlMap: "Test string",
        }, {
            creationTimestamp: "Test string",
            defaultRouteAction: {
                corsPolicy: {
                    allowCredentials: true,
                    allowHeaders: [
                        "Test string"
                    ],
                    allowMethods: [
                        "Test string"
                    ],
                    allowOriginRegexes: [
                        "Test string"
                    ],
                    allowOrigins: [
                        "Test string"
                    ],
                    disabled: true,
                    exposeHeaders: [
                        "Test string"
                    ],
                    maxAge: 42,
                },
                faultInjectionPolicy: {
                    abort: {
                        httpStatus: 42,
                        percentage: 42,
                    },
                    delay: {
                        fixedDelay: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        percentage: 42,
                    },
                },
                maxStreamDuration: {
                    nanos: 42,
                    seconds: "Test string",
                },
                requestMirrorPolicy: {
                    backendService: "Test string",
                },
                retryPolicy: {
                    numRetries: 42,
                    perTryTimeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    retryConditions: [
                        "Test string"
                    ],
                },
                timeout: {
                    nanos: 42,
                    seconds: "Test string",
                },
                urlRewrite: {
                    hostRewrite: "Test string",
                    pathPrefixRewrite: "Test string",
                    pathTemplateRewrite: "Test string",
                },
                weightedBackendServices: [
                    {
                        backendService: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        weight: 42,
                    }
                ],
            },
            defaultService: "Test string",
            defaultUrlRedirect: {
                hostRedirect: "Test string",
                httpsRedirect: true,
                pathRedirect: "Test string",
                prefixRedirect: "Test string",
                redirectResponseCode: "Test string",
                stripQuery: true,
            },
            description: "Test string",
            fingerprint: "Test string",
            headerAction: {
                requestHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                requestHeadersToRemove: [
                    "Test string"
                ],
                responseHeadersToAdd: [
                    {
                        headerName: "Test string",
                        headerValue: "Test string",
                        replace: true,
                    }
                ],
                responseHeadersToRemove: [
                    "Test string"
                ],
            },
            hostRules: [
                {
                    description: "Test string",
                    hosts: [
                        "Test string"
                    ],
                    pathMatcher: "Test string",
                }
            ],
            id: "Test string",
            kind: "Test string",
            name: "Test string",
            pathMatchers: [
                {
                    defaultRouteAction: {
                        corsPolicy: {
                            allowCredentials: true,
                            allowHeaders: [
                                "Test string"
                            ],
                            allowMethods: [
                                "Test string"
                            ],
                            allowOriginRegexes: [
                                "Test string"
                            ],
                            allowOrigins: [
                                "Test string"
                            ],
                            disabled: true,
                            exposeHeaders: [
                                "Test string"
                            ],
                            maxAge: 42,
                        },
                        faultInjectionPolicy: {
                            abort: {
                                httpStatus: 42,
                                percentage: 42,
                            },
                            delay: {
                                fixedDelay: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                percentage: 42,
                            },
                        },
                        maxStreamDuration: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        requestMirrorPolicy: {
                            backendService: "Test string",
                        },
                        retryPolicy: {
                            numRetries: 42,
                            perTryTimeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            retryConditions: [
                                "Test string"
                            ],
                        },
                        timeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        urlRewrite: {
                            hostRewrite: "Test string",
                            pathPrefixRewrite: "Test string",
                            pathTemplateRewrite: "Test string",
                        },
                        weightedBackendServices: [
                            {
                                backendService: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                weight: 42,
                            }
                        ],
                    },
                    defaultService: "Test string",
                    defaultUrlRedirect: {
                        hostRedirect: "Test string",
                        httpsRedirect: true,
                        pathRedirect: "Test string",
                        prefixRedirect: "Test string",
                        redirectResponseCode: "Test string",
                        stripQuery: true,
                    },
                    description: "Test string",
                    headerAction: {
                        requestHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        requestHeadersToRemove: [
                            "Test string"
                        ],
                        responseHeadersToAdd: [
                            {
                                headerName: "Test string",
                                headerValue: "Test string",
                                replace: true,
                            }
                        ],
                        responseHeadersToRemove: [
                            "Test string"
                        ],
                    },
                    name: "Test string",
                    pathRules: [
                        {
                            paths: [
                                "Test string"
                            ],
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                    routeRules: [
                        {
                            description: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            matchRules: [
                                {
                                    fullPathMatch: "Test string",
                                    headerMatches: [
                                        {
                                            exactMatch: "Test string",
                                            headerName: "Test string",
                                            invertMatch: true,
                                            prefixMatch: "Test string",
                                            presentMatch: true,
                                            rangeMatch: {
                                                rangeEnd: "Test string",
                                                rangeStart: "Test string",
                                            },
                                            regexMatch: "Test string",
                                            suffixMatch: "Test string",
                                        }
                                    ],
                                    ignoreCase: true,
                                    metadataFilters: [
                                        {
                                            filterLabels: [
                                                {
                                                    name: "Test string",
                                                    value: "Test string",
                                                }
                                            ],
                                            filterMatchCriteria: "Test string",
                                        }
                                    ],
                                    pathTemplateMatch: "Test string",
                                    prefixMatch: "Test string",
                                    queryParameterMatches: [
                                        {
                                            exactMatch: "Test string",
                                            name: "Test string",
                                            presentMatch: true,
                                            regexMatch: "Test string",
                                        }
                                    ],
                                    regexMatch: "Test string",
                                }
                            ],
                            priority: 42,
                            routeAction: {
                                corsPolicy: {
                                    allowCredentials: true,
                                    allowHeaders: [
                                        "Test string"
                                    ],
                                    allowMethods: [
                                        "Test string"
                                    ],
                                    allowOriginRegexes: [
                                        "Test string"
                                    ],
                                    allowOrigins: [
                                        "Test string"
                                    ],
                                    disabled: true,
                                    exposeHeaders: [
                                        "Test string"
                                    ],
                                    maxAge: 42,
                                },
                                faultInjectionPolicy: {
                                    abort: {
                                        httpStatus: 42,
                                        percentage: 42,
                                    },
                                    delay: {
                                        fixedDelay: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        percentage: 42,
                                    },
                                },
                                maxStreamDuration: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                requestMirrorPolicy: {
                                    backendService: "Test string",
                                },
                                retryPolicy: {
                                    numRetries: 42,
                                    perTryTimeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    retryConditions: [
                                        "Test string"
                                    ],
                                },
                                timeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                urlRewrite: {
                                    hostRewrite: "Test string",
                                    pathPrefixRewrite: "Test string",
                                    pathTemplateRewrite: "Test string",
                                },
                                weightedBackendServices: [
                                    {
                                        backendService: "Test string",
                                        headerAction: {
                                            requestHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            requestHeadersToRemove: [
                                                "Test string"
                                            ],
                                            responseHeadersToAdd: [
                                                {
                                                    headerName: "Test string",
                                                    headerValue: "Test string",
                                                    replace: true,
                                                }
                                            ],
                                            responseHeadersToRemove: [
                                                "Test string"
                                            ],
                                        },
                                        weight: 42,
                                    }
                                ],
                            },
                            service: "Test string",
                            urlRedirect: {
                                hostRedirect: "Test string",
                                httpsRedirect: true,
                                pathRedirect: "Test string",
                                prefixRedirect: "Test string",
                                redirectResponseCode: "Test string",
                                stripQuery: true,
                            },
                        }
                    ],
                }
            ],
            region: "Test string",
            selfLink: "Test string",
            tests: [
                {
                    description: "Test string",
                    expectedOutputUrl: "Test string",
                    expectedRedirectResponseCode: 42,
                    headers: [
                        {
                            name: "Test string",
                            value: "Test string",
                        }
                    ],
                    host: "Test string",
                    path: "Test string",
                    service: "Test string",
                }
            ],
        });
        /** Runs static validation for the UrlMap. In particular, the tests of the provided UrlMap will be run. Calling this method does NOT create the UrlMap. */
        await gapi.client.compute.urlMaps.validate({
            project: "Test string",
            urlMap: "Test string",
        }, {
            loadBalancingSchemes: [
                "Test string"
            ],
            resource: {
                creationTimestamp: "Test string",
                defaultRouteAction: {
                    corsPolicy: {
                        allowCredentials: true,
                        allowHeaders: [
                            "Test string"
                        ],
                        allowMethods: [
                            "Test string"
                        ],
                        allowOriginRegexes: [
                            "Test string"
                        ],
                        allowOrigins: [
                            "Test string"
                        ],
                        disabled: true,
                        exposeHeaders: [
                            "Test string"
                        ],
                        maxAge: 42,
                    },
                    faultInjectionPolicy: {
                        abort: {
                            httpStatus: 42,
                            percentage: 42,
                        },
                        delay: {
                            fixedDelay: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            percentage: 42,
                        },
                    },
                    maxStreamDuration: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    requestMirrorPolicy: {
                        backendService: "Test string",
                    },
                    retryPolicy: {
                        numRetries: 42,
                        perTryTimeout: {
                            nanos: 42,
                            seconds: "Test string",
                        },
                        retryConditions: [
                            "Test string"
                        ],
                    },
                    timeout: {
                        nanos: 42,
                        seconds: "Test string",
                    },
                    urlRewrite: {
                        hostRewrite: "Test string",
                        pathPrefixRewrite: "Test string",
                        pathTemplateRewrite: "Test string",
                    },
                    weightedBackendServices: [
                        {
                            backendService: "Test string",
                            headerAction: {
                                requestHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                requestHeadersToRemove: [
                                    "Test string"
                                ],
                                responseHeadersToAdd: [
                                    {
                                        headerName: "Test string",
                                        headerValue: "Test string",
                                        replace: true,
                                    }
                                ],
                                responseHeadersToRemove: [
                                    "Test string"
                                ],
                            },
                            weight: 42,
                        }
                    ],
                },
                defaultService: "Test string",
                defaultUrlRedirect: {
                    hostRedirect: "Test string",
                    httpsRedirect: true,
                    pathRedirect: "Test string",
                    prefixRedirect: "Test string",
                    redirectResponseCode: "Test string",
                    stripQuery: true,
                },
                description: "Test string",
                fingerprint: "Test string",
                headerAction: {
                    requestHeadersToAdd: [
                        {
                            headerName: "Test string",
                            headerValue: "Test string",
                            replace: true,
                        }
                    ],
                    requestHeadersToRemove: [
                        "Test string"
                    ],
                    responseHeadersToAdd: [
                        {
                            headerName: "Test string",
                            headerValue: "Test string",
                            replace: true,
                        }
                    ],
                    responseHeadersToRemove: [
                        "Test string"
                    ],
                },
                hostRules: [
                    {
                        description: "Test string",
                        hosts: [
                            "Test string"
                        ],
                        pathMatcher: "Test string",
                    }
                ],
                id: "Test string",
                kind: "Test string",
                name: "Test string",
                pathMatchers: [
                    {
                        defaultRouteAction: {
                            corsPolicy: {
                                allowCredentials: true,
                                allowHeaders: [
                                    "Test string"
                                ],
                                allowMethods: [
                                    "Test string"
                                ],
                                allowOriginRegexes: [
                                    "Test string"
                                ],
                                allowOrigins: [
                                    "Test string"
                                ],
                                disabled: true,
                                exposeHeaders: [
                                    "Test string"
                                ],
                                maxAge: 42,
                            },
                            faultInjectionPolicy: {
                                abort: {
                                    httpStatus: 42,
                                    percentage: 42,
                                },
                                delay: {
                                    fixedDelay: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    percentage: 42,
                                },
                            },
                            maxStreamDuration: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            requestMirrorPolicy: {
                                backendService: "Test string",
                            },
                            retryPolicy: {
                                numRetries: 42,
                                perTryTimeout: {
                                    nanos: 42,
                                    seconds: "Test string",
                                },
                                retryConditions: [
                                    "Test string"
                                ],
                            },
                            timeout: {
                                nanos: 42,
                                seconds: "Test string",
                            },
                            urlRewrite: {
                                hostRewrite: "Test string",
                                pathPrefixRewrite: "Test string",
                                pathTemplateRewrite: "Test string",
                            },
                            weightedBackendServices: [
                                {
                                    backendService: "Test string",
                                    headerAction: {
                                        requestHeadersToAdd: [
                                            {
                                                headerName: "Test string",
                                                headerValue: "Test string",
                                                replace: true,
                                            }
                                        ],
                                        requestHeadersToRemove: [
                                            "Test string"
                                        ],
                                        responseHeadersToAdd: [
                                            {
                                                headerName: "Test string",
                                                headerValue: "Test string",
                                                replace: true,
                                            }
                                        ],
                                        responseHeadersToRemove: [
                                            "Test string"
                                        ],
                                    },
                                    weight: 42,
                                }
                            ],
                        },
                        defaultService: "Test string",
                        defaultUrlRedirect: {
                            hostRedirect: "Test string",
                            httpsRedirect: true,
                            pathRedirect: "Test string",
                            prefixRedirect: "Test string",
                            redirectResponseCode: "Test string",
                            stripQuery: true,
                        },
                        description: "Test string",
                        headerAction: {
                            requestHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            requestHeadersToRemove: [
                                "Test string"
                            ],
                            responseHeadersToAdd: [
                                {
                                    headerName: "Test string",
                                    headerValue: "Test string",
                                    replace: true,
                                }
                            ],
                            responseHeadersToRemove: [
                                "Test string"
                            ],
                        },
                        name: "Test string",
                        pathRules: [
                            {
                                paths: [
                                    "Test string"
                                ],
                                routeAction: {
                                    corsPolicy: {
                                        allowCredentials: true,
                                        allowHeaders: [
                                            "Test string"
                                        ],
                                        allowMethods: [
                                            "Test string"
                                        ],
                                        allowOriginRegexes: [
                                            "Test string"
                                        ],
                                        allowOrigins: [
                                            "Test string"
                                        ],
                                        disabled: true,
                                        exposeHeaders: [
                                            "Test string"
                                        ],
                                        maxAge: 42,
                                    },
                                    faultInjectionPolicy: {
                                        abort: {
                                            httpStatus: 42,
                                            percentage: 42,
                                        },
                                        delay: {
                                            fixedDelay: {
                                                nanos: 42,
                                                seconds: "Test string",
                                            },
                                            percentage: 42,
                                        },
                                    },
                                    maxStreamDuration: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    requestMirrorPolicy: {
                                        backendService: "Test string",
                                    },
                                    retryPolicy: {
                                        numRetries: 42,
                                        perTryTimeout: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        retryConditions: [
                                            "Test string"
                                        ],
                                    },
                                    timeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    urlRewrite: {
                                        hostRewrite: "Test string",
                                        pathPrefixRewrite: "Test string",
                                        pathTemplateRewrite: "Test string",
                                    },
                                    weightedBackendServices: [
                                        {
                                            backendService: "Test string",
                                            headerAction: {
                                                requestHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                requestHeadersToRemove: [
                                                    "Test string"
                                                ],
                                                responseHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                responseHeadersToRemove: [
                                                    "Test string"
                                                ],
                                            },
                                            weight: 42,
                                        }
                                    ],
                                },
                                service: "Test string",
                                urlRedirect: {
                                    hostRedirect: "Test string",
                                    httpsRedirect: true,
                                    pathRedirect: "Test string",
                                    prefixRedirect: "Test string",
                                    redirectResponseCode: "Test string",
                                    stripQuery: true,
                                },
                            }
                        ],
                        routeRules: [
                            {
                                description: "Test string",
                                headerAction: {
                                    requestHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    requestHeadersToRemove: [
                                        "Test string"
                                    ],
                                    responseHeadersToAdd: [
                                        {
                                            headerName: "Test string",
                                            headerValue: "Test string",
                                            replace: true,
                                        }
                                    ],
                                    responseHeadersToRemove: [
                                        "Test string"
                                    ],
                                },
                                matchRules: [
                                    {
                                        fullPathMatch: "Test string",
                                        headerMatches: [
                                            {
                                                exactMatch: "Test string",
                                                headerName: "Test string",
                                                invertMatch: true,
                                                prefixMatch: "Test string",
                                                presentMatch: true,
                                                rangeMatch: {
                                                    rangeEnd: "Test string",
                                                    rangeStart: "Test string",
                                                },
                                                regexMatch: "Test string",
                                                suffixMatch: "Test string",
                                            }
                                        ],
                                        ignoreCase: true,
                                        metadataFilters: [
                                            {
                                                filterLabels: [
                                                    {
                                                        name: "Test string",
                                                        value: "Test string",
                                                    }
                                                ],
                                                filterMatchCriteria: "Test string",
                                            }
                                        ],
                                        pathTemplateMatch: "Test string",
                                        prefixMatch: "Test string",
                                        queryParameterMatches: [
                                            {
                                                exactMatch: "Test string",
                                                name: "Test string",
                                                presentMatch: true,
                                                regexMatch: "Test string",
                                            }
                                        ],
                                        regexMatch: "Test string",
                                    }
                                ],
                                priority: 42,
                                routeAction: {
                                    corsPolicy: {
                                        allowCredentials: true,
                                        allowHeaders: [
                                            "Test string"
                                        ],
                                        allowMethods: [
                                            "Test string"
                                        ],
                                        allowOriginRegexes: [
                                            "Test string"
                                        ],
                                        allowOrigins: [
                                            "Test string"
                                        ],
                                        disabled: true,
                                        exposeHeaders: [
                                            "Test string"
                                        ],
                                        maxAge: 42,
                                    },
                                    faultInjectionPolicy: {
                                        abort: {
                                            httpStatus: 42,
                                            percentage: 42,
                                        },
                                        delay: {
                                            fixedDelay: {
                                                nanos: 42,
                                                seconds: "Test string",
                                            },
                                            percentage: 42,
                                        },
                                    },
                                    maxStreamDuration: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    requestMirrorPolicy: {
                                        backendService: "Test string",
                                    },
                                    retryPolicy: {
                                        numRetries: 42,
                                        perTryTimeout: {
                                            nanos: 42,
                                            seconds: "Test string",
                                        },
                                        retryConditions: [
                                            "Test string"
                                        ],
                                    },
                                    timeout: {
                                        nanos: 42,
                                        seconds: "Test string",
                                    },
                                    urlRewrite: {
                                        hostRewrite: "Test string",
                                        pathPrefixRewrite: "Test string",
                                        pathTemplateRewrite: "Test string",
                                    },
                                    weightedBackendServices: [
                                        {
                                            backendService: "Test string",
                                            headerAction: {
                                                requestHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                requestHeadersToRemove: [
                                                    "Test string"
                                                ],
                                                responseHeadersToAdd: [
                                                    {
                                                        headerName: "Test string",
                                                        headerValue: "Test string",
                                                        replace: true,
                                                    }
                                                ],
                                                responseHeadersToRemove: [
                                                    "Test string"
                                                ],
                                            },
                                            weight: 42,
                                        }
                                    ],
                                },
                                service: "Test string",
                                urlRedirect: {
                                    hostRedirect: "Test string",
                                    httpsRedirect: true,
                                    pathRedirect: "Test string",
                                    prefixRedirect: "Test string",
                                    redirectResponseCode: "Test string",
                                    stripQuery: true,
                                },
                            }
                        ],
                    }
                ],
                region: "Test string",
                selfLink: "Test string",
                tests: [
                    {
                        description: "Test string",
                        expectedOutputUrl: "Test string",
                        expectedRedirectResponseCode: 42,
                        headers: [
                            {
                                name: "Test string",
                                value: "Test string",
                            }
                        ],
                        host: "Test string",
                        path: "Test string",
                        service: "Test string",
                    }
                ],
            },
        });
        /** Retrieves an aggregated list of VPN gateways. */
        await gapi.client.compute.vpnGateways.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified VPN gateway. */
        await gapi.client.compute.vpnGateways.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            vpnGateway: "Test string",
        });
        /** Returns the specified VPN gateway. */
        await gapi.client.compute.vpnGateways.get({
            project: "Test string",
            region: "Test string",
            vpnGateway: "Test string",
        });
        /** Returns the status for the specified VPN gateway. */
        await gapi.client.compute.vpnGateways.getStatus({
            project: "Test string",
            region: "Test string",
            vpnGateway: "Test string",
        });
        /** Creates a VPN gateway in the specified project and region using the data included in the request. */
        await gapi.client.compute.vpnGateways.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            id: "Test string",
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            name: "Test string",
            network: "Test string",
            region: "Test string",
            selfLink: "Test string",
            stackType: "Test string",
            vpnInterfaces: [
                {
                    id: 42,
                    interconnectAttachment: "Test string",
                    ipAddress: "Test string",
                }
            ],
        });
        /** Retrieves a list of VPN gateways available to the specified project and region. */
        await gapi.client.compute.vpnGateways.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the labels on a VpnGateway. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.vpnGateways.setLabels({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Returns permissions that a caller has on the specified resource. */
        await gapi.client.compute.vpnGateways.testIamPermissions({
            project: "Test string",
            region: "Test string",
            resource: "Test string",
        }, {
            permissions: [
                "Test string"
            ],
        });
        /** Retrieves an aggregated list of VPN tunnels. */
        await gapi.client.compute.vpnTunnels.aggregatedList({
            filter: "Test string",
            includeAllScopes: true,
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
        /** Deletes the specified VpnTunnel resource. */
        await gapi.client.compute.vpnTunnels.delete({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            vpnTunnel: "Test string",
        });
        /** Returns the specified VpnTunnel resource. */
        await gapi.client.compute.vpnTunnels.get({
            project: "Test string",
            region: "Test string",
            vpnTunnel: "Test string",
        });
        /** Creates a VpnTunnel resource in the specified project and region using the data included in the request. */
        await gapi.client.compute.vpnTunnels.insert({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
        }, {
            creationTimestamp: "Test string",
            description: "Test string",
            detailedStatus: "Test string",
            id: "Test string",
            ikeVersion: 42,
            kind: "Test string",
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
            localTrafficSelector: [
                "Test string"
            ],
            name: "Test string",
            peerExternalGateway: "Test string",
            peerExternalGatewayInterface: 42,
            peerGcpGateway: "Test string",
            peerIp: "Test string",
            region: "Test string",
            remoteTrafficSelector: [
                "Test string"
            ],
            router: "Test string",
            selfLink: "Test string",
            sharedSecret: "Test string",
            sharedSecretHash: "Test string",
            status: "Test string",
            targetVpnGateway: "Test string",
            vpnGateway: "Test string",
            vpnGatewayInterface: 42,
        });
        /** Retrieves a list of VpnTunnel resources contained in the specified project and region. */
        await gapi.client.compute.vpnTunnels.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            region: "Test string",
            returnPartialSuccess: true,
        });
        /** Sets the labels on a VpnTunnel. To learn more about labels, read the Labeling Resources documentation. */
        await gapi.client.compute.vpnTunnels.setLabels({
            project: "Test string",
            region: "Test string",
            requestId: "Test string",
            resource: "Test string",
        }, {
            labelFingerprint: "Test string",
            labels: {
                A: "Test string"
            },
        });
        /** Deletes the specified zone-specific Operations resource. */
        await gapi.client.compute.zoneOperations.delete({
            operation: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Retrieves the specified zone-specific Operations resource. */
        await gapi.client.compute.zoneOperations.get({
            operation: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Retrieves a list of Operation resources contained within the specified zone. */
        await gapi.client.compute.zoneOperations.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
            zone: "Test string",
        });
        /**
         * Waits for the specified Operation resource to return as `DONE` or for the request to approach the 2 minute deadline, and retrieves the specified Operation resource. This method waits
         * for no more than the 2 minutes and then returns the current state of the operation, which might be `DONE` or still in progress. This method is called on a best-effort basis.
         * Specifically: - In uncommon cases, when the server is overloaded, the request might return before the default deadline is reached, or might return after zero seconds. - If the default
         * deadline is reached, there is no guarantee that the operation is actually done when the method returns. Be prepared to retry if the operation is not `DONE`.
         */
        await gapi.client.compute.zoneOperations.wait({
            operation: "Test string",
            project: "Test string",
            zone: "Test string",
        });
        /** Returns the specified Zone resource. */
        await gapi.client.compute.zones.get({
            project: "Test string",
            zone: "Test string",
        });
        /** Retrieves the list of Zone resources available to the specified project. */
        await gapi.client.compute.zones.list({
            filter: "Test string",
            maxResults: 42,
            orderBy: "Test string",
            pageToken: "Test string",
            project: "Test string",
            returnPartialSuccess: true,
        });
    }
});
