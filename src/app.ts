import sortObject from 'deep-sort-object';
import {ProxySetting} from 'get-proxy-settings';
import _ from 'lodash';
import fs from 'node:fs';
import {copyFile} from 'node:fs/promises';
import path, {basename, join} from 'node:path';
import {
  fallbackDocumentationLinks,
  revisionPrefix,
  zeroWidthJoinerCharacter,
} from './constants.js';
import {
  getAllDiscoveryItems,
  getRestDescriptionIfPossible,
  getRestDescriptionsForService,
} from './discovery.js';
import {Template, TemplateData} from './template/index.js';
import {
  checkExists,
  ensureDirectoryExists,
  getAllNamespaces,
  getPackageNameFromRestDescription,
  getResourceTypeName,
  getRevision,
  majorAndMinorVersion,
  sameNamespace,
  setOutputGHActions,
} from './utils.js';
import {StreamWriter, TextWriter} from './writer.js';
import {AstTypescriptTextWriter} from './ast-typescript-writer.js';

type JsonSchema = gapi.client.discovery.JsonSchema;
type RestResource = gapi.client.discovery.RestResource;
type RestDescription = gapi.client.discovery.RestDescription;
type RestMethod = gapi.client.discovery.RestMethod;

const typesMap: {[key: string]: string} = {
  integer: 'number',
  object: 'any',
  any: 'any',
  string: 'string',
};

export const excludedRestDescriptionIds: NonNullable<RestDescription['id']>[] =
  [
    'apigee:v1',
    'clouddebugger:v2', // cspell:words clouddebugger
    'poly:v1', // Google Poly was shut down on June 30, 2021; The Discovery API returns 5xx error
  ];

const generatedDisclaimer = [
  'IMPORTANT',
  'This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.',
  'In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator',
];
const writeGeneratedDisclaimer = (writer: AstTypescriptTextWriter) =>
  generatedDisclaimer.map(line => writer.writeLine(`// ${line}`));

const irregularSpaces = [
  // eslint-disable-next-line no-control-regex
  /\u000B/g, // Line Tabulation (\v) - <VT>
  // eslint-disable-next-line no-control-regex
  /\u000C/g, // Form Feed (\f) - <FF>
  /\u00A0/g, // No-Break Space - <NBSP>
  /\u0085/g, // Next Line
  /\u1680/g, // Ogham Space Mark
  /\u180E/g, // Mongolian Vowel Separator - <MVS>
  /\ufeff/g, // Zero Width No-Break Space - <BOM>
  /\u2000/g, // En Quad
  /\u2001/g, // Em Quad
  /\u2002/g, // En Space - <ENSP>
  /\u2003/g, // Em Space - <EMSP>
  /\u2004/g, // Tree-Per-Em
  /\u2005/g, // Four-Per-Em
  /\u2006/g, // Six-Per-Em
  /\u2007/g, // Figure Space
  /\u2008/g, // Punctuation Space - <PUNCSP>
  /\u2009/g, // Thin Space
  /\u200A/g, // Hair Space
  /\u200B/g, // Zero Width Space - <ZWSP>
  /\u2028/g, // Line Separator
  /\u2029/g, // Paragraph Separator
  /\u202F/g, // Narrow No-Break Space
  /\u205f/g, // Medium Mathematical Space
  /\u3000/g, // Ideographic Space
];

const jsdocComment = {start: '/**', end: '*/'};

export class IndentedTextWriter {
  constructor(
    private writer: TextWriter,
    public newLine = '\n',
    public tabString = '    ',
  ) {}

  public indent = 0;

  write(chunk: string) {
    this.writer.write(chunk);
  }

  startIndentedLine(chunk = '') {
    this.write(Array(this.indent + 1).join(this.tabString) + chunk);
  }

  endIndentedLine(chunk = '') {
    this.write(chunk + Array(this.indent + 1).join(this.tabString));
  }

  writeLine(chunk = '') {
    this.startIndentedLine(chunk + this.newLine);
  }

  writeNewLine(chunk = '') {
    this.endIndentedLine(chunk + this.newLine);
  }

  async end() {
    await this.writer.end();
  }
}

type TypescriptWriterCallback = (writer: AstTypescriptTextWriter) => void;

function formatPropertyName(name: string) {
  if (name.includes('.') || name.includes('-') || name.includes('@')) {
    return `"${name}"`;
  }
  return name;
}

function getName(path: string | undefined): string | undefined {
  if (!path) {
    return undefined;
  }
  const parts = path.split('.');

  if (parts.length > 0) {
    return _.last(parts);
  } else {
    return undefined;
  }
}

function getType(
  type: JsonSchema,
  schemas: Record<string, JsonSchema>,
): string | TypescriptWriterCallback {
  if (type.type === 'array') {
    const child = getType(checkExists(type.items), schemas);

    if (typeof child === 'string') {
      return `${child}[]`;
    } else if (typeof child === 'function') {
      return (writer: AstTypescriptTextWriter) => {
        writer.write('Array<');
        child(writer);
        writer.write('>');
      };
    } else {
      return '[]';
    }
  } else if (type.type === 'object' && type.properties) {
    return (writer: AstTypescriptTextWriter) => {
      writer.anonymousType(() => {
        _.forEach(type.properties, (property, propertyName) => {
          if (property.description) {
            writer.comment(formatComment(property.description));
          }
          writer.property(
            propertyName,
            getType(property, schemas),
            property.required || false,
          );
        });

        if (type.additionalProperties) {
          writer.property(
            '[key: string]',
            getType(type.additionalProperties, schemas),
          );
        }
      });
    };
  } else if (type.type === 'object' && type.additionalProperties) {
    return (writer: AstTypescriptTextWriter) => {
      const child = getType(checkExists(type.additionalProperties), schemas);
      // Record<K, T> (workaround for https://github.com/Maxim-Mazurok/google-api-typings-generator/issues/206)
      writer.write('{ [P in string]: ');
      writer.write(child);
      writer.write(' }');
    };
  } else if (type.type) {
    const tsType = typesMap[type.type] || type.type;
    return type.repeated ? `${tsType} | ${tsType}[]` : tsType;
  } else if (type.$ref) {
    const referencedType = schemas[type.$ref];

    if (isEmptySchema(referencedType)) {
      return 'any';
    }

    return type.$ref;
  } else throw Error();
}

function formatComment(comment: string) {
  if (!comment) return '';

  return comment;
}

function getMethodReturn(
  method: RestMethod,
  schemas: Record<string, JsonSchema>,
) {
  const name = schemas['Request'] ? 'client.Request' : 'Request';

  if (method.response) {
    const emptyObject = `${name}<{}>`;

    if (
      _.isEqual(method.response, {
        // workaround for https://identitytoolkit.googleapis.com/$discovery/rest?version=v1
        additionalProperties: {
          type: 'any',
          description: 'Properties of the object.',
        },
        type: 'object',
      })
    ) {
      return emptyObject;
    }

    if (_.isEqual(method.response, {type: 'string'})) {
      // workaround for https://tagmanager.googleapis.com/$discovery/rest?version=v2
      return `${name}<string>`;
    }

    const schema = schemas[checkExists(method.response.$ref)];

    if (schema && !_.isEmpty(schema.properties)) {
      return `${name}<${method.response.$ref}>`;
    } else {
      return emptyObject;
    }
  } else {
    return `${name}<void>`;
  }
}

const readmeTpl = new Template('readme.dot');
const packageJsonTpl = new Template('package-json.dot');

function isEmptySchema(schema: JsonSchema) {
  return _.isEmpty(schema.properties) && !schema.additionalProperties;
}

export interface Configuration {
  discoveryJsonDirectory?: string; // temporary directory to cache discovery service JSON
  proxy?: ProxySetting;
  typesDirectory: string;
  bannedTypes: string[];
  owners: string[];
}

export class App {
  private seenSchemaRefs: Set<string> = new Set();

  constructor(private readonly config: Configuration) {
    ensureDirectoryExists(config.typesDirectory);

    console.log(`types directory: ${config.typesDirectory}\n`);
  }

  static parseOutPath(dir: string) {
    ensureDirectoryExists(dir);

    return dir;
  }

  /**
   * Creates a callback that writes request parameters.
   */
  private static createRequestParameterWriterCallback(
    parameters: Record<string, JsonSchema>,
    schemas: Record<string, JsonSchema>,
    ref?: string,
  ) {
    return function requestParameterWriterCallback(
      writer: AstTypescriptTextWriter,
    ) {
      writer.anonymousType(() => {
        _.forEach(parameters, (data, key) => {
          if (data.description) {
            writer.comment(formatComment(data.description));
          }

          writer.property(key, getType(data, schemas), Boolean(data.required));
        });

        if (ref) {
          writer.comment('Request body');
          writer.property('resource', ref, true);
        }
      });
    };
  }

  /**
   * Writes specified resource definition.
   */
  private writeResources(
    out: AstTypescriptTextWriter,
    resources: Record<string, RestResource>,
    parameters: Record<string, JsonSchema> = {},
    schemas: Record<string, JsonSchema>,
    namespace: string,
  ): string[] {
    const writtenTopLevelResourceNames: string[] = [];

    _.forEach(resources, (resource, resourceName) => {
      const resourceInterfaceName = getResourceTypeName(resourceName);

      let writtenResources: string[] = [];

      if (resource.resources !== undefined) {
        writtenResources = this.writeResources(
          out,
          resource.resources,
          parameters,
          schemas,
          namespace,
        );
      }

      const allMethods = Object.entries(resource.methods || {});

      const methods = allMethods
        .filter(([, method]) => sameNamespace(method.id, namespace))
        .filter(([methodName]) => !writtenResources.includes(methodName)); // see `resource takes precedence to method on the same level with the same name` test in gapi

      const supposedToBeEmpty =
        allMethods.length === 0 &&
        (resource.resources === undefined ||
          Object.keys(resource.resources).length === 0);

      const resourceHasNamespaceDeep =
        getAllNamespaces(resource).includes(namespace);

      if (
        !supposedToBeEmpty &&
        methods.length === 0 &&
        resourceHasNamespaceDeep === false
      ) {
        // this interface isn't supposed to be empty and it/kids doesn't have any methods in this namespace - so don't print it
        return;
      }

      out.interface(resourceInterfaceName, () => {
        writtenTopLevelResourceNames.push(resourceName);
        methods.forEach(([methodName, method]) => {
          if (method.description) {
            out.comment(formatComment(method.description));
          }

          const requestRef = method.request?.$ref;
          const requestParameters: Record<string, JsonSchema> = sortObject({
            ...parameters,
            ...method.parameters,
          });

          if (!requestParameters.resource || !requestRef) {
            // generate method(request)
            out.method(
              formatPropertyName(checkExists(getName(methodName))),
              [
                {
                  parameter: 'request',
                  type: App.createRequestParameterWriterCallback(
                    requestParameters,
                    schemas,
                    requestRef,
                  ),
                  required: Boolean(requestRef),
                },
              ],
              getMethodReturn(method, schemas),
            );
          }

          if (requestRef) {
            // generate method(request, body)
            out.method(
              formatPropertyName(checkExists(getName(methodName))),
              [
                {
                  parameter: 'request',
                  type: App.createRequestParameterWriterCallback(
                    requestParameters,
                    schemas,
                  ),
                  required: true,
                },
                {
                  parameter: 'body',
                  type: requestRef,
                  required: true,
                },
              ],
              getMethodReturn(method, schemas),
            );
          }
        });

        if (resource.resources) {
          _.forEach(resource.resources, (childResource, childResourceName) => {
            if (!getAllNamespaces(childResource).includes(namespace)) return;

            const childResourceInterfaceName =
              getResourceTypeName(childResourceName);
            out.property(childResourceName, childResourceInterfaceName);
          });
        }
      });
    });

    return _.uniq(writtenTopLevelResourceNames).sort();
  }

  /// writes api description for specified JSON object
  private async processApi(
    destinationDirectory: string,
    restDescription: RestDescription,
    restDescriptionSource: URL,
    namespaces: string[],
  ) {
    console.log(
      `Generating ${restDescription.id} definitions... ${
        (restDescription.labels && restDescription.labels.join(', ')) || ''
      }`,
    );

    const stream = fs.createWriteStream(
      path.join(destinationDirectory, 'index.d.ts'),
    );
    const writer = new AstTypescriptTextWriter(
      new IndentedTextWriter(new StreamWriter(stream)),
      this.config.bannedTypes,
    );

    writer.writeLine(
      `/* Type definitions for non-npm package ${checkExists(
        restDescription.title,
      )} ${restDescription.version} ${majorAndMinorVersion} */`,
    );
    writer.writeLine(`// Project: ${restDescription.documentationLink}`);
    this.config.owners.forEach((owner, index) =>
      writer.writeLine(
        index === 0
          ? `// Definitions by: ${owner}`
          : `//                 ${owner}`,
      ),
    );

    writer.writeLine(
      '// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped',
    );
    writer.writeLine();
    writeGeneratedDisclaimer(writer);
    writer.writeLine(`// Generated from: ${restDescriptionSource}`);
    writer.writeLine(`${revisionPrefix}${restDescription.revision}`);
    writer.writeLine();
    writer.referenceTypes('gapi.client');

    // write main namespace
    writer.declareNamespace('gapi.client', () => {
      writer.comment(
        formatComment(
          `Load ${restDescription.title} ${restDescription.version}`,
        ),
      );

      writer.method(
        'function load',
        [
          {
            parameter: 'urlOrObject',
            type: `"${restDescriptionSource}"`,
            required: true,
          },
        ],
        'Promise<void>',
        true,
      );

      writer.comment('@deprecated Please load APIs with discovery documents.');

      writer.method(
        'function load',
        [
          {
            parameter: 'name',
            type: `"${restDescription.name}"`,
            required: true,
          },
          {
            parameter: 'version',
            type: `"${restDescription.version}"`,
            required: true,
          },
        ],
        'Promise<void>',
        true,
      );

      writer.comment('@deprecated Please load APIs with discovery documents.');

      writer.method(
        'function load',
        [
          {
            parameter: 'name',
            type: `"${restDescription.name}"`,
            required: true,
          },
          {
            parameter: 'version',
            type: `"${restDescription.version}"`,
            required: true,
          },
          {parameter: 'callback', type: '() => any', required: true},
        ],
        'void',
        true,
      );

      // expose root resources to gapi.client namespace

      writer.endLine();

      namespaces.forEach(namespace => {
        writer.namespace(namespace, () => {
          const schemas = checkExists(restDescription.schemas);
          _.forEach(schemas, schema => {
            writer.interface(checkExists(schema.id), () => {
              if (schema.properties) {
                _.forEach(schema.properties, (data, key) => {
                  if (data.description) {
                    writer.comment(formatComment(data.description));
                  }
                  writer.property(
                    key,
                    getType(data, schemas),
                    data.required || false,
                  );
                });
              }

              if (schema.additionalProperties) {
                writer.property(
                  '[key: string]',
                  getType(schema.additionalProperties, schemas),
                );
              }
            });
          });

          if (restDescription.resources) {
            const writtenResources = this.writeResources(
              writer,
              restDescription.resources,
              restDescription.parameters,
              schemas,
              namespace,
            );

            writtenResources.forEach(resourceName => {
              writer.endLine();
              writer.writeLine(
                `const ${resourceName}: ${getResourceTypeName(resourceName)};`,
              );
            });
          }
        });
      });
    });

    await writer.end();
  }

  async processService(
    restDescription: RestDescription,
    restDescriptionSource: URL,
    newRevisionsOnly = false,
  ) {
    restDescription = sortObject(restDescription);
    restDescription.id = checkExists(restDescription.id);
    restDescription.name = checkExists(restDescription.name);
    const packageName = getPackageNameFromRestDescription(restDescription);

    console.log(`Processing service with ID ${restDescription.id}...`);

    restDescription.documentationLink =
      restDescription.documentationLink ||
      fallbackDocumentationLinks[restDescription.id];

    if (!restDescription.documentationLink) {
      throw `No documentationLink found for service with ID ${restDescription.id}, can't write required Project header, aborting`;
    }

    const destinationDirectory = path.join(
      this.config.typesDirectory,
      packageName,
    );

    if (this.config.discoveryJsonDirectory) {
      fs.writeFileSync(
        join(
          this.config.discoveryJsonDirectory,
          `${basename(destinationDirectory)}.json`,
        ),
        JSON.stringify(restDescription),
      );
    }

    ensureDirectoryExists(destinationDirectory);
    const indexDTSPath = path.join(destinationDirectory, 'index.d.ts');

    if (newRevisionsOnly && fs.existsSync(indexDTSPath)) {
      if (!restDescription.revision) {
        return console.error(
          `There's no revision in JSON of service with ID: ${restDescription.id}`,
        );
      }

      let existingRevision = getRevision(indexDTSPath);

      if (!existingRevision) {
        console.error(
          `Can't find previous revision in index.d.ts: ${restDescription.id}`,
        );
        existingRevision = Infinity; // to avoid loop that happened with compute:v1, always update when can't find previous revision
      }

      const newRevision = Number(restDescription.revision);
      if (existingRevision > newRevision) {
        return console.warn(
          `Local revision ${existingRevision} is more recent than fetched ${newRevision}, skipping ${restDescription.id}`,
        );
      }
    }

    const namespaces = getAllNamespaces(restDescription);

    await this.processApi(
      destinationDirectory,
      restDescription,
      restDescriptionSource,
      namespaces,
    );

    const templateData: TemplateData = {
      restDescription,
      restDescriptionSource: restDescriptionSource.toString(),
      namespaces,
      packageName,
      majorAndMinorVersion,
    };

    await readmeTpl.write(
      path.join(destinationDirectory, 'readme.md'),
      templateData,
    );
    await packageJsonTpl.write(
      path.join(destinationDirectory, 'package.json'),
      templateData,
    );

    await Promise.all(
      ['.npmIgnore'.toLowerCase(), '.eslintrc.json', 'tsconfig.json'].map(
        fileName =>
          copyFile(
            path.join(
              import.meta.dirname,
              'template',
              `template.${fileName}`, // can't use just fileName, because tsconfig.json will act like a real config for the index.ts inside of template folder
            ),
            path.join(destinationDirectory, fileName),
          ),
      ),
    );

    await this.writeTests(
      destinationDirectory,
      restDescription,
      restDescriptionSource,
      namespaces,
    );
  }

  private writePropertyValue(
    scope: AstTypescriptTextWriter,
    api: RestDescription,
    property: JsonSchema,
  ) {
    switch (property.type) {
      case 'number':
      case 'integer':
        scope.write('42');
        break;
      case 'boolean':
        scope.write('true');
        break;
      case 'string':
        scope.write('"Test string"');
        break;
      case 'array':
        this.writeArray(scope, api, checkExists(property.items));
        break;
      case 'object':
        this.writeObject(scope, api, property);
        break;
      case 'any':
        scope.write('42');
        break;
      default:
        throw new Error(`Unknown scalar type ${property.type}`);
    }
  }

  private writeArray(
    scope: AstTypescriptTextWriter,
    api: RestDescription,
    items: JsonSchema,
  ) {
    const schemaName = items.$ref;
    if (schemaName && this.seenSchemaRefs.has(schemaName)) {
      // Break out of recursive reference by writing undefined
      scope.write('undefined');
      return;
    }

    scope.scope(
      () => {
        scope.newLine('');
        if (schemaName) {
          this.writeSchemaRef(scope, api, schemaName);
        } else {
          this.writePropertyValue(scope, api, items);
        }
        scope.endLine();
      },
      '[',
      ']',
    );
  }

  private writeObject(
    scope: AstTypescriptTextWriter,
    api: RestDescription,
    object: JsonSchema,
  ) {
    const schemaName = object.additionalProperties?.$ref;
    if (schemaName && this.seenSchemaRefs.has(schemaName)) {
      scope.write('undefined');
      return;
    }
    if (object.properties) {
      // If the object has properties, only write that structure
      scope.scope(() => {
        this.writeProperties(scope, api, object.properties!);
      });
      return;
    } else if (object.additionalProperties) {
      // Otherwise, we have a Record<K, V> and we should write a placeholder key
      scope.scope(() => {
        scope.newLine('A: ');
        if (schemaName) {
          this.writeSchemaRef(scope, api, schemaName);
        } else {
          this.writePropertyValue(scope, api, object.additionalProperties!);
        }
        scope.endLine();
      });
    } else {
      this.writePropertyValue(scope, api, object);
    }
  }

  // Performs a lookup of the specified interface/schema type and recursively generates stubbed values
  private writeSchemaRef(
    scope: AstTypescriptTextWriter,
    api: RestDescription,
    schemaName: string,
  ) {
    if (this.seenSchemaRefs.has(schemaName)) {
      // Break out of recursive reference by writing undefined
      scope.write('undefined');
      return;
    }

    const schema = checkExists(api.schemas)[schemaName];
    if (!schema) {
      throw new Error(
        `Attempted to generate stub for unknown schema '${schemaName}'`, // maybe we can just use `any` in this case? On one hand - less maintenance. On other hand - it caught an error with integrations:v1 and after reporting it to Google it was fixed.
      );
    }

    this.seenSchemaRefs.add(schemaName);
    this.writeObject(scope, api, schema);
    this.seenSchemaRefs.delete(schemaName);
  }

  private writeProperties(
    scope: AstTypescriptTextWriter,
    api: RestDescription,
    record: Record<string, JsonSchema>,
  ) {
    _.forEach(record, (parameter, name) => {
      scope.newLine(`${formatPropertyName(name)}: `);
      if (parameter.type === 'object') {
        this.writeObject(scope, api, parameter);
      } else if (parameter.$ref) {
        this.writeSchemaRef(scope, api, parameter.$ref);
      } else {
        this.writePropertyValue(scope, api, parameter);
      }
      scope.endLine(',');
    });
  }

  private writeResourceTests(
    scope: AstTypescriptTextWriter,
    api: RestDescription,
    ancestors: string,
    resourceName: string,
    resource: RestResource,
    namespace: string,
  ) {
    resourceName = resourceName.includes('-')
      ? `["${resourceName}"]`
      : `.${resourceName}`;

    _.forEach(resource.methods, (method, methodName) => {
      if (
        Object.prototype.hasOwnProperty.call(resource, 'resources') &&
        Object.prototype.hasOwnProperty.call(resource.resources, methodName)
      ) {
        return; // see `resource takes precedence to method on the same level with the same name` test in gapi
      }

      methodName = methodName.includes('-')
        ? `["${methodName}"]`
        : `.${methodName}`;
      if (sameNamespace(method.id, namespace)) {
        scope.comment(method.description);
        scope.newLine(`await ${ancestors}${resourceName}${methodName}(`); // TODO: figure out if gapi uses names or id

        const params: Record<string, JsonSchema> | undefined =
          method.parameters;
        const ref = method.request?.$ref;

        if (params) {
          scope.scope(() => {
            this.writeProperties(scope, api, params);
          });
        }

        if (ref) {
          if (!params) {
            scope.write('{} ');
          }

          scope.write(', ');

          this.writeSchemaRef(scope, api, ref);
        }

        scope.endLine(');');
      }
    });

    _.forEach(resource.resources, (subResource, subResourceName) => {
      this.writeResourceTests(
        scope,
        api,
        `${ancestors}${resourceName}`,
        subResourceName,
        subResource,
        namespace,
      );
    });
  }

  private async writeTests(
    destinationDirectory: string,
    api: RestDescription,
    restDescriptionSource: URL,
    namespaces: string[],
  ) {
    const packageName = getPackageNameFromRestDescription(api);

    const stream = fs.createWriteStream(
        path.join(destinationDirectory, 'tests.ts'),
      ),
      writer = new AstTypescriptTextWriter(
        new IndentedTextWriter(new StreamWriter(stream)),
        this.config.bannedTypes,
      );

    writer.writeLine(
      `/* This is stub file for ${packageName} definition tests */`,
    );
    writeGeneratedDisclaimer(writer);
    writer.writeLine();
    writer.writeLine(`${revisionPrefix}${api.revision}`);
    writer.writeLine();
    writer.newLine("gapi.load('client', async () => ");
    writer.scope(writer3 => {
      writer3.comment('now we can use gapi.client');
      writer3.endLine();
      writer3.writeLine(`await gapi.client.load('${restDescriptionSource}');`);
      writer3.comment(
        `now we can use ${namespaces.map(x => `gapi.client.${x}`).join(', ')}`,
      );
      writer3.endLine();
      if (api.auth) {
        writer3.comment(
          "don't forget to authenticate your client before sending any request to resources:",
        );
        writer3.comment(
          'declare client_id registered in Google Developers Console',
        );

        writer3.writeLine("const client_id = '<<PUT YOUR CLIENT ID HERE>>';");
        writer3.newLine('const scope = ');
        writer3.scope(
          () => {
            const oauth2 = checkExists(api?.auth?.oauth2);
            _.forEach(oauth2.scopes, (value, scope) => {
              writer3.comment(value.description);
              writer3.writeLine(`'${scope}',`);
            });
          },
          '[',
          ']',
        );

        writer3.endLine(';');
        writer3.writeLine('const immediate = false;');
        writer3.newLine(
          'gapi.auth.authorize({ client_id, scope, immediate }, authResult => ',
        );

        writer3.scope(scope => {
          writer3.newLine('if (authResult && !authResult.error) ');
          scope.scope(a => {
            a.comment('handle successful authorization');
            a.writeLine('void run();');
          });
          scope.write(' else ');
          scope.scope(() => {
            scope.comment('handle authorization error');
          });
          writer3.endLine();
        });

        writer3.endLine(');');
      } else {
        writer3.writeLine('void run();');
      }

      writer3.endLine();
      writer3.newLine('async function run() ');
      writer.scope(scope => {
        namespaces.forEach(namespace => {
          _.forEach(api.resources, (resource, resourceName) => {
            this.writeResourceTests(
              scope,
              api,
              `gapi.client.${namespace}`,
              resourceName,
              resource,
              namespace,
            );
          });
        });
      });

      writer3.endLine();
    });
    writer.endLine(');');
    await writer.end();
  }

  async discover(service: string | undefined, newRevisionsOnly = false) {
    console.log('Discovering Google services...');

    if (service) {
      const serviceRestDescriptions = await getRestDescriptionsForService(
        service,
        this.config.proxy,
      );
      for (const {
        restDescription,
        restDescriptionSource,
      } of serviceRestDescriptions) {
        try {
          await this.processService(
            restDescription,
            restDescriptionSource,
            newRevisionsOnly,
          );
        } catch (e) {
          console.error(e);
          throw Error(`Error processing service: ${restDescription.name}`);
        }
      }
    } else {
      const discoveryItems = (
        await getAllDiscoveryItems(this.config.proxy)
      ).filter(
        discoveryItem =>
          !excludedRestDescriptionIds.includes(checkExists(discoveryItem.id)),
      );

      if (discoveryItems.length === 0) {
        throw Error("Can't find services");
      }

      let failedFetchesCount = 0;

      discoveryItems.forEach(async discoveryItem => {
        const restDescriptionSource = new URL(
          checkExists(discoveryItem.discoveryRestUrl),
        );
        let restDescription;
        try {
          restDescription = await getRestDescriptionIfPossible(
            restDescriptionSource,
            this.config.proxy,
          );
        } catch (e) {
          console.warn(e);
          failedFetchesCount++;
          if (failedFetchesCount >= 5) {
            throw Error(
              `Failed to fetch ${failedFetchesCount} services, potentially something is wrong, please check.`,
            );
          }
        }

        if (!restDescription) return;

        try {
          await this.processService(
            restDescription,
            restDescriptionSource,
            newRevisionsOnly,
          );
        } catch (e) {
          console.error(e);
          setOutputGHActions(
            'FAILED_TYPE',
            getPackageNameFromRestDescription(restDescription),
          );
          throw Error(`Error processing service: ${restDescription.name}`);
        }
      });
    }
  }
}
