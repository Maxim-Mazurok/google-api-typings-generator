/* Type definitions for non-npm package Checks API v1alpha 0.0 */
// Project: https://developers.google.com/checks
// Definitions by: Maxim Mazurok <https://github.com/Maxim-Mazurok>
//                 Nick Amoscato <https://github.com/namoscato>
//                 Declan Vong <https://github.com/declanvong>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator
// Generated from: https://checks.googleapis.com/$discovery/rest?version=v1alpha
// Revision: 20230627

/// <reference types="gapi.client" />

declare namespace gapi.client {
    /** Load Checks API v1alpha */
    function load(urlOrObject: "https://checks.googleapis.com/$discovery/rest?version=v1alpha"): Promise<void>;
    /** @deprecated Please load APIs with discovery documents. */
    function load(name: "checks", version: "v1alpha"): Promise<void>;
    /** @deprecated Please load APIs with discovery documents. */
    function load(name: "checks", version: "v1alpha", callback: () => any): void;

    namespace checks {
        interface AnalyzePrivacyPolicyRequest {
            /** Web page raw HTML content for the privacy policy page to be analyzed. Useful when the client wants to analyze a privacy policy already fetched. */
            privacyPolicyPageContent?:
                string;
            /** URL for the privacy policy page to be analyzed. https://linter.aip.dev/140/uri (Use `uri` instead of `url` in field name) */
            privacyPolicyUri?:
                string;
        }
        interface AnalyzePrivacyPolicyResponse {
            /** List of all data types in the privacy policy. */
            dataPurposeAnnotations?:
                PolicyPurposeOfUseAnnotation[];
            /** List of all data types in the privacy policy. */
            dataTypeAnnotations?:
                PolicyDataTypeAnnotation[];
            /** HTML content for the privacy policy page. */
            htmlContent?:
                string;
            /** Information about the date when the privacy policy was last updated. */
            lastUpdatedDateInfo?:
                LastUpdatedDate;
            /** List of all sections in the privacy policy. */
            sectionAnnotations?:
                PolicySectionAnnotation[];
        }
        interface Date {
            /** Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant. */
            day?:
                number;
            /** Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day. */
            month?:
                number;
            /** Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year. */
            year?:
                number;
        }
        interface LastUpdatedDate {
            /** Byte offsets for the end of the date text inside the full text. */
            endOffset?:
                string;
            /** Date when the privacy policy was last updated. */
            lastUpdatedDate?:
                Date;
            /** Byte offsets for the start of the date text inside the full text. */
            startOffset?:
                string;
            /** The bytes of actual text content in the section. NOTE: - This will correspond to the whole sentence that includes the date. - This field might contain HTML and it is not sanitized. */
            textContent?:
                string;
        }
        interface Operation {
            /** If the value is `false`, it means the operation is still in progress. If `true`, the operation is completed, and either `error` or `response` is available. */
            done?:
                boolean;
            /** The error result of the operation in case of failure or cancellation. */
            error?:
                Status;
            /**
             * Service-specific metadata associated with the operation. It typically contains progress information and common metadata such as create time. Some services might not provide such
             * metadata. Any method that returns a long-running operation should document the metadata type, if any.
             */
            metadata?:
                { [P in string]: any };
            /**
             * The server-assigned name, which is only unique within the same service that originally returns it. If you use the default HTTP mapping, the `name` should be a resource name ending
             * with `operations/{unique_id}`.
             */
            name?:
                string;
            /**
             * The normal response of the operation in case of success. If the original method returns no data on success, such as `Delete`, the response is `google.protobuf.Empty`. If the
             * original method is standard `Get`/`Create`/`Update`, the response should be the resource. For other methods, the response should have the type `XxxResponse`, where `Xxx` is the
             * original method name. For example, if the original method name is `TakeSnapshot()`, the inferred response type is `TakeSnapshotResponse`.
             */
            response?:
                { [P in string]: any };
        }
        interface PolicyDataTypeAnnotation {
            /** Type of the data mentioned in the policy. */
            dataType?:
                string;
            /** Byte offsets for the end of the data type sentence inside the full text. */
            endOffset?:
                string;
            /** Score given by the model representing how confident it was regarding this `text_content` being of `data_type`. */
            score?:
                number;
            /** Byte offsets for the start of the data type sentence inside the full text. */
            startOffset?:
                string;
            /**
             * Actual text content in the section. This makes it much easier to consume the information. NOTE: This field might contain HTML and does not guarantee a SafeHtml security contract
             * go/safehtmltypecontracts#safehtml.
             */
            textContent?:
                string;
        }
        interface PolicyPurposeOfUseAnnotation {
            /** Byte offsets for the end of the purpose of use sentence inside the full text. */
            endOffset?:
                string;
            /** Purpose of use mentioned in the policy. */
            purposeOfUse?:
                string;
            /** Score given by the model representing how confident it was regarding this `text_content` being of `purpose_of_use`. */
            score?:
                number;
            /** Byte offsets for the start of the purpose of use sentence inside the full text. */
            startOffset?:
                string;
            /**
             * The bytes of actual text content in the sentence that mentions the purpose of use. This makes it much easier to consume the information. NOTE: This field might contain HTML and does
             * not guarantee a SafeHtml security contract go/safehtmltypecontracts#safehtml.
             */
            textContent?:
                string;
        }
        interface PolicySectionAnnotation {
            /** Byte offsets for the end of the section inside the full text. */
            endOffset?:
                string;
            /** Score given by the model representing how confident it was regarding this `text_content` being of `section_type`. */
            score?:
                number;
            /** Type of the high-level category in the policy. */
            sectionType?:
                string;
            /** Byte offsets for the start of the section inside the full text. */
            startOffset?:
                string;
            /**
             * Actual text content in the section. This makes it much easier to consume the information. NOTE: This field might contain HTML and does not guarantee a SafeHtml security contract
             * go/safehtmltypecontracts#safehtml.
             */
            textContent?:
                string;
        }
        interface Status {
            /** The status code, which should be an enum value of google.rpc.Code. */
            code?:
                number;
            /** A list of messages that carry the error details. There is a common set of message types for APIs to use. */
            details?:
                Array<{ [P in string]: any }>;
            /**
             * A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the
             * client.
             */
            message?:
                string;
        }
        interface OperationsResource {
            /** Gets the latest state of a long-running operation. Clients can use this method to poll the operation result at intervals as recommended by the API service. */
            get(request?: {
                /** V1 error format. */
                "$.xgafv"?:
                    string;
                /** OAuth access token. */
                access_token?:
                    string;
                /** Data format for response. */
                alt?:
                    string;
                /** JSONP */
                callback?:
                    string;
                /** Selector specifying which fields to include in a partial response. */
                fields?:
                    string;
                /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
                key?:
                    string;
                /** The name of the operation resource. */
                name:
                    string;
                /** OAuth 2.0 token for the current user. */
                oauth_token?:
                    string;
                /** Returns response with indentations and line breaks. */
                prettyPrint?:
                    boolean;
                /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
                quotaUser?:
                    string;
                /** Upload protocol for media (e.g. "raw", "multipart"). */
                upload_protocol?:
                    string;
                /** Legacy upload protocol for media (e.g. "media", "multipart"). */
                uploadType?:
                    string;
            }): Request<Operation>;
        }
        interface AppsResource {
            operations:
                OperationsResource;
        }
        interface AccountsResource {
            apps:
                AppsResource;
        }
        interface PrivacypolicyResource {
            /** Analyzes the privacy policy of the given policy URL or content. */
            analyze(request: {
                /** V1 error format. */
                "$.xgafv"?:
                    string;
                /** OAuth access token. */
                access_token?:
                    string;
                /** Data format for response. */
                alt?:
                    string;
                /** JSONP */
                callback?:
                    string;
                /** Selector specifying which fields to include in a partial response. */
                fields?:
                    string;
                /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
                key?:
                    string;
                /** OAuth 2.0 token for the current user. */
                oauth_token?:
                    string;
                /** Returns response with indentations and line breaks. */
                prettyPrint?:
                    boolean;
                /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
                quotaUser?:
                    string;
                /** Upload protocol for media (e.g. "raw", "multipart"). */
                upload_protocol?:
                    string;
                /** Legacy upload protocol for media (e.g. "media", "multipart"). */
                uploadType?:
                    string;
                /** Request body */
                resource:
                    AnalyzePrivacyPolicyRequest;
            }): Request<AnalyzePrivacyPolicyResponse>;
            analyze(request: {
                /** V1 error format. */
                "$.xgafv"?:
                    string;
                /** OAuth access token. */
                access_token?:
                    string;
                /** Data format for response. */
                alt?:
                    string;
                /** JSONP */
                callback?:
                    string;
                /** Selector specifying which fields to include in a partial response. */
                fields?:
                    string;
                /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
                key?:
                    string;
                /** OAuth 2.0 token for the current user. */
                oauth_token?:
                    string;
                /** Returns response with indentations and line breaks. */
                prettyPrint?:
                    boolean;
                /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
                quotaUser?:
                    string;
                /** Upload protocol for media (e.g. "raw", "multipart"). */
                upload_protocol?:
                    string;
                /** Legacy upload protocol for media (e.g. "media", "multipart"). */
                uploadType?:
                    string;
            },
            body: AnalyzePrivacyPolicyRequest): Request<AnalyzePrivacyPolicyResponse>;
        }

        const accounts: AccountsResource;

        const privacypolicy: PrivacypolicyResource;
    }
}
