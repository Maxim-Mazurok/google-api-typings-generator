/* This is stub file for gapi.client.firebaseappcheck-v1 definition tests */
// IMPORTANT
// This file was generated by https://github.com/Maxim-Mazurok/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Maxim-Mazurok/google-api-typings-generator

// Revision: 20220812

gapi.load('client', async () => {
    /** now we can use gapi.client */

    await gapi.client.load('https://firebaseappcheck.googleapis.com/$discovery/rest?version=v1');
    /** now we can use gapi.client.firebaseappcheck */

    /** don't forget to authenticate your client before sending any request to resources: */
    /** declare client_id registered in Google Developers Console */
    const client_id = '<<PUT YOUR CLIENT ID HERE>>';
    const scope = [
        /** See, edit, configure, and delete your Google Cloud data and see the email address for your Google Account. */
        'https://www.googleapis.com/auth/cloud-platform',
        /** View and administer all your Firebase data and settings */
        'https://www.googleapis.com/auth/firebase',
    ];
    const immediate = false;
    gapi.auth.authorize({ client_id, scope, immediate }, authResult => {
        if (authResult && !authResult.error) {
            /** handle successful authorization */
            run();
        } else {
            /** handle authorization error */
        }
    });

    async function run() {
        /**
         * Returns a public JWK set as specified by [RFC 7517](https://tools.ietf.org/html/rfc7517) that can be used to verify App Check tokens. Exactly one of the public keys in the returned set
         * will successfully validate any App Check token that is currently valid.
         */
        await gapi.client.firebaseappcheck.jwks.get({
            name: "Test string",
        });
        /** Accepts an App Attest assertion and an artifact previously obtained from ExchangeAppAttestAttestation and verifies those with Apple. If valid, returns an AppCheckToken. */
        await gapi.client.firebaseappcheck.projects.apps.exchangeAppAttestAssertion({
            app: "Test string",
        }, {
            artifact: "Test string",
            assertion: "Test string",
            challenge: "Test string",
        });
        /**
         * Accepts an App Attest CBOR attestation and verifies it with Apple using your preconfigured team and bundle IDs. If valid, returns an attestation artifact that can later be exchanged for
         * an AppCheckToken using ExchangeAppAttestAssertion. For convenience and performance, this method's response object will also contain an AppCheckToken (if the verification is successful).
         */
        await gapi.client.firebaseappcheck.projects.apps.exchangeAppAttestAttestation({
            app: "Test string",
        }, {
            attestationStatement: "Test string",
            challenge: "Test string",
            keyId: "Test string",
        });
        /** Validates a custom token signed using your project's Admin SDK service account credentials. If valid, returns an AppCheckToken. */
        await gapi.client.firebaseappcheck.projects.apps.exchangeCustomToken({
            app: "Test string",
        }, {
            customToken: "Test string",
        });
        /**
         * Validates a debug token secret that you have previously created using CreateDebugToken. If valid, returns an AppCheckToken. Note that a restrictive quota is enforced on this method to
         * prevent accidental exposure of the app to abuse.
         */
        await gapi.client.firebaseappcheck.projects.apps.exchangeDebugToken({
            app: "Test string",
        }, {
            debugToken: "Test string",
        });
        /**
         * Accepts a [`device_token`](https://developer.apple.com/documentation/devicecheck/dcdevice) issued by DeviceCheck, and attempts to validate it with Apple. If valid, returns an
         * AppCheckToken.
         */
        await gapi.client.firebaseappcheck.projects.apps.exchangeDeviceCheckToken({
            app: "Test string",
        }, {
            deviceToken: "Test string",
        });
        /** Validates an [integrity verdict response token from Play Integrity](https://developer.android.com/google/play/integrity/verdict#decrypt-verify). If valid, returns an AppCheckToken. */
        await gapi.client.firebaseappcheck.projects.apps.exchangePlayIntegrityToken({
            app: "Test string",
        }, {
            playIntegrityToken: "Test string",
        });
        /** Validates a [reCAPTCHA Enterprise response token](https://cloud.google.com/recaptcha-enterprise/docs/create-assessment#retrieve_token). If valid, returns an AppCheckToken. */
        await gapi.client.firebaseappcheck.projects.apps.exchangeRecaptchaEnterpriseToken({
            app: "Test string",
        }, {
            recaptchaEnterpriseToken: "Test string",
        });
        /** Validates a [reCAPTCHA v3 response token](https://developers.google.com/recaptcha/docs/v3). If valid, returns an AppCheckToken. */
        await gapi.client.firebaseappcheck.projects.apps.exchangeRecaptchaV3Token({
            app: "Test string",
        }, {
            recaptchaV3Token: "Test string",
        });
        /** Validates a [SafetyNet token](https://developer.android.com/training/safetynet/attestation#request-attestation-step). If valid, returns an AppCheckToken. */
        await gapi.client.firebaseappcheck.projects.apps.exchangeSafetyNetToken({
            app: "Test string",
        }, {
            safetyNetToken: "Test string",
        });
        /**
         * Generates a challenge that protects the integrity of an immediately following call to ExchangeAppAttestAttestation or ExchangeAppAttestAssertion. A challenge should not be reused for
         * multiple calls.
         */
        await gapi.client.firebaseappcheck.projects.apps.generateAppAttestChallenge({
            app: "Test string",
        }, {
        });
        /**
         * Generates a challenge that protects the integrity of an immediately following integrity verdict request to the Play Integrity API. The next call to ExchangePlayIntegrityToken using the
         * resulting integrity token will verify the presence and validity of the challenge. A challenge should not be reused for multiple calls.
         */
        await gapi.client.firebaseappcheck.projects.apps.generatePlayIntegrityChallenge({
            app: "Test string",
        }, {
        });
        /** Atomically gets the AppAttestConfigs for the specified list of apps. */
        await gapi.client.firebaseappcheck.projects.apps.appAttestConfig.batchGet({
            names: "Test string",
            parent: "Test string",
        });
        /** Gets the AppAttestConfig for the specified app. */
        await gapi.client.firebaseappcheck.projects.apps.appAttestConfig.get({
            name: "Test string",
        });
        /** Updates the AppAttestConfig for the specified app. While this configuration is incomplete or invalid, the app will be unable to exchange AppAttest tokens for App Check tokens. */
        await gapi.client.firebaseappcheck.projects.apps.appAttestConfig.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            name: "Test string",
            tokenTtl: "Test string",
        });
        /**
         * Creates a new DebugToken for the specified app. For security reasons, after the creation operation completes, the `token` field cannot be updated or retrieved, but you can revoke the
         * debug token using DeleteDebugToken. Each app can have a maximum of 20 debug tokens.
         */
        await gapi.client.firebaseappcheck.projects.apps.debugTokens.create({
            parent: "Test string",
        }, {
            displayName: "Test string",
            name: "Test string",
            token: "Test string",
        });
        /**
         * Deletes the specified DebugToken. A deleted debug token cannot be used to exchange for an App Check token. Use this method when you suspect the secret `token` has been compromised or
         * when you no longer need the debug token.
         */
        await gapi.client.firebaseappcheck.projects.apps.debugTokens.delete({
            name: "Test string",
        });
        /** Gets the specified DebugToken. For security reasons, the `token` field is never populated in the response. */
        await gapi.client.firebaseappcheck.projects.apps.debugTokens.get({
            name: "Test string",
        });
        /** Lists all DebugTokens for the specified app. For security reasons, the `token` field is never populated in the response. */
        await gapi.client.firebaseappcheck.projects.apps.debugTokens.list({
            pageSize: 42,
            pageToken: "Test string",
            parent: "Test string",
        });
        /**
         * Updates the specified DebugToken. For security reasons, the `token` field cannot be updated, nor will it be populated in the response, but you can revoke the debug token using
         * DeleteDebugToken.
         */
        await gapi.client.firebaseappcheck.projects.apps.debugTokens.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            displayName: "Test string",
            name: "Test string",
            token: "Test string",
        });
        /** Atomically gets the DeviceCheckConfigs for the specified list of apps. For security reasons, the `private_key` field is never populated in the response. */
        await gapi.client.firebaseappcheck.projects.apps.deviceCheckConfig.batchGet({
            names: "Test string",
            parent: "Test string",
        });
        /** Gets the DeviceCheckConfig for the specified app. For security reasons, the `private_key` field is never populated in the response. */
        await gapi.client.firebaseappcheck.projects.apps.deviceCheckConfig.get({
            name: "Test string",
        });
        /**
         * Updates the DeviceCheckConfig for the specified app. While this configuration is incomplete or invalid, the app will be unable to exchange DeviceCheck tokens for App Check tokens. For
         * security reasons, the `private_key` field is never populated in the response.
         */
        await gapi.client.firebaseappcheck.projects.apps.deviceCheckConfig.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            keyId: "Test string",
            name: "Test string",
            privateKey: "Test string",
            privateKeySet: true,
            tokenTtl: "Test string",
        });
        /** Atomically gets the PlayIntegrityConfigs for the specified list of apps. */
        await gapi.client.firebaseappcheck.projects.apps.playIntegrityConfig.batchGet({
            names: "Test string",
            parent: "Test string",
        });
        /** Gets the PlayIntegrityConfig for the specified app. */
        await gapi.client.firebaseappcheck.projects.apps.playIntegrityConfig.get({
            name: "Test string",
        });
        /** Updates the PlayIntegrityConfig for the specified app. While this configuration is incomplete or invalid, the app will be unable to exchange Play Integrity tokens for App Check tokens. */
        await gapi.client.firebaseappcheck.projects.apps.playIntegrityConfig.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            name: "Test string",
            tokenTtl: "Test string",
        });
        /** Atomically gets the RecaptchaEnterpriseConfigs for the specified list of apps. */
        await gapi.client.firebaseappcheck.projects.apps.recaptchaEnterpriseConfig.batchGet({
            names: "Test string",
            parent: "Test string",
        });
        /** Gets the RecaptchaEnterpriseConfig for the specified app. */
        await gapi.client.firebaseappcheck.projects.apps.recaptchaEnterpriseConfig.get({
            name: "Test string",
        });
        /**
         * Updates the RecaptchaEnterpriseConfig for the specified app. While this configuration is incomplete or invalid, the app will be unable to exchange reCAPTCHA Enterprise tokens for App
         * Check tokens.
         */
        await gapi.client.firebaseappcheck.projects.apps.recaptchaEnterpriseConfig.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            name: "Test string",
            siteKey: "Test string",
            tokenTtl: "Test string",
        });
        /** Atomically gets the RecaptchaV3Configs for the specified list of apps. For security reasons, the `site_secret` field is never populated in the response. */
        await gapi.client.firebaseappcheck.projects.apps.recaptchaV3Config.batchGet({
            names: "Test string",
            parent: "Test string",
        });
        /** Gets the RecaptchaV3Config for the specified app. For security reasons, the `site_secret` field is never populated in the response. */
        await gapi.client.firebaseappcheck.projects.apps.recaptchaV3Config.get({
            name: "Test string",
        });
        /**
         * Updates the RecaptchaV3Config for the specified app. While this configuration is incomplete or invalid, the app will be unable to exchange reCAPTCHA tokens for App Check tokens. For
         * security reasons, the `site_secret` field is never populated in the response.
         */
        await gapi.client.firebaseappcheck.projects.apps.recaptchaV3Config.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            name: "Test string",
            siteSecret: "Test string",
            siteSecretSet: true,
            tokenTtl: "Test string",
        });
        /** Atomically gets the SafetyNetConfigs for the specified list of apps. */
        await gapi.client.firebaseappcheck.projects.apps.safetyNetConfig.batchGet({
            names: "Test string",
            parent: "Test string",
        });
        /** Gets the SafetyNetConfig for the specified app. */
        await gapi.client.firebaseappcheck.projects.apps.safetyNetConfig.get({
            name: "Test string",
        });
        /** Updates the SafetyNetConfig for the specified app. While this configuration is incomplete or invalid, the app will be unable to exchange SafetyNet tokens for App Check tokens. */
        await gapi.client.firebaseappcheck.projects.apps.safetyNetConfig.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            name: "Test string",
            tokenTtl: "Test string",
        });
        /** Atomically updates the specified Service configurations. */
        await gapi.client.firebaseappcheck.projects.services.batchUpdate({
            parent: "Test string",
        }, {
            requests: [
                {
                    service: {
                        enforcementMode: "Test string",
                        name: "Test string",
                    },
                    updateMask: "Test string",
                }
            ],
            updateMask: "Test string",
        });
        /** Gets the Service configuration for the specified service name. */
        await gapi.client.firebaseappcheck.projects.services.get({
            name: "Test string",
        });
        /** Lists all Service configurations for the specified project. Only Services which were explicitly configured using UpdateService or BatchUpdateServices will be returned. */
        await gapi.client.firebaseappcheck.projects.services.list({
            pageSize: 42,
            pageToken: "Test string",
            parent: "Test string",
        });
        /** Updates the specified Service configuration. */
        await gapi.client.firebaseappcheck.projects.services.patch({
            name: "Test string",
            updateMask: "Test string",
        }, {
            enforcementMode: "Test string",
            name: "Test string",
        });
    }
});
